/*
 * Module code.
 *
 * Generated by SIP 4.19.15
 *
 * Copyright (c) 2019 Riverbank Computing Limited <info@riverbankcomputing.com>
 * 
 * This file is part of PyQt5.
 * 
 * This file may be used under the terms of the GNU General Public License
 * version 3.0 as published by the Free Software Foundation and appearing in
 * the file LICENSE included in the packaging of this file.  Please review the
 * following information to ensure the GNU General Public License version 3.0
 * requirements will be met: http://www.gnu.org/copyleft/gpl.html.
 * 
 * If you do not wish to use this file under the terms of the GPL version 3.0
 * then you may purchase a commercial license.  For more information contact
 * info@riverbankcomputing.com.
 * 
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "sipAPIQtSensors.h"

#line 42 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qirproximitysensor.sip"
#include <qirproximitysensor.h>
#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qirproximitysensor.sip"
#include <qirproximitysensor.h>
#line 33 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQIRProximityFilter : public  ::QIRProximityFilter
{
public:
    sipQIRProximityFilter();
    sipQIRProximityFilter(const  ::QIRProximityFilter&);
    virtual ~sipQIRProximityFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QIRProximityReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQIRProximityFilter(const sipQIRProximityFilter &);
    sipQIRProximityFilter &operator = (const sipQIRProximityFilter &);

    char sipPyMethods[1];
};

sipQIRProximityFilter::sipQIRProximityFilter():  ::QIRProximityFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQIRProximityFilter::sipQIRProximityFilter(const  ::QIRProximityFilter& a0):  ::QIRProximityFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQIRProximityFilter::~sipQIRProximityFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQIRProximityFilter::filter( ::QIRProximityReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QIRProximityFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_16(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QIRProximityReading*);

    return sipVH_QtSensors_16(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QIRProximityFilter_filter, "filter(self, QIRProximityReading) -> bool");

extern "C" {static PyObject *meth_QIRProximityFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QIRProximityFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QIRProximityReading* a0;
         ::QIRProximityFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QIRProximityFilter, &sipCpp, sipType_QIRProximityReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QIRProximityFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QIRProximityFilter, sipName_filter, doc_QIRProximityFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QIRProximityFilter(void *, const sipTypeDef *);}
static void *cast_QIRProximityFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QIRProximityFilter *sipCpp = reinterpret_cast< ::QIRProximityFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QIRProximityFilter(void *, int);}
static void release_QIRProximityFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQIRProximityFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QIRProximityFilter *>(sipCppV);
}


extern "C" {static void dealloc_QIRProximityFilter(sipSimpleWrapper *);}
static void dealloc_QIRProximityFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQIRProximityFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QIRProximityFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QIRProximityFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QIRProximityFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQIRProximityFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQIRProximityFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QIRProximityFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QIRProximityFilter, &a0))
        {
            sipCpp = new sipQIRProximityFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QIRProximityFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QIRProximityFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QIRProximityFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QIRProximityFilter_filter)}
};

PyDoc_STRVAR(doc_QIRProximityFilter, "\1QIRProximityFilter()\n"
"QIRProximityFilter(QIRProximityFilter)");


static pyqt5ClassPluginDef plugin_QIRProximityFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QIRProximityFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QIRProximityFilter,
        {SIP_NULLPTR},
        &plugin_QIRProximityFilter
    },
    {
        sipNameNr_QIRProximityFilter,
        {0, 0, 1},
        1, methods_QIRProximityFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QIRProximityFilter,
    -1,
    -1,
    supers_QIRProximityFilter,
    SIP_NULLPTR,
    init_type_QIRProximityFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QIRProximityFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QIRProximityFilter,
    cast_QIRProximityFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qirproximitysensor.sip"
#include <qirproximitysensor.h>
#line 270 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 274 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 277 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 280 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 283 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 286 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 289 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 292 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 295 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 298 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 301 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 304 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 307 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 310 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 313 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 316 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 319 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


PyDoc_STRVAR(doc_QIRProximityReading_reflectance, "reflectance(self) -> float");

extern "C" {static PyObject *meth_QIRProximityReading_reflectance(PyObject *, PyObject *);}
static PyObject *meth_QIRProximityReading_reflectance(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QIRProximityReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QIRProximityReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->reflectance();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QIRProximityReading, sipName_reflectance, doc_QIRProximityReading_reflectance);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QIRProximityReading_setReflectance, "setReflectance(self, float)");

extern "C" {static PyObject *meth_QIRProximityReading_setReflectance(PyObject *, PyObject *);}
static PyObject *meth_QIRProximityReading_setReflectance(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QIRProximityReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QIRProximityReading, &sipCpp, &a0))
        {
            sipCpp->setReflectance(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QIRProximityReading, sipName_setReflectance, doc_QIRProximityReading_setReflectance);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QIRProximityReading(void *, const sipTypeDef *);}
static void *cast_QIRProximityReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QIRProximityReading *sipCpp = reinterpret_cast< ::QIRProximityReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QIRProximityReading(void *, int);}
static void release_QIRProximityReading(void *sipCppV, int)
{
     ::QIRProximityReading *sipCpp = reinterpret_cast< ::QIRProximityReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QIRProximityReading(sipSimpleWrapper *);}
static void dealloc_QIRProximityReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QIRProximityReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QIRProximityReading[] = {{60, 255, 1}};


static PyMethodDef methods_QIRProximityReading[] = {
    {SIP_MLNAME_CAST(sipName_reflectance), meth_QIRProximityReading_reflectance, METH_VARARGS, SIP_MLDOC_CAST(doc_QIRProximityReading_reflectance)},
    {SIP_MLNAME_CAST(sipName_setReflectance), meth_QIRProximityReading_setReflectance, METH_VARARGS, SIP_MLDOC_CAST(doc_QIRProximityReading_setReflectance)}
};


static pyqt5ClassPluginDef plugin_QIRProximityReading = {
    & ::QIRProximityReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QIRProximityReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QIRProximityReading,
        {SIP_NULLPTR},
        &plugin_QIRProximityReading
    },
    {
        sipNameNr_QIRProximityReading,
        {0, 0, 1},
        2, methods_QIRProximityReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QIRProximityReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QIRProximityReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QIRProximityReading,
    cast_QIRProximityReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 57 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qhumiditysensor.sip"
#include <qhumiditysensor.h>
#line 486 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 490 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qhumiditysensor.sip"
#include <qhumiditysensor.h>
#line 493 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 496 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 499 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 502 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 505 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 508 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 511 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 514 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 517 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 521 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 524 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 527 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 530 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 533 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 536 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 539 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 542 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 545 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 548 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 551 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 554 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 557 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQHumiditySensor : public  ::QHumiditySensor
{
public:
    sipQHumiditySensor( ::QObject*);
    virtual ~sipQHumiditySensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQHumiditySensor(const sipQHumiditySensor &);
    sipQHumiditySensor &operator = (const sipQHumiditySensor &);

    char sipPyMethods[7];
};

sipQHumiditySensor::sipQHumiditySensor( ::QObject*a0):  ::QHumiditySensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQHumiditySensor::~sipQHumiditySensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQHumiditySensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QHumiditySensor);

    return  ::QHumiditySensor::metaObject();
}

int sipQHumiditySensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QHumiditySensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QHumiditySensor,_c,_id,_a);

    return _id;
}

void *sipQHumiditySensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QHumiditySensor, _clname, &sipCpp) ? sipCpp :  ::QHumiditySensor::qt_metacast(_clname));
}

void sipQHumiditySensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QHumiditySensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQHumiditySensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QHumiditySensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQHumiditySensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QHumiditySensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQHumiditySensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QHumiditySensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQHumiditySensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QHumiditySensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQHumiditySensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QHumiditySensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQHumiditySensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QHumiditySensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QHumiditySensor_reading, "reading(self) -> QHumidityReading");

extern "C" {static PyObject *meth_QHumiditySensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QHumiditySensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QHumiditySensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QHumiditySensor, &sipCpp))
        {
             ::QHumidityReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QHumidityReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QHumiditySensor, sipName_reading, doc_QHumiditySensor_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QHumiditySensor(void *, const sipTypeDef *);}
static void *cast_QHumiditySensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QHumiditySensor *sipCpp = reinterpret_cast< ::QHumiditySensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QHumiditySensor(void *, int);}
static void release_QHumiditySensor(void *sipCppV, int)
{
     ::QHumiditySensor *sipCpp = reinterpret_cast< ::QHumiditySensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QHumiditySensor(sipSimpleWrapper *);}
static void dealloc_QHumiditySensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQHumiditySensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QHumiditySensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QHumiditySensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QHumiditySensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQHumiditySensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQHumiditySensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QHumiditySensor[] = {{56, 255, 1}};


static PyMethodDef methods_QHumiditySensor[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QHumiditySensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QHumiditySensor_reading)}
};

PyDoc_STRVAR(doc_QHumiditySensor, "\1QHumiditySensor(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QHumiditySensor = {
    & ::QHumiditySensor::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QHumiditySensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QHumiditySensor,
        {SIP_NULLPTR},
        &plugin_QHumiditySensor
    },
    {
        sipNameNr_QHumiditySensor,
        {0, 0, 1},
        1, methods_QHumiditySensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QHumiditySensor,
    -1,
    -1,
    supers_QHumiditySensor,
    SIP_NULLPTR,
    init_type_QHumiditySensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QHumiditySensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QHumiditySensor,
    cast_QHumiditySensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 44 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qhumiditysensor.sip"
#include <qhumiditysensor.h>
#line 916 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qhumiditysensor.sip"
#include <qhumiditysensor.h>
#line 920 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQHumidityFilter : public  ::QHumidityFilter
{
public:
    sipQHumidityFilter();
    sipQHumidityFilter(const  ::QHumidityFilter&);
    virtual ~sipQHumidityFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QHumidityReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQHumidityFilter(const sipQHumidityFilter &);
    sipQHumidityFilter &operator = (const sipQHumidityFilter &);

    char sipPyMethods[1];
};

sipQHumidityFilter::sipQHumidityFilter():  ::QHumidityFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQHumidityFilter::sipQHumidityFilter(const  ::QHumidityFilter& a0):  ::QHumidityFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQHumidityFilter::~sipQHumidityFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQHumidityFilter::filter( ::QHumidityReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QHumidityFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_15(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QHumidityReading*);

    return sipVH_QtSensors_15(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QHumidityFilter_filter, "filter(self, QHumidityReading) -> bool");

extern "C" {static PyObject *meth_QHumidityFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QHumidityFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QHumidityReading* a0;
         ::QHumidityFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QHumidityFilter, &sipCpp, sipType_QHumidityReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QHumidityFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QHumidityFilter, sipName_filter, doc_QHumidityFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QHumidityFilter(void *, const sipTypeDef *);}
static void *cast_QHumidityFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QHumidityFilter *sipCpp = reinterpret_cast< ::QHumidityFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QHumidityFilter(void *, int);}
static void release_QHumidityFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQHumidityFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QHumidityFilter *>(sipCppV);
}


extern "C" {static void dealloc_QHumidityFilter(sipSimpleWrapper *);}
static void dealloc_QHumidityFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQHumidityFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QHumidityFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QHumidityFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QHumidityFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQHumidityFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQHumidityFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QHumidityFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QHumidityFilter, &a0))
        {
            sipCpp = new sipQHumidityFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QHumidityFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QHumidityFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QHumidityFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QHumidityFilter_filter)}
};

PyDoc_STRVAR(doc_QHumidityFilter, "\1QHumidityFilter()\n"
"QHumidityFilter(QHumidityFilter)");


static pyqt5ClassPluginDef plugin_QHumidityFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QHumidityFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QHumidityFilter,
        {SIP_NULLPTR},
        &plugin_QHumidityFilter
    },
    {
        sipNameNr_QHumidityFilter,
        {0, 0, 1},
        1, methods_QHumidityFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QHumidityFilter,
    -1,
    -1,
    supers_QHumidityFilter,
    SIP_NULLPTR,
    init_type_QHumidityFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QHumidityFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QHumidityFilter,
    cast_QHumidityFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qhumiditysensor.sip"
#include <qhumiditysensor.h>
#line 1157 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 1161 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 1164 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 1167 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 1170 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 1173 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 1176 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 1179 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1182 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 1185 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1188 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 1191 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 1194 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 1197 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 1200 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 1203 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 1206 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


PyDoc_STRVAR(doc_QHumidityReading_relativeHumidity, "relativeHumidity(self) -> float");

extern "C" {static PyObject *meth_QHumidityReading_relativeHumidity(PyObject *, PyObject *);}
static PyObject *meth_QHumidityReading_relativeHumidity(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QHumidityReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QHumidityReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->relativeHumidity();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QHumidityReading, sipName_relativeHumidity, doc_QHumidityReading_relativeHumidity);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QHumidityReading_setRelativeHumidity, "setRelativeHumidity(self, float)");

extern "C" {static PyObject *meth_QHumidityReading_setRelativeHumidity(PyObject *, PyObject *);}
static PyObject *meth_QHumidityReading_setRelativeHumidity(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QHumidityReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QHumidityReading, &sipCpp, &a0))
        {
            sipCpp->setRelativeHumidity(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QHumidityReading, sipName_setRelativeHumidity, doc_QHumidityReading_setRelativeHumidity);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QHumidityReading_absoluteHumidity, "absoluteHumidity(self) -> float");

extern "C" {static PyObject *meth_QHumidityReading_absoluteHumidity(PyObject *, PyObject *);}
static PyObject *meth_QHumidityReading_absoluteHumidity(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QHumidityReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QHumidityReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->absoluteHumidity();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QHumidityReading, sipName_absoluteHumidity, doc_QHumidityReading_absoluteHumidity);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QHumidityReading_setAbsoluteHumidity, "setAbsoluteHumidity(self, float)");

extern "C" {static PyObject *meth_QHumidityReading_setAbsoluteHumidity(PyObject *, PyObject *);}
static PyObject *meth_QHumidityReading_setAbsoluteHumidity(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QHumidityReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QHumidityReading, &sipCpp, &a0))
        {
            sipCpp->setAbsoluteHumidity(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QHumidityReading, sipName_setAbsoluteHumidity, doc_QHumidityReading_setAbsoluteHumidity);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QHumidityReading(void *, const sipTypeDef *);}
static void *cast_QHumidityReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QHumidityReading *sipCpp = reinterpret_cast< ::QHumidityReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QHumidityReading(void *, int);}
static void release_QHumidityReading(void *sipCppV, int)
{
     ::QHumidityReading *sipCpp = reinterpret_cast< ::QHumidityReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QHumidityReading(sipSimpleWrapper *);}
static void dealloc_QHumidityReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QHumidityReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QHumidityReading[] = {{60, 255, 1}};


static PyMethodDef methods_QHumidityReading[] = {
    {SIP_MLNAME_CAST(sipName_absoluteHumidity), meth_QHumidityReading_absoluteHumidity, METH_VARARGS, SIP_MLDOC_CAST(doc_QHumidityReading_absoluteHumidity)},
    {SIP_MLNAME_CAST(sipName_relativeHumidity), meth_QHumidityReading_relativeHumidity, METH_VARARGS, SIP_MLDOC_CAST(doc_QHumidityReading_relativeHumidity)},
    {SIP_MLNAME_CAST(sipName_setAbsoluteHumidity), meth_QHumidityReading_setAbsoluteHumidity, METH_VARARGS, SIP_MLDOC_CAST(doc_QHumidityReading_setAbsoluteHumidity)},
    {SIP_MLNAME_CAST(sipName_setRelativeHumidity), meth_QHumidityReading_setRelativeHumidity, METH_VARARGS, SIP_MLDOC_CAST(doc_QHumidityReading_setRelativeHumidity)}
};


static pyqt5ClassPluginDef plugin_QHumidityReading = {
    & ::QHumidityReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QHumidityReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QHumidityReading,
        {SIP_NULLPTR},
        &plugin_QHumidityReading
    },
    {
        sipNameNr_QHumidityReading,
        {0, 0, 1},
        4, methods_QHumidityReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QHumidityReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QHumidityReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QHumidityReading,
    cast_QHumidityReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 55 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qholstersensor.sip"
#include <qholstersensor.h>
#line 1431 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 1435 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qholstersensor.sip"
#include <qholstersensor.h>
#line 1438 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 1441 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 1444 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1447 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1450 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 1453 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 1456 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1459 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 1462 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 1466 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 1469 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 1472 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 1475 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 1478 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 1481 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1484 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 1487 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 1490 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 1493 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 1496 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 1499 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 1502 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQHolsterSensor : public  ::QHolsterSensor
{
public:
    sipQHolsterSensor( ::QObject*);
    virtual ~sipQHolsterSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQHolsterSensor(const sipQHolsterSensor &);
    sipQHolsterSensor &operator = (const sipQHolsterSensor &);

    char sipPyMethods[7];
};

sipQHolsterSensor::sipQHolsterSensor( ::QObject*a0):  ::QHolsterSensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQHolsterSensor::~sipQHolsterSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQHolsterSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QHolsterSensor);

    return  ::QHolsterSensor::metaObject();
}

int sipQHolsterSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QHolsterSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QHolsterSensor,_c,_id,_a);

    return _id;
}

void *sipQHolsterSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QHolsterSensor, _clname, &sipCpp) ? sipCpp :  ::QHolsterSensor::qt_metacast(_clname));
}

void sipQHolsterSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QHolsterSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQHolsterSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QHolsterSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQHolsterSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QHolsterSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQHolsterSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QHolsterSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQHolsterSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QHolsterSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQHolsterSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QHolsterSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQHolsterSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QHolsterSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QHolsterSensor_reading, "reading(self) -> QHolsterReading");

extern "C" {static PyObject *meth_QHolsterSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QHolsterSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QHolsterSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QHolsterSensor, &sipCpp))
        {
             ::QHolsterReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QHolsterReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QHolsterSensor, sipName_reading, doc_QHolsterSensor_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QHolsterSensor(void *, const sipTypeDef *);}
static void *cast_QHolsterSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QHolsterSensor *sipCpp = reinterpret_cast< ::QHolsterSensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QHolsterSensor(void *, int);}
static void release_QHolsterSensor(void *sipCppV, int)
{
     ::QHolsterSensor *sipCpp = reinterpret_cast< ::QHolsterSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QHolsterSensor(sipSimpleWrapper *);}
static void dealloc_QHolsterSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQHolsterSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QHolsterSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QHolsterSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QHolsterSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQHolsterSensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQHolsterSensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QHolsterSensor[] = {{56, 255, 1}};


static PyMethodDef methods_QHolsterSensor[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QHolsterSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QHolsterSensor_reading)}
};

PyDoc_STRVAR(doc_QHolsterSensor, "\1QHolsterSensor(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QHolsterSensor = {
    & ::QHolsterSensor::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QHolsterSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QHolsterSensor,
        {SIP_NULLPTR},
        &plugin_QHolsterSensor
    },
    {
        sipNameNr_QHolsterSensor,
        {0, 0, 1},
        1, methods_QHolsterSensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QHolsterSensor,
    -1,
    -1,
    supers_QHolsterSensor,
    SIP_NULLPTR,
    init_type_QHolsterSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QHolsterSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QHolsterSensor,
    cast_QHolsterSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 42 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qholstersensor.sip"
#include <qholstersensor.h>
#line 1861 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qholstersensor.sip"
#include <qholstersensor.h>
#line 1865 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQHolsterFilter : public  ::QHolsterFilter
{
public:
    sipQHolsterFilter();
    sipQHolsterFilter(const  ::QHolsterFilter&);
    virtual ~sipQHolsterFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QHolsterReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQHolsterFilter(const sipQHolsterFilter &);
    sipQHolsterFilter &operator = (const sipQHolsterFilter &);

    char sipPyMethods[1];
};

sipQHolsterFilter::sipQHolsterFilter():  ::QHolsterFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQHolsterFilter::sipQHolsterFilter(const  ::QHolsterFilter& a0):  ::QHolsterFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQHolsterFilter::~sipQHolsterFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQHolsterFilter::filter( ::QHolsterReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QHolsterFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_14(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QHolsterReading*);

    return sipVH_QtSensors_14(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QHolsterFilter_filter, "filter(self, QHolsterReading) -> bool");

extern "C" {static PyObject *meth_QHolsterFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QHolsterFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QHolsterReading* a0;
         ::QHolsterFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QHolsterFilter, &sipCpp, sipType_QHolsterReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QHolsterFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QHolsterFilter, sipName_filter, doc_QHolsterFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QHolsterFilter(void *, const sipTypeDef *);}
static void *cast_QHolsterFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QHolsterFilter *sipCpp = reinterpret_cast< ::QHolsterFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QHolsterFilter(void *, int);}
static void release_QHolsterFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQHolsterFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QHolsterFilter *>(sipCppV);
}


extern "C" {static void dealloc_QHolsterFilter(sipSimpleWrapper *);}
static void dealloc_QHolsterFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQHolsterFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QHolsterFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QHolsterFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QHolsterFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQHolsterFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQHolsterFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QHolsterFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QHolsterFilter, &a0))
        {
            sipCpp = new sipQHolsterFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QHolsterFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QHolsterFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QHolsterFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QHolsterFilter_filter)}
};

PyDoc_STRVAR(doc_QHolsterFilter, "\1QHolsterFilter()\n"
"QHolsterFilter(QHolsterFilter)");


static pyqt5ClassPluginDef plugin_QHolsterFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QHolsterFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QHolsterFilter,
        {SIP_NULLPTR},
        &plugin_QHolsterFilter
    },
    {
        sipNameNr_QHolsterFilter,
        {0, 0, 1},
        1, methods_QHolsterFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QHolsterFilter,
    -1,
    -1,
    supers_QHolsterFilter,
    SIP_NULLPTR,
    init_type_QHolsterFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QHolsterFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QHolsterFilter,
    cast_QHolsterFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qholstersensor.sip"
#include <qholstersensor.h>
#line 2102 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 2106 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 2109 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2112 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2115 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2118 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 2121 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 2124 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2127 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 2130 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2133 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 2136 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 2139 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 2142 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 2145 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 2148 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 2151 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


PyDoc_STRVAR(doc_QHolsterReading_holstered, "holstered(self) -> bool");

extern "C" {static PyObject *meth_QHolsterReading_holstered(PyObject *, PyObject *);}
static PyObject *meth_QHolsterReading_holstered(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QHolsterReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QHolsterReading, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->holstered();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QHolsterReading, sipName_holstered, doc_QHolsterReading_holstered);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QHolsterReading_setHolstered, "setHolstered(self, bool)");

extern "C" {static PyObject *meth_QHolsterReading_setHolstered(PyObject *, PyObject *);}
static PyObject *meth_QHolsterReading_setHolstered(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool a0;
         ::QHolsterReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QHolsterReading, &sipCpp, &a0))
        {
            sipCpp->setHolstered(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QHolsterReading, sipName_setHolstered, doc_QHolsterReading_setHolstered);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QHolsterReading(void *, const sipTypeDef *);}
static void *cast_QHolsterReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QHolsterReading *sipCpp = reinterpret_cast< ::QHolsterReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QHolsterReading(void *, int);}
static void release_QHolsterReading(void *sipCppV, int)
{
     ::QHolsterReading *sipCpp = reinterpret_cast< ::QHolsterReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QHolsterReading(sipSimpleWrapper *);}
static void dealloc_QHolsterReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QHolsterReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QHolsterReading[] = {{60, 255, 1}};


static PyMethodDef methods_QHolsterReading[] = {
    {SIP_MLNAME_CAST(sipName_holstered), meth_QHolsterReading_holstered, METH_VARARGS, SIP_MLDOC_CAST(doc_QHolsterReading_holstered)},
    {SIP_MLNAME_CAST(sipName_setHolstered), meth_QHolsterReading_setHolstered, METH_VARARGS, SIP_MLDOC_CAST(doc_QHolsterReading_setHolstered)}
};


static pyqt5ClassPluginDef plugin_QHolsterReading = {
    & ::QHolsterReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QHolsterReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QHolsterReading,
        {SIP_NULLPTR},
        &plugin_QHolsterReading
    },
    {
        sipNameNr_QHolsterReading,
        {0, 0, 1},
        2, methods_QHolsterReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QHolsterReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QHolsterReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QHolsterReading,
    cast_QHolsterReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 59 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qgyroscope.sip"
#include <qgyroscope.h>
#line 2318 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 2322 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qgyroscope.sip"
#include <qgyroscope.h>
#line 2325 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 2328 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 2331 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2334 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2337 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 2340 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 2343 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2346 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 2349 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 2353 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 2356 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2359 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2362 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2365 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 2368 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2371 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 2374 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 2377 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 2380 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 2383 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 2386 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 2389 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQGyroscope : public  ::QGyroscope
{
public:
    sipQGyroscope( ::QObject*);
    virtual ~sipQGyroscope();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQGyroscope(const sipQGyroscope &);
    sipQGyroscope &operator = (const sipQGyroscope &);

    char sipPyMethods[7];
};

sipQGyroscope::sipQGyroscope( ::QObject*a0):  ::QGyroscope(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQGyroscope::~sipQGyroscope()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQGyroscope::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QGyroscope);

    return  ::QGyroscope::metaObject();
}

int sipQGyroscope::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QGyroscope::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QGyroscope,_c,_id,_a);

    return _id;
}

void *sipQGyroscope::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QGyroscope, _clname, &sipCpp) ? sipCpp :  ::QGyroscope::qt_metacast(_clname));
}

void sipQGyroscope::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QGyroscope::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQGyroscope::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QGyroscope::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQGyroscope::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QGyroscope::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQGyroscope::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QGyroscope::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQGyroscope::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QGyroscope::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQGyroscope::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QGyroscope::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQGyroscope::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QGyroscope::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QGyroscope_reading, "reading(self) -> QGyroscopeReading");

extern "C" {static PyObject *meth_QGyroscope_reading(PyObject *, PyObject *);}
static PyObject *meth_QGyroscope_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QGyroscope *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QGyroscope, &sipCpp))
        {
             ::QGyroscopeReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QGyroscopeReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QGyroscope, sipName_reading, doc_QGyroscope_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QGyroscope(void *, const sipTypeDef *);}
static void *cast_QGyroscope(void *sipCppV, const sipTypeDef *targetType)
{
     ::QGyroscope *sipCpp = reinterpret_cast< ::QGyroscope *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QGyroscope(void *, int);}
static void release_QGyroscope(void *sipCppV, int)
{
     ::QGyroscope *sipCpp = reinterpret_cast< ::QGyroscope *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QGyroscope(sipSimpleWrapper *);}
static void dealloc_QGyroscope(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQGyroscope *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QGyroscope(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QGyroscope(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QGyroscope(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQGyroscope *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQGyroscope(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QGyroscope[] = {{56, 255, 1}};


static PyMethodDef methods_QGyroscope[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QGyroscope_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QGyroscope_reading)}
};

PyDoc_STRVAR(doc_QGyroscope, "\1QGyroscope(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QGyroscope = {
    & ::QGyroscope::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QGyroscope = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QGyroscope,
        {SIP_NULLPTR},
        &plugin_QGyroscope
    },
    {
        sipNameNr_QGyroscope,
        {0, 0, 1},
        1, methods_QGyroscope,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QGyroscope,
    -1,
    -1,
    supers_QGyroscope,
    SIP_NULLPTR,
    init_type_QGyroscope,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QGyroscope,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QGyroscope,
    cast_QGyroscope,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 46 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qgyroscope.sip"
#include <qgyroscope.h>
#line 2748 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qgyroscope.sip"
#include <qgyroscope.h>
#line 2752 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQGyroscopeFilter : public  ::QGyroscopeFilter
{
public:
    sipQGyroscopeFilter();
    sipQGyroscopeFilter(const  ::QGyroscopeFilter&);
    virtual ~sipQGyroscopeFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QGyroscopeReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQGyroscopeFilter(const sipQGyroscopeFilter &);
    sipQGyroscopeFilter &operator = (const sipQGyroscopeFilter &);

    char sipPyMethods[1];
};

sipQGyroscopeFilter::sipQGyroscopeFilter():  ::QGyroscopeFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQGyroscopeFilter::sipQGyroscopeFilter(const  ::QGyroscopeFilter& a0):  ::QGyroscopeFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQGyroscopeFilter::~sipQGyroscopeFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQGyroscopeFilter::filter( ::QGyroscopeReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QGyroscopeFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_13(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QGyroscopeReading*);

    return sipVH_QtSensors_13(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QGyroscopeFilter_filter, "filter(self, QGyroscopeReading) -> bool");

extern "C" {static PyObject *meth_QGyroscopeFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QGyroscopeFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QGyroscopeReading* a0;
         ::QGyroscopeFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QGyroscopeFilter, &sipCpp, sipType_QGyroscopeReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QGyroscopeFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QGyroscopeFilter, sipName_filter, doc_QGyroscopeFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QGyroscopeFilter(void *, const sipTypeDef *);}
static void *cast_QGyroscopeFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QGyroscopeFilter *sipCpp = reinterpret_cast< ::QGyroscopeFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QGyroscopeFilter(void *, int);}
static void release_QGyroscopeFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQGyroscopeFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QGyroscopeFilter *>(sipCppV);
}


extern "C" {static void dealloc_QGyroscopeFilter(sipSimpleWrapper *);}
static void dealloc_QGyroscopeFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQGyroscopeFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QGyroscopeFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QGyroscopeFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QGyroscopeFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQGyroscopeFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQGyroscopeFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QGyroscopeFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QGyroscopeFilter, &a0))
        {
            sipCpp = new sipQGyroscopeFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QGyroscopeFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QGyroscopeFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QGyroscopeFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QGyroscopeFilter_filter)}
};

PyDoc_STRVAR(doc_QGyroscopeFilter, "\1QGyroscopeFilter()\n"
"QGyroscopeFilter(QGyroscopeFilter)");


static pyqt5ClassPluginDef plugin_QGyroscopeFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QGyroscopeFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QGyroscopeFilter,
        {SIP_NULLPTR},
        &plugin_QGyroscopeFilter
    },
    {
        sipNameNr_QGyroscopeFilter,
        {0, 0, 1},
        1, methods_QGyroscopeFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QGyroscopeFilter,
    -1,
    -1,
    supers_QGyroscopeFilter,
    SIP_NULLPTR,
    init_type_QGyroscopeFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QGyroscopeFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QGyroscopeFilter,
    cast_QGyroscopeFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qgyroscope.sip"
#include <qgyroscope.h>
#line 2989 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 2993 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 2996 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2999 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3002 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3005 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 3008 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 3011 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3014 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 3017 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3020 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 3023 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 3026 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 3029 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 3032 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 3035 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 3038 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


PyDoc_STRVAR(doc_QGyroscopeReading_x, "x(self) -> float");

extern "C" {static PyObject *meth_QGyroscopeReading_x(PyObject *, PyObject *);}
static PyObject *meth_QGyroscopeReading_x(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QGyroscopeReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QGyroscopeReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->x();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QGyroscopeReading, sipName_x, doc_QGyroscopeReading_x);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QGyroscopeReading_setX, "setX(self, float)");

extern "C" {static PyObject *meth_QGyroscopeReading_setX(PyObject *, PyObject *);}
static PyObject *meth_QGyroscopeReading_setX(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QGyroscopeReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QGyroscopeReading, &sipCpp, &a0))
        {
            sipCpp->setX(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QGyroscopeReading, sipName_setX, doc_QGyroscopeReading_setX);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QGyroscopeReading_y, "y(self) -> float");

extern "C" {static PyObject *meth_QGyroscopeReading_y(PyObject *, PyObject *);}
static PyObject *meth_QGyroscopeReading_y(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QGyroscopeReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QGyroscopeReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->y();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QGyroscopeReading, sipName_y, doc_QGyroscopeReading_y);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QGyroscopeReading_setY, "setY(self, float)");

extern "C" {static PyObject *meth_QGyroscopeReading_setY(PyObject *, PyObject *);}
static PyObject *meth_QGyroscopeReading_setY(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QGyroscopeReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QGyroscopeReading, &sipCpp, &a0))
        {
            sipCpp->setY(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QGyroscopeReading, sipName_setY, doc_QGyroscopeReading_setY);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QGyroscopeReading_z, "z(self) -> float");

extern "C" {static PyObject *meth_QGyroscopeReading_z(PyObject *, PyObject *);}
static PyObject *meth_QGyroscopeReading_z(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QGyroscopeReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QGyroscopeReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->z();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QGyroscopeReading, sipName_z, doc_QGyroscopeReading_z);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QGyroscopeReading_setZ, "setZ(self, float)");

extern "C" {static PyObject *meth_QGyroscopeReading_setZ(PyObject *, PyObject *);}
static PyObject *meth_QGyroscopeReading_setZ(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QGyroscopeReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QGyroscopeReading, &sipCpp, &a0))
        {
            sipCpp->setZ(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QGyroscopeReading, sipName_setZ, doc_QGyroscopeReading_setZ);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QGyroscopeReading(void *, const sipTypeDef *);}
static void *cast_QGyroscopeReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QGyroscopeReading *sipCpp = reinterpret_cast< ::QGyroscopeReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QGyroscopeReading(void *, int);}
static void release_QGyroscopeReading(void *sipCppV, int)
{
     ::QGyroscopeReading *sipCpp = reinterpret_cast< ::QGyroscopeReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QGyroscopeReading(sipSimpleWrapper *);}
static void dealloc_QGyroscopeReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QGyroscopeReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QGyroscopeReading[] = {{60, 255, 1}};


static PyMethodDef methods_QGyroscopeReading[] = {
    {SIP_MLNAME_CAST(sipName_setX), meth_QGyroscopeReading_setX, METH_VARARGS, SIP_MLDOC_CAST(doc_QGyroscopeReading_setX)},
    {SIP_MLNAME_CAST(sipName_setY), meth_QGyroscopeReading_setY, METH_VARARGS, SIP_MLDOC_CAST(doc_QGyroscopeReading_setY)},
    {SIP_MLNAME_CAST(sipName_setZ), meth_QGyroscopeReading_setZ, METH_VARARGS, SIP_MLDOC_CAST(doc_QGyroscopeReading_setZ)},
    {SIP_MLNAME_CAST(sipName_x), meth_QGyroscopeReading_x, METH_VARARGS, SIP_MLDOC_CAST(doc_QGyroscopeReading_x)},
    {SIP_MLNAME_CAST(sipName_y), meth_QGyroscopeReading_y, METH_VARARGS, SIP_MLDOC_CAST(doc_QGyroscopeReading_y)},
    {SIP_MLNAME_CAST(sipName_z), meth_QGyroscopeReading_z, METH_VARARGS, SIP_MLDOC_CAST(doc_QGyroscopeReading_z)}
};


static pyqt5ClassPluginDef plugin_QGyroscopeReading = {
    & ::QGyroscopeReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QGyroscopeReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QGyroscopeReading,
        {SIP_NULLPTR},
        &plugin_QGyroscopeReading
    },
    {
        sipNameNr_QGyroscopeReading,
        {0, 0, 1},
        6, methods_QGyroscopeReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QGyroscopeReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QGyroscopeReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QGyroscopeReading,
    cast_QGyroscopeReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 55 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qdistancesensor.sip"
#include <qdistancesensor.h>
#line 3321 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 3325 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qdistancesensor.sip"
#include <qdistancesensor.h>
#line 3328 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 3331 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 3334 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3337 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3340 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 3343 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 3346 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3349 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 3352 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 3356 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 3359 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3362 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3365 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3368 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 3371 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3374 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 3377 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 3380 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 3383 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 3386 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 3389 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 3392 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQDistanceSensor : public  ::QDistanceSensor
{
public:
    sipQDistanceSensor( ::QObject*);
    virtual ~sipQDistanceSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQDistanceSensor(const sipQDistanceSensor &);
    sipQDistanceSensor &operator = (const sipQDistanceSensor &);

    char sipPyMethods[7];
};

sipQDistanceSensor::sipQDistanceSensor( ::QObject*a0):  ::QDistanceSensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQDistanceSensor::~sipQDistanceSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQDistanceSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QDistanceSensor);

    return  ::QDistanceSensor::metaObject();
}

int sipQDistanceSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QDistanceSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QDistanceSensor,_c,_id,_a);

    return _id;
}

void *sipQDistanceSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QDistanceSensor, _clname, &sipCpp) ? sipCpp :  ::QDistanceSensor::qt_metacast(_clname));
}

void sipQDistanceSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QDistanceSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQDistanceSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QDistanceSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQDistanceSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QDistanceSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQDistanceSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QDistanceSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQDistanceSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QDistanceSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQDistanceSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QDistanceSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQDistanceSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QDistanceSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QDistanceSensor_reading, "reading(self) -> QDistanceReading");

extern "C" {static PyObject *meth_QDistanceSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QDistanceSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QDistanceSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QDistanceSensor, &sipCpp))
        {
             ::QDistanceReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QDistanceReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QDistanceSensor, sipName_reading, doc_QDistanceSensor_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QDistanceSensor(void *, const sipTypeDef *);}
static void *cast_QDistanceSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QDistanceSensor *sipCpp = reinterpret_cast< ::QDistanceSensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QDistanceSensor(void *, int);}
static void release_QDistanceSensor(void *sipCppV, int)
{
     ::QDistanceSensor *sipCpp = reinterpret_cast< ::QDistanceSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QDistanceSensor(sipSimpleWrapper *);}
static void dealloc_QDistanceSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQDistanceSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QDistanceSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QDistanceSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QDistanceSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQDistanceSensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQDistanceSensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QDistanceSensor[] = {{56, 255, 1}};


static PyMethodDef methods_QDistanceSensor[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QDistanceSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QDistanceSensor_reading)}
};

PyDoc_STRVAR(doc_QDistanceSensor, "\1QDistanceSensor(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QDistanceSensor = {
    & ::QDistanceSensor::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QDistanceSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QDistanceSensor,
        {SIP_NULLPTR},
        &plugin_QDistanceSensor
    },
    {
        sipNameNr_QDistanceSensor,
        {0, 0, 1},
        1, methods_QDistanceSensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QDistanceSensor,
    -1,
    -1,
    supers_QDistanceSensor,
    SIP_NULLPTR,
    init_type_QDistanceSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QDistanceSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QDistanceSensor,
    cast_QDistanceSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 42 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qdistancesensor.sip"
#include <qdistancesensor.h>
#line 3751 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qdistancesensor.sip"
#include <qdistancesensor.h>
#line 3755 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQDistanceFilter : public  ::QDistanceFilter
{
public:
    sipQDistanceFilter();
    sipQDistanceFilter(const  ::QDistanceFilter&);
    virtual ~sipQDistanceFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QDistanceReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQDistanceFilter(const sipQDistanceFilter &);
    sipQDistanceFilter &operator = (const sipQDistanceFilter &);

    char sipPyMethods[1];
};

sipQDistanceFilter::sipQDistanceFilter():  ::QDistanceFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQDistanceFilter::sipQDistanceFilter(const  ::QDistanceFilter& a0):  ::QDistanceFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQDistanceFilter::~sipQDistanceFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQDistanceFilter::filter( ::QDistanceReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QDistanceFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_12(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QDistanceReading*);

    return sipVH_QtSensors_12(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QDistanceFilter_filter, "filter(self, QDistanceReading) -> bool");

extern "C" {static PyObject *meth_QDistanceFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QDistanceFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QDistanceReading* a0;
         ::QDistanceFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QDistanceFilter, &sipCpp, sipType_QDistanceReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QDistanceFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QDistanceFilter, sipName_filter, doc_QDistanceFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QDistanceFilter(void *, const sipTypeDef *);}
static void *cast_QDistanceFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QDistanceFilter *sipCpp = reinterpret_cast< ::QDistanceFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QDistanceFilter(void *, int);}
static void release_QDistanceFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQDistanceFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QDistanceFilter *>(sipCppV);
}


extern "C" {static void dealloc_QDistanceFilter(sipSimpleWrapper *);}
static void dealloc_QDistanceFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQDistanceFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QDistanceFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QDistanceFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QDistanceFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQDistanceFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQDistanceFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QDistanceFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QDistanceFilter, &a0))
        {
            sipCpp = new sipQDistanceFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QDistanceFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QDistanceFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QDistanceFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QDistanceFilter_filter)}
};

PyDoc_STRVAR(doc_QDistanceFilter, "\1QDistanceFilter()\n"
"QDistanceFilter(QDistanceFilter)");


static pyqt5ClassPluginDef plugin_QDistanceFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QDistanceFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QDistanceFilter,
        {SIP_NULLPTR},
        &plugin_QDistanceFilter
    },
    {
        sipNameNr_QDistanceFilter,
        {0, 0, 1},
        1, methods_QDistanceFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QDistanceFilter,
    -1,
    -1,
    supers_QDistanceFilter,
    SIP_NULLPTR,
    init_type_QDistanceFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QDistanceFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QDistanceFilter,
    cast_QDistanceFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qdistancesensor.sip"
#include <qdistancesensor.h>
#line 3992 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 3996 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 3999 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4002 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4005 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4008 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 4011 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 4014 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4017 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 4020 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4023 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4026 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 4029 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4032 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 4035 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 4038 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 4041 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


PyDoc_STRVAR(doc_QDistanceReading_distance, "distance(self) -> float");

extern "C" {static PyObject *meth_QDistanceReading_distance(PyObject *, PyObject *);}
static PyObject *meth_QDistanceReading_distance(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QDistanceReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QDistanceReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->distance();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QDistanceReading, sipName_distance, doc_QDistanceReading_distance);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QDistanceReading_setDistance, "setDistance(self, float)");

extern "C" {static PyObject *meth_QDistanceReading_setDistance(PyObject *, PyObject *);}
static PyObject *meth_QDistanceReading_setDistance(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QDistanceReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QDistanceReading, &sipCpp, &a0))
        {
            sipCpp->setDistance(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QDistanceReading, sipName_setDistance, doc_QDistanceReading_setDistance);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QDistanceReading(void *, const sipTypeDef *);}
static void *cast_QDistanceReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QDistanceReading *sipCpp = reinterpret_cast< ::QDistanceReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QDistanceReading(void *, int);}
static void release_QDistanceReading(void *sipCppV, int)
{
     ::QDistanceReading *sipCpp = reinterpret_cast< ::QDistanceReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QDistanceReading(sipSimpleWrapper *);}
static void dealloc_QDistanceReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QDistanceReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QDistanceReading[] = {{60, 255, 1}};


static PyMethodDef methods_QDistanceReading[] = {
    {SIP_MLNAME_CAST(sipName_distance), meth_QDistanceReading_distance, METH_VARARGS, SIP_MLDOC_CAST(doc_QDistanceReading_distance)},
    {SIP_MLNAME_CAST(sipName_setDistance), meth_QDistanceReading_setDistance, METH_VARARGS, SIP_MLDOC_CAST(doc_QDistanceReading_setDistance)}
};


static pyqt5ClassPluginDef plugin_QDistanceReading = {
    & ::QDistanceReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QDistanceReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QDistanceReading,
        {SIP_NULLPTR},
        &plugin_QDistanceReading
    },
    {
        sipNameNr_QDistanceReading,
        {0, 0, 1},
        2, methods_QDistanceReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QDistanceReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QDistanceReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QDistanceReading,
    cast_QDistanceReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 57 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qcompass.sip"
#include <qcompass.h>
#line 4208 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 4212 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qcompass.sip"
#include <qcompass.h>
#line 4215 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 4218 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 4221 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4224 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4227 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 4230 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 4233 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4236 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 4239 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 4243 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 4246 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4249 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4252 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4255 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 4258 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4261 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4264 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 4267 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4270 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 4273 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 4276 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 4279 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQCompass : public  ::QCompass
{
public:
    sipQCompass( ::QObject*);
    virtual ~sipQCompass();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQCompass(const sipQCompass &);
    sipQCompass &operator = (const sipQCompass &);

    char sipPyMethods[7];
};

sipQCompass::sipQCompass( ::QObject*a0):  ::QCompass(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQCompass::~sipQCompass()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQCompass::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QCompass);

    return  ::QCompass::metaObject();
}

int sipQCompass::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QCompass::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QCompass,_c,_id,_a);

    return _id;
}

void *sipQCompass::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QCompass, _clname, &sipCpp) ? sipCpp :  ::QCompass::qt_metacast(_clname));
}

void sipQCompass::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QCompass::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQCompass::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QCompass::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQCompass::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QCompass::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQCompass::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QCompass::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQCompass::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QCompass::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQCompass::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QCompass::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQCompass::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QCompass::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QCompass_reading, "reading(self) -> QCompassReading");

extern "C" {static PyObject *meth_QCompass_reading(PyObject *, PyObject *);}
static PyObject *meth_QCompass_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QCompass *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QCompass, &sipCpp))
        {
             ::QCompassReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QCompassReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QCompass, sipName_reading, doc_QCompass_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QCompass(void *, const sipTypeDef *);}
static void *cast_QCompass(void *sipCppV, const sipTypeDef *targetType)
{
     ::QCompass *sipCpp = reinterpret_cast< ::QCompass *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QCompass(void *, int);}
static void release_QCompass(void *sipCppV, int)
{
     ::QCompass *sipCpp = reinterpret_cast< ::QCompass *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QCompass(sipSimpleWrapper *);}
static void dealloc_QCompass(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQCompass *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QCompass(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QCompass(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QCompass(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQCompass *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQCompass(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QCompass[] = {{56, 255, 1}};


static PyMethodDef methods_QCompass[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QCompass_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QCompass_reading)}
};

PyDoc_STRVAR(doc_QCompass, "\1QCompass(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QCompass = {
    & ::QCompass::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QCompass = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QCompass,
        {SIP_NULLPTR},
        &plugin_QCompass
    },
    {
        sipNameNr_QCompass,
        {0, 0, 1},
        1, methods_QCompass,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QCompass,
    -1,
    -1,
    supers_QCompass,
    SIP_NULLPTR,
    init_type_QCompass,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QCompass,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QCompass,
    cast_QCompass,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 44 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qcompass.sip"
#include <qcompass.h>
#line 4638 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qcompass.sip"
#include <qcompass.h>
#line 4642 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQCompassFilter : public  ::QCompassFilter
{
public:
    sipQCompassFilter();
    sipQCompassFilter(const  ::QCompassFilter&);
    virtual ~sipQCompassFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QCompassReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQCompassFilter(const sipQCompassFilter &);
    sipQCompassFilter &operator = (const sipQCompassFilter &);

    char sipPyMethods[1];
};

sipQCompassFilter::sipQCompassFilter():  ::QCompassFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQCompassFilter::sipQCompassFilter(const  ::QCompassFilter& a0):  ::QCompassFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQCompassFilter::~sipQCompassFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQCompassFilter::filter( ::QCompassReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QCompassFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_11(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QCompassReading*);

    return sipVH_QtSensors_11(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QCompassFilter_filter, "filter(self, QCompassReading) -> bool");

extern "C" {static PyObject *meth_QCompassFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QCompassFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QCompassReading* a0;
         ::QCompassFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QCompassFilter, &sipCpp, sipType_QCompassReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QCompassFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QCompassFilter, sipName_filter, doc_QCompassFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QCompassFilter(void *, const sipTypeDef *);}
static void *cast_QCompassFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QCompassFilter *sipCpp = reinterpret_cast< ::QCompassFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QCompassFilter(void *, int);}
static void release_QCompassFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQCompassFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QCompassFilter *>(sipCppV);
}


extern "C" {static void dealloc_QCompassFilter(sipSimpleWrapper *);}
static void dealloc_QCompassFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQCompassFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QCompassFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QCompassFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QCompassFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQCompassFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQCompassFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QCompassFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QCompassFilter, &a0))
        {
            sipCpp = new sipQCompassFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QCompassFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QCompassFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QCompassFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QCompassFilter_filter)}
};

PyDoc_STRVAR(doc_QCompassFilter, "\1QCompassFilter()\n"
"QCompassFilter(QCompassFilter)");


static pyqt5ClassPluginDef plugin_QCompassFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QCompassFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QCompassFilter,
        {SIP_NULLPTR},
        &plugin_QCompassFilter
    },
    {
        sipNameNr_QCompassFilter,
        {0, 0, 1},
        1, methods_QCompassFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QCompassFilter,
    -1,
    -1,
    supers_QCompassFilter,
    SIP_NULLPTR,
    init_type_QCompassFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QCompassFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QCompassFilter,
    cast_QCompassFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qcompass.sip"
#include <qcompass.h>
#line 4879 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 4883 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 4886 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4889 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4892 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4895 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 4898 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 4901 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4904 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 4907 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4910 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4913 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 4916 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4919 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 4922 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 4925 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 4928 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


PyDoc_STRVAR(doc_QCompassReading_azimuth, "azimuth(self) -> float");

extern "C" {static PyObject *meth_QCompassReading_azimuth(PyObject *, PyObject *);}
static PyObject *meth_QCompassReading_azimuth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QCompassReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QCompassReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->azimuth();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QCompassReading, sipName_azimuth, doc_QCompassReading_azimuth);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QCompassReading_setAzimuth, "setAzimuth(self, float)");

extern "C" {static PyObject *meth_QCompassReading_setAzimuth(PyObject *, PyObject *);}
static PyObject *meth_QCompassReading_setAzimuth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QCompassReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QCompassReading, &sipCpp, &a0))
        {
            sipCpp->setAzimuth(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QCompassReading, sipName_setAzimuth, doc_QCompassReading_setAzimuth);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QCompassReading_calibrationLevel, "calibrationLevel(self) -> float");

extern "C" {static PyObject *meth_QCompassReading_calibrationLevel(PyObject *, PyObject *);}
static PyObject *meth_QCompassReading_calibrationLevel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QCompassReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QCompassReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->calibrationLevel();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QCompassReading, sipName_calibrationLevel, doc_QCompassReading_calibrationLevel);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QCompassReading_setCalibrationLevel, "setCalibrationLevel(self, float)");

extern "C" {static PyObject *meth_QCompassReading_setCalibrationLevel(PyObject *, PyObject *);}
static PyObject *meth_QCompassReading_setCalibrationLevel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QCompassReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QCompassReading, &sipCpp, &a0))
        {
            sipCpp->setCalibrationLevel(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QCompassReading, sipName_setCalibrationLevel, doc_QCompassReading_setCalibrationLevel);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QCompassReading(void *, const sipTypeDef *);}
static void *cast_QCompassReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QCompassReading *sipCpp = reinterpret_cast< ::QCompassReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QCompassReading(void *, int);}
static void release_QCompassReading(void *sipCppV, int)
{
     ::QCompassReading *sipCpp = reinterpret_cast< ::QCompassReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QCompassReading(sipSimpleWrapper *);}
static void dealloc_QCompassReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QCompassReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QCompassReading[] = {{60, 255, 1}};


static PyMethodDef methods_QCompassReading[] = {
    {SIP_MLNAME_CAST(sipName_azimuth), meth_QCompassReading_azimuth, METH_VARARGS, SIP_MLDOC_CAST(doc_QCompassReading_azimuth)},
    {SIP_MLNAME_CAST(sipName_calibrationLevel), meth_QCompassReading_calibrationLevel, METH_VARARGS, SIP_MLDOC_CAST(doc_QCompassReading_calibrationLevel)},
    {SIP_MLNAME_CAST(sipName_setAzimuth), meth_QCompassReading_setAzimuth, METH_VARARGS, SIP_MLDOC_CAST(doc_QCompassReading_setAzimuth)},
    {SIP_MLNAME_CAST(sipName_setCalibrationLevel), meth_QCompassReading_setCalibrationLevel, METH_VARARGS, SIP_MLDOC_CAST(doc_QCompassReading_setCalibrationLevel)}
};


static pyqt5ClassPluginDef plugin_QCompassReading = {
    & ::QCompassReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QCompassReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QCompassReading,
        {SIP_NULLPTR},
        &plugin_QCompassReading
    },
    {
        sipNameNr_QCompassReading,
        {0, 0, 1},
        4, methods_QCompassReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QCompassReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QCompassReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QCompassReading,
    cast_QCompassReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 55 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambienttemperaturesensor.sip"
#include <qambienttemperaturesensor.h>
#line 5153 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 5157 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambienttemperaturesensor.sip"
#include <qambienttemperaturesensor.h>
#line 5160 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 5163 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 5166 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5169 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5172 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 5175 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 5178 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5181 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 5184 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 5188 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 5191 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5194 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5197 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5200 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 5203 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5206 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 5209 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 5212 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 5215 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 5218 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 5221 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 5224 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQAmbientTemperatureSensor : public  ::QAmbientTemperatureSensor
{
public:
    sipQAmbientTemperatureSensor( ::QObject*);
    virtual ~sipQAmbientTemperatureSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQAmbientTemperatureSensor(const sipQAmbientTemperatureSensor &);
    sipQAmbientTemperatureSensor &operator = (const sipQAmbientTemperatureSensor &);

    char sipPyMethods[7];
};

sipQAmbientTemperatureSensor::sipQAmbientTemperatureSensor( ::QObject*a0):  ::QAmbientTemperatureSensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAmbientTemperatureSensor::~sipQAmbientTemperatureSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQAmbientTemperatureSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QAmbientTemperatureSensor);

    return  ::QAmbientTemperatureSensor::metaObject();
}

int sipQAmbientTemperatureSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QAmbientTemperatureSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QAmbientTemperatureSensor,_c,_id,_a);

    return _id;
}

void *sipQAmbientTemperatureSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QAmbientTemperatureSensor, _clname, &sipCpp) ? sipCpp :  ::QAmbientTemperatureSensor::qt_metacast(_clname));
}

void sipQAmbientTemperatureSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QAmbientTemperatureSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAmbientTemperatureSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QAmbientTemperatureSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAmbientTemperatureSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QAmbientTemperatureSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAmbientTemperatureSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QAmbientTemperatureSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAmbientTemperatureSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QAmbientTemperatureSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQAmbientTemperatureSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QAmbientTemperatureSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQAmbientTemperatureSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QAmbientTemperatureSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QAmbientTemperatureSensor_reading, "reading(self) -> QAmbientTemperatureReading");

extern "C" {static PyObject *meth_QAmbientTemperatureSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QAmbientTemperatureSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QAmbientTemperatureSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QAmbientTemperatureSensor, &sipCpp))
        {
             ::QAmbientTemperatureReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QAmbientTemperatureReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAmbientTemperatureSensor, sipName_reading, doc_QAmbientTemperatureSensor_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAmbientTemperatureSensor(void *, const sipTypeDef *);}
static void *cast_QAmbientTemperatureSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAmbientTemperatureSensor *sipCpp = reinterpret_cast< ::QAmbientTemperatureSensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAmbientTemperatureSensor(void *, int);}
static void release_QAmbientTemperatureSensor(void *sipCppV, int)
{
     ::QAmbientTemperatureSensor *sipCpp = reinterpret_cast< ::QAmbientTemperatureSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QAmbientTemperatureSensor(sipSimpleWrapper *);}
static void dealloc_QAmbientTemperatureSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQAmbientTemperatureSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAmbientTemperatureSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QAmbientTemperatureSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QAmbientTemperatureSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQAmbientTemperatureSensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQAmbientTemperatureSensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAmbientTemperatureSensor[] = {{56, 255, 1}};


static PyMethodDef methods_QAmbientTemperatureSensor[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QAmbientTemperatureSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QAmbientTemperatureSensor_reading)}
};

PyDoc_STRVAR(doc_QAmbientTemperatureSensor, "\1QAmbientTemperatureSensor(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QAmbientTemperatureSensor = {
    & ::QAmbientTemperatureSensor::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAmbientTemperatureSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAmbientTemperatureSensor,
        {SIP_NULLPTR},
        &plugin_QAmbientTemperatureSensor
    },
    {
        sipNameNr_QAmbientTemperatureSensor,
        {0, 0, 1},
        1, methods_QAmbientTemperatureSensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QAmbientTemperatureSensor,
    -1,
    -1,
    supers_QAmbientTemperatureSensor,
    SIP_NULLPTR,
    init_type_QAmbientTemperatureSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAmbientTemperatureSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAmbientTemperatureSensor,
    cast_QAmbientTemperatureSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 42 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambienttemperaturesensor.sip"
#include <qambienttemperaturesensor.h>
#line 5583 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambienttemperaturesensor.sip"
#include <qambienttemperaturesensor.h>
#line 5587 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQAmbientTemperatureFilter : public  ::QAmbientTemperatureFilter
{
public:
    sipQAmbientTemperatureFilter();
    sipQAmbientTemperatureFilter(const  ::QAmbientTemperatureFilter&);
    virtual ~sipQAmbientTemperatureFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QAmbientTemperatureReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQAmbientTemperatureFilter(const sipQAmbientTemperatureFilter &);
    sipQAmbientTemperatureFilter &operator = (const sipQAmbientTemperatureFilter &);

    char sipPyMethods[1];
};

sipQAmbientTemperatureFilter::sipQAmbientTemperatureFilter():  ::QAmbientTemperatureFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAmbientTemperatureFilter::sipQAmbientTemperatureFilter(const  ::QAmbientTemperatureFilter& a0):  ::QAmbientTemperatureFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAmbientTemperatureFilter::~sipQAmbientTemperatureFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQAmbientTemperatureFilter::filter( ::QAmbientTemperatureReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QAmbientTemperatureFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QAmbientTemperatureReading*);

    return sipVH_QtSensors_10(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QAmbientTemperatureFilter_filter, "filter(self, QAmbientTemperatureReading) -> bool");

extern "C" {static PyObject *meth_QAmbientTemperatureFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QAmbientTemperatureFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QAmbientTemperatureReading* a0;
         ::QAmbientTemperatureFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QAmbientTemperatureFilter, &sipCpp, sipType_QAmbientTemperatureReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QAmbientTemperatureFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAmbientTemperatureFilter, sipName_filter, doc_QAmbientTemperatureFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAmbientTemperatureFilter(void *, const sipTypeDef *);}
static void *cast_QAmbientTemperatureFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAmbientTemperatureFilter *sipCpp = reinterpret_cast< ::QAmbientTemperatureFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAmbientTemperatureFilter(void *, int);}
static void release_QAmbientTemperatureFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQAmbientTemperatureFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QAmbientTemperatureFilter *>(sipCppV);
}


extern "C" {static void dealloc_QAmbientTemperatureFilter(sipSimpleWrapper *);}
static void dealloc_QAmbientTemperatureFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQAmbientTemperatureFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAmbientTemperatureFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QAmbientTemperatureFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QAmbientTemperatureFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQAmbientTemperatureFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQAmbientTemperatureFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QAmbientTemperatureFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QAmbientTemperatureFilter, &a0))
        {
            sipCpp = new sipQAmbientTemperatureFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAmbientTemperatureFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QAmbientTemperatureFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QAmbientTemperatureFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QAmbientTemperatureFilter_filter)}
};

PyDoc_STRVAR(doc_QAmbientTemperatureFilter, "\1QAmbientTemperatureFilter()\n"
"QAmbientTemperatureFilter(QAmbientTemperatureFilter)");


static pyqt5ClassPluginDef plugin_QAmbientTemperatureFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAmbientTemperatureFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAmbientTemperatureFilter,
        {SIP_NULLPTR},
        &plugin_QAmbientTemperatureFilter
    },
    {
        sipNameNr_QAmbientTemperatureFilter,
        {0, 0, 1},
        1, methods_QAmbientTemperatureFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QAmbientTemperatureFilter,
    -1,
    -1,
    supers_QAmbientTemperatureFilter,
    SIP_NULLPTR,
    init_type_QAmbientTemperatureFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAmbientTemperatureFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAmbientTemperatureFilter,
    cast_QAmbientTemperatureFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambienttemperaturesensor.sip"
#include <qambienttemperaturesensor.h>
#line 5824 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 5828 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 5831 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5834 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5837 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5840 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 5843 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 5846 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5849 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 5852 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5855 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 5858 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 5861 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 5864 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 5867 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 5870 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 5873 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


PyDoc_STRVAR(doc_QAmbientTemperatureReading_temperature, "temperature(self) -> float");

extern "C" {static PyObject *meth_QAmbientTemperatureReading_temperature(PyObject *, PyObject *);}
static PyObject *meth_QAmbientTemperatureReading_temperature(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QAmbientTemperatureReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QAmbientTemperatureReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->temperature();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAmbientTemperatureReading, sipName_temperature, doc_QAmbientTemperatureReading_temperature);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QAmbientTemperatureReading_setTemperature, "setTemperature(self, float)");

extern "C" {static PyObject *meth_QAmbientTemperatureReading_setTemperature(PyObject *, PyObject *);}
static PyObject *meth_QAmbientTemperatureReading_setTemperature(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QAmbientTemperatureReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QAmbientTemperatureReading, &sipCpp, &a0))
        {
            sipCpp->setTemperature(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAmbientTemperatureReading, sipName_setTemperature, doc_QAmbientTemperatureReading_setTemperature);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAmbientTemperatureReading(void *, const sipTypeDef *);}
static void *cast_QAmbientTemperatureReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAmbientTemperatureReading *sipCpp = reinterpret_cast< ::QAmbientTemperatureReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAmbientTemperatureReading(void *, int);}
static void release_QAmbientTemperatureReading(void *sipCppV, int)
{
     ::QAmbientTemperatureReading *sipCpp = reinterpret_cast< ::QAmbientTemperatureReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QAmbientTemperatureReading(sipSimpleWrapper *);}
static void dealloc_QAmbientTemperatureReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAmbientTemperatureReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAmbientTemperatureReading[] = {{60, 255, 1}};


static PyMethodDef methods_QAmbientTemperatureReading[] = {
    {SIP_MLNAME_CAST(sipName_setTemperature), meth_QAmbientTemperatureReading_setTemperature, METH_VARARGS, SIP_MLDOC_CAST(doc_QAmbientTemperatureReading_setTemperature)},
    {SIP_MLNAME_CAST(sipName_temperature), meth_QAmbientTemperatureReading_temperature, METH_VARARGS, SIP_MLDOC_CAST(doc_QAmbientTemperatureReading_temperature)}
};


static pyqt5ClassPluginDef plugin_QAmbientTemperatureReading = {
    & ::QAmbientTemperatureReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAmbientTemperatureReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAmbientTemperatureReading,
        {SIP_NULLPTR},
        &plugin_QAmbientTemperatureReading
    },
    {
        sipNameNr_QAmbientTemperatureReading,
        {0, 0, 1},
        2, methods_QAmbientTemperatureReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QAmbientTemperatureReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAmbientTemperatureReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAmbientTemperatureReading,
    cast_QAmbientTemperatureReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 65 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambientlightsensor.sip"
#include <qambientlightsensor.h>
#line 6040 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 6044 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambientlightsensor.sip"
#include <qambientlightsensor.h>
#line 6047 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 6050 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 6053 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6056 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6059 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 6062 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 6065 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6068 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 6071 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 6075 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 6078 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6081 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6084 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6087 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 6090 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6093 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6096 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 6099 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6102 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 6105 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 6108 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 6111 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQAmbientLightSensor : public  ::QAmbientLightSensor
{
public:
    sipQAmbientLightSensor( ::QObject*);
    virtual ~sipQAmbientLightSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQAmbientLightSensor(const sipQAmbientLightSensor &);
    sipQAmbientLightSensor &operator = (const sipQAmbientLightSensor &);

    char sipPyMethods[7];
};

sipQAmbientLightSensor::sipQAmbientLightSensor( ::QObject*a0):  ::QAmbientLightSensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAmbientLightSensor::~sipQAmbientLightSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQAmbientLightSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QAmbientLightSensor);

    return  ::QAmbientLightSensor::metaObject();
}

int sipQAmbientLightSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QAmbientLightSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QAmbientLightSensor,_c,_id,_a);

    return _id;
}

void *sipQAmbientLightSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QAmbientLightSensor, _clname, &sipCpp) ? sipCpp :  ::QAmbientLightSensor::qt_metacast(_clname));
}

void sipQAmbientLightSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QAmbientLightSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAmbientLightSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QAmbientLightSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAmbientLightSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QAmbientLightSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAmbientLightSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QAmbientLightSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAmbientLightSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QAmbientLightSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQAmbientLightSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QAmbientLightSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQAmbientLightSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QAmbientLightSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QAmbientLightSensor_reading, "reading(self) -> QAmbientLightReading");

extern "C" {static PyObject *meth_QAmbientLightSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QAmbientLightSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QAmbientLightSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QAmbientLightSensor, &sipCpp))
        {
             ::QAmbientLightReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QAmbientLightReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAmbientLightSensor, sipName_reading, doc_QAmbientLightSensor_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAmbientLightSensor(void *, const sipTypeDef *);}
static void *cast_QAmbientLightSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAmbientLightSensor *sipCpp = reinterpret_cast< ::QAmbientLightSensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAmbientLightSensor(void *, int);}
static void release_QAmbientLightSensor(void *sipCppV, int)
{
     ::QAmbientLightSensor *sipCpp = reinterpret_cast< ::QAmbientLightSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QAmbientLightSensor(sipSimpleWrapper *);}
static void dealloc_QAmbientLightSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQAmbientLightSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAmbientLightSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QAmbientLightSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QAmbientLightSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQAmbientLightSensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQAmbientLightSensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAmbientLightSensor[] = {{56, 255, 1}};


static PyMethodDef methods_QAmbientLightSensor[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QAmbientLightSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QAmbientLightSensor_reading)}
};

PyDoc_STRVAR(doc_QAmbientLightSensor, "\1QAmbientLightSensor(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QAmbientLightSensor = {
    & ::QAmbientLightSensor::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAmbientLightSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAmbientLightSensor,
        {SIP_NULLPTR},
        &plugin_QAmbientLightSensor
    },
    {
        sipNameNr_QAmbientLightSensor,
        {0, 0, 1},
        1, methods_QAmbientLightSensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QAmbientLightSensor,
    -1,
    -1,
    supers_QAmbientLightSensor,
    SIP_NULLPTR,
    init_type_QAmbientLightSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAmbientLightSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAmbientLightSensor,
    cast_QAmbientLightSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 52 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambientlightsensor.sip"
#include <qambientlightsensor.h>
#line 6470 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambientlightsensor.sip"
#include <qambientlightsensor.h>
#line 6474 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQAmbientLightFilter : public  ::QAmbientLightFilter
{
public:
    sipQAmbientLightFilter();
    sipQAmbientLightFilter(const  ::QAmbientLightFilter&);
    virtual ~sipQAmbientLightFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QAmbientLightReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQAmbientLightFilter(const sipQAmbientLightFilter &);
    sipQAmbientLightFilter &operator = (const sipQAmbientLightFilter &);

    char sipPyMethods[1];
};

sipQAmbientLightFilter::sipQAmbientLightFilter():  ::QAmbientLightFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAmbientLightFilter::sipQAmbientLightFilter(const  ::QAmbientLightFilter& a0):  ::QAmbientLightFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAmbientLightFilter::~sipQAmbientLightFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQAmbientLightFilter::filter( ::QAmbientLightReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QAmbientLightFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QAmbientLightReading*);

    return sipVH_QtSensors_9(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QAmbientLightFilter_filter, "filter(self, QAmbientLightReading) -> bool");

extern "C" {static PyObject *meth_QAmbientLightFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QAmbientLightFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QAmbientLightReading* a0;
         ::QAmbientLightFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QAmbientLightFilter, &sipCpp, sipType_QAmbientLightReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QAmbientLightFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAmbientLightFilter, sipName_filter, doc_QAmbientLightFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAmbientLightFilter(void *, const sipTypeDef *);}
static void *cast_QAmbientLightFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAmbientLightFilter *sipCpp = reinterpret_cast< ::QAmbientLightFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAmbientLightFilter(void *, int);}
static void release_QAmbientLightFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQAmbientLightFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QAmbientLightFilter *>(sipCppV);
}


extern "C" {static void dealloc_QAmbientLightFilter(sipSimpleWrapper *);}
static void dealloc_QAmbientLightFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQAmbientLightFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAmbientLightFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QAmbientLightFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QAmbientLightFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQAmbientLightFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQAmbientLightFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QAmbientLightFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QAmbientLightFilter, &a0))
        {
            sipCpp = new sipQAmbientLightFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAmbientLightFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QAmbientLightFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QAmbientLightFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QAmbientLightFilter_filter)}
};

PyDoc_STRVAR(doc_QAmbientLightFilter, "\1QAmbientLightFilter()\n"
"QAmbientLightFilter(QAmbientLightFilter)");


static pyqt5ClassPluginDef plugin_QAmbientLightFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAmbientLightFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAmbientLightFilter,
        {SIP_NULLPTR},
        &plugin_QAmbientLightFilter
    },
    {
        sipNameNr_QAmbientLightFilter,
        {0, 0, 1},
        1, methods_QAmbientLightFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QAmbientLightFilter,
    -1,
    -1,
    supers_QAmbientLightFilter,
    SIP_NULLPTR,
    init_type_QAmbientLightFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAmbientLightFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAmbientLightFilter,
    cast_QAmbientLightFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambientlightsensor.sip"
#include <qambientlightsensor.h>
#line 6711 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 6715 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 6718 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6721 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6724 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6727 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 6730 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 6733 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6736 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 6739 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6742 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6745 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 6748 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6751 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 6754 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 6757 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 6760 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


PyDoc_STRVAR(doc_QAmbientLightReading_lightLevel, "lightLevel(self) -> QAmbientLightReading.LightLevel");

extern "C" {static PyObject *meth_QAmbientLightReading_lightLevel(PyObject *, PyObject *);}
static PyObject *meth_QAmbientLightReading_lightLevel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QAmbientLightReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QAmbientLightReading, &sipCpp))
        {
             ::QAmbientLightReading::LightLevel sipRes;

            sipRes = sipCpp->lightLevel();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QAmbientLightReading_LightLevel);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAmbientLightReading, sipName_lightLevel, doc_QAmbientLightReading_lightLevel);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QAmbientLightReading_setLightLevel, "setLightLevel(self, QAmbientLightReading.LightLevel)");

extern "C" {static PyObject *meth_QAmbientLightReading_setLightLevel(PyObject *, PyObject *);}
static PyObject *meth_QAmbientLightReading_setLightLevel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QAmbientLightReading::LightLevel a0;
         ::QAmbientLightReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QAmbientLightReading, &sipCpp, sipType_QAmbientLightReading_LightLevel, &a0))
        {
            sipCpp->setLightLevel(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAmbientLightReading, sipName_setLightLevel, doc_QAmbientLightReading_setLightLevel);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAmbientLightReading(void *, const sipTypeDef *);}
static void *cast_QAmbientLightReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAmbientLightReading *sipCpp = reinterpret_cast< ::QAmbientLightReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAmbientLightReading(void *, int);}
static void release_QAmbientLightReading(void *sipCppV, int)
{
     ::QAmbientLightReading *sipCpp = reinterpret_cast< ::QAmbientLightReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QAmbientLightReading(sipSimpleWrapper *);}
static void dealloc_QAmbientLightReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAmbientLightReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAmbientLightReading[] = {{60, 255, 1}};


static PyMethodDef methods_QAmbientLightReading[] = {
    {SIP_MLNAME_CAST(sipName_lightLevel), meth_QAmbientLightReading_lightLevel, METH_VARARGS, SIP_MLDOC_CAST(doc_QAmbientLightReading_lightLevel)},
    {SIP_MLNAME_CAST(sipName_setLightLevel), meth_QAmbientLightReading_setLightLevel, METH_VARARGS, SIP_MLDOC_CAST(doc_QAmbientLightReading_setLightLevel)}
};

static sipEnumMemberDef enummembers_QAmbientLightReading[] = {
    {sipName_Bright, static_cast<int>( ::QAmbientLightReading::Bright), 9},
    {sipName_Dark, static_cast<int>( ::QAmbientLightReading::Dark), 9},
    {sipName_Light, static_cast<int>( ::QAmbientLightReading::Light), 9},
    {sipName_Sunny, static_cast<int>( ::QAmbientLightReading::Sunny), 9},
    {sipName_Twilight, static_cast<int>( ::QAmbientLightReading::Twilight), 9},
    {sipName_Undefined, static_cast<int>( ::QAmbientLightReading::Undefined), 9},
};


static pyqt5ClassPluginDef plugin_QAmbientLightReading = {
    & ::QAmbientLightReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAmbientLightReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAmbientLightReading,
        {SIP_NULLPTR},
        &plugin_QAmbientLightReading
    },
    {
        sipNameNr_QAmbientLightReading,
        {0, 0, 1},
        2, methods_QAmbientLightReading,
        6, enummembers_QAmbientLightReading,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QAmbientLightReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAmbientLightReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAmbientLightReading,
    cast_QAmbientLightReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 55 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaltimeter.sip"
#include <qaltimeter.h>
#line 6936 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 6940 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaltimeter.sip"
#include <qaltimeter.h>
#line 6943 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 6946 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 6949 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6952 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6955 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 6958 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 6961 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6964 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 6967 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 6971 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 6974 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6977 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6980 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6983 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 6986 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6989 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6992 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 6995 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6998 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 7001 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 7004 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 7007 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQAltimeter : public  ::QAltimeter
{
public:
    sipQAltimeter( ::QObject*);
    virtual ~sipQAltimeter();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQAltimeter(const sipQAltimeter &);
    sipQAltimeter &operator = (const sipQAltimeter &);

    char sipPyMethods[7];
};

sipQAltimeter::sipQAltimeter( ::QObject*a0):  ::QAltimeter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAltimeter::~sipQAltimeter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQAltimeter::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QAltimeter);

    return  ::QAltimeter::metaObject();
}

int sipQAltimeter::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QAltimeter::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QAltimeter,_c,_id,_a);

    return _id;
}

void *sipQAltimeter::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QAltimeter, _clname, &sipCpp) ? sipCpp :  ::QAltimeter::qt_metacast(_clname));
}

void sipQAltimeter::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QAltimeter::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAltimeter::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QAltimeter::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAltimeter::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QAltimeter::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAltimeter::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QAltimeter::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAltimeter::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QAltimeter::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQAltimeter::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QAltimeter::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQAltimeter::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QAltimeter::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QAltimeter_reading, "reading(self) -> QAltimeterReading");

extern "C" {static PyObject *meth_QAltimeter_reading(PyObject *, PyObject *);}
static PyObject *meth_QAltimeter_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QAltimeter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QAltimeter, &sipCpp))
        {
             ::QAltimeterReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QAltimeterReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAltimeter, sipName_reading, doc_QAltimeter_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAltimeter(void *, const sipTypeDef *);}
static void *cast_QAltimeter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAltimeter *sipCpp = reinterpret_cast< ::QAltimeter *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAltimeter(void *, int);}
static void release_QAltimeter(void *sipCppV, int)
{
     ::QAltimeter *sipCpp = reinterpret_cast< ::QAltimeter *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QAltimeter(sipSimpleWrapper *);}
static void dealloc_QAltimeter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQAltimeter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAltimeter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QAltimeter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QAltimeter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQAltimeter *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQAltimeter(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAltimeter[] = {{56, 255, 1}};


static PyMethodDef methods_QAltimeter[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QAltimeter_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QAltimeter_reading)}
};

PyDoc_STRVAR(doc_QAltimeter, "\1QAltimeter(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QAltimeter = {
    & ::QAltimeter::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAltimeter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAltimeter,
        {SIP_NULLPTR},
        &plugin_QAltimeter
    },
    {
        sipNameNr_QAltimeter,
        {0, 0, 1},
        1, methods_QAltimeter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QAltimeter,
    -1,
    -1,
    supers_QAltimeter,
    SIP_NULLPTR,
    init_type_QAltimeter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAltimeter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAltimeter,
    cast_QAltimeter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 42 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaltimeter.sip"
#include <qaltimeter.h>
#line 7366 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaltimeter.sip"
#include <qaltimeter.h>
#line 7370 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQAltimeterFilter : public  ::QAltimeterFilter
{
public:
    sipQAltimeterFilter();
    sipQAltimeterFilter(const  ::QAltimeterFilter&);
    virtual ~sipQAltimeterFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QAltimeterReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQAltimeterFilter(const sipQAltimeterFilter &);
    sipQAltimeterFilter &operator = (const sipQAltimeterFilter &);

    char sipPyMethods[1];
};

sipQAltimeterFilter::sipQAltimeterFilter():  ::QAltimeterFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAltimeterFilter::sipQAltimeterFilter(const  ::QAltimeterFilter& a0):  ::QAltimeterFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAltimeterFilter::~sipQAltimeterFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQAltimeterFilter::filter( ::QAltimeterReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QAltimeterFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QAltimeterReading*);

    return sipVH_QtSensors_8(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QAltimeterFilter_filter, "filter(self, QAltimeterReading) -> bool");

extern "C" {static PyObject *meth_QAltimeterFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QAltimeterFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QAltimeterReading* a0;
         ::QAltimeterFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QAltimeterFilter, &sipCpp, sipType_QAltimeterReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QAltimeterFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAltimeterFilter, sipName_filter, doc_QAltimeterFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAltimeterFilter(void *, const sipTypeDef *);}
static void *cast_QAltimeterFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAltimeterFilter *sipCpp = reinterpret_cast< ::QAltimeterFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAltimeterFilter(void *, int);}
static void release_QAltimeterFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQAltimeterFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QAltimeterFilter *>(sipCppV);
}


extern "C" {static void dealloc_QAltimeterFilter(sipSimpleWrapper *);}
static void dealloc_QAltimeterFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQAltimeterFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAltimeterFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QAltimeterFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QAltimeterFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQAltimeterFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQAltimeterFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QAltimeterFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QAltimeterFilter, &a0))
        {
            sipCpp = new sipQAltimeterFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAltimeterFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QAltimeterFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QAltimeterFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QAltimeterFilter_filter)}
};

PyDoc_STRVAR(doc_QAltimeterFilter, "\1QAltimeterFilter()\n"
"QAltimeterFilter(QAltimeterFilter)");


static pyqt5ClassPluginDef plugin_QAltimeterFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAltimeterFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAltimeterFilter,
        {SIP_NULLPTR},
        &plugin_QAltimeterFilter
    },
    {
        sipNameNr_QAltimeterFilter,
        {0, 0, 1},
        1, methods_QAltimeterFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QAltimeterFilter,
    -1,
    -1,
    supers_QAltimeterFilter,
    SIP_NULLPTR,
    init_type_QAltimeterFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAltimeterFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAltimeterFilter,
    cast_QAltimeterFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaltimeter.sip"
#include <qaltimeter.h>
#line 7607 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 7611 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 7614 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7617 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7620 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7623 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 7626 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 7629 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7632 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 7635 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7638 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 7641 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 7644 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 7647 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 7650 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 7653 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 7656 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


PyDoc_STRVAR(doc_QAltimeterReading_altitude, "altitude(self) -> float");

extern "C" {static PyObject *meth_QAltimeterReading_altitude(PyObject *, PyObject *);}
static PyObject *meth_QAltimeterReading_altitude(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QAltimeterReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QAltimeterReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->altitude();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAltimeterReading, sipName_altitude, doc_QAltimeterReading_altitude);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QAltimeterReading_setAltitude, "setAltitude(self, float)");

extern "C" {static PyObject *meth_QAltimeterReading_setAltitude(PyObject *, PyObject *);}
static PyObject *meth_QAltimeterReading_setAltitude(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QAltimeterReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QAltimeterReading, &sipCpp, &a0))
        {
            sipCpp->setAltitude(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAltimeterReading, sipName_setAltitude, doc_QAltimeterReading_setAltitude);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAltimeterReading(void *, const sipTypeDef *);}
static void *cast_QAltimeterReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAltimeterReading *sipCpp = reinterpret_cast< ::QAltimeterReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAltimeterReading(void *, int);}
static void release_QAltimeterReading(void *sipCppV, int)
{
     ::QAltimeterReading *sipCpp = reinterpret_cast< ::QAltimeterReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QAltimeterReading(sipSimpleWrapper *);}
static void dealloc_QAltimeterReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAltimeterReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAltimeterReading[] = {{60, 255, 1}};


static PyMethodDef methods_QAltimeterReading[] = {
    {SIP_MLNAME_CAST(sipName_altitude), meth_QAltimeterReading_altitude, METH_VARARGS, SIP_MLDOC_CAST(doc_QAltimeterReading_altitude)},
    {SIP_MLNAME_CAST(sipName_setAltitude), meth_QAltimeterReading_setAltitude, METH_VARARGS, SIP_MLDOC_CAST(doc_QAltimeterReading_setAltitude)}
};


static pyqt5ClassPluginDef plugin_QAltimeterReading = {
    & ::QAltimeterReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAltimeterReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAltimeterReading,
        {SIP_NULLPTR},
        &plugin_QAltimeterReading
    },
    {
        sipNameNr_QAltimeterReading,
        {0, 0, 1},
        2, methods_QAltimeterReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QAltimeterReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAltimeterReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAltimeterReading,
    cast_QAltimeterReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 59 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaccelerometer.sip"
#include <qaccelerometer.h>
#line 7823 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 7827 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaccelerometer.sip"
#include <qaccelerometer.h>
#line 7830 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 7833 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 7836 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7839 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7842 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 7845 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 7848 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7851 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 7854 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 7858 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 7861 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7864 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7867 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7870 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 7873 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7876 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 7879 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 7882 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 7885 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 7888 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 7891 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 7894 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQAccelerometer : public  ::QAccelerometer
{
public:
    sipQAccelerometer( ::QObject*);
    virtual ~sipQAccelerometer();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQAccelerometer(const sipQAccelerometer &);
    sipQAccelerometer &operator = (const sipQAccelerometer &);

    char sipPyMethods[7];
};

sipQAccelerometer::sipQAccelerometer( ::QObject*a0):  ::QAccelerometer(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAccelerometer::~sipQAccelerometer()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQAccelerometer::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QAccelerometer);

    return  ::QAccelerometer::metaObject();
}

int sipQAccelerometer::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QAccelerometer::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QAccelerometer,_c,_id,_a);

    return _id;
}

void *sipQAccelerometer::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QAccelerometer, _clname, &sipCpp) ? sipCpp :  ::QAccelerometer::qt_metacast(_clname));
}

void sipQAccelerometer::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QAccelerometer::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAccelerometer::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QAccelerometer::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAccelerometer::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QAccelerometer::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAccelerometer::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QAccelerometer::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQAccelerometer::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QAccelerometer::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQAccelerometer::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QAccelerometer::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQAccelerometer::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QAccelerometer::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QAccelerometer_accelerationMode, "accelerationMode(self) -> QAccelerometer.AccelerationMode");

extern "C" {static PyObject *meth_QAccelerometer_accelerationMode(PyObject *, PyObject *);}
static PyObject *meth_QAccelerometer_accelerationMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QAccelerometer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QAccelerometer, &sipCpp))
        {
             ::QAccelerometer::AccelerationMode sipRes;

            sipRes = sipCpp->accelerationMode();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QAccelerometer_AccelerationMode);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAccelerometer, sipName_accelerationMode, doc_QAccelerometer_accelerationMode);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QAccelerometer_setAccelerationMode, "setAccelerationMode(self, QAccelerometer.AccelerationMode)");

extern "C" {static PyObject *meth_QAccelerometer_setAccelerationMode(PyObject *, PyObject *);}
static PyObject *meth_QAccelerometer_setAccelerationMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QAccelerometer::AccelerationMode a0;
         ::QAccelerometer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QAccelerometer, &sipCpp, sipType_QAccelerometer_AccelerationMode, &a0))
        {
            sipCpp->setAccelerationMode(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAccelerometer, sipName_setAccelerationMode, doc_QAccelerometer_setAccelerationMode);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QAccelerometer_reading, "reading(self) -> QAccelerometerReading");

extern "C" {static PyObject *meth_QAccelerometer_reading(PyObject *, PyObject *);}
static PyObject *meth_QAccelerometer_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QAccelerometer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QAccelerometer, &sipCpp))
        {
             ::QAccelerometerReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QAccelerometerReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAccelerometer, sipName_reading, doc_QAccelerometer_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAccelerometer(void *, const sipTypeDef *);}
static void *cast_QAccelerometer(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAccelerometer *sipCpp = reinterpret_cast< ::QAccelerometer *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAccelerometer(void *, int);}
static void release_QAccelerometer(void *sipCppV, int)
{
     ::QAccelerometer *sipCpp = reinterpret_cast< ::QAccelerometer *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QAccelerometer(sipSimpleWrapper *);}
static void dealloc_QAccelerometer(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQAccelerometer *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAccelerometer(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QAccelerometer(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QAccelerometer(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQAccelerometer *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQAccelerometer(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAccelerometer[] = {{56, 255, 1}};


static PyMethodDef methods_QAccelerometer[] = {
    {SIP_MLNAME_CAST(sipName_accelerationMode), meth_QAccelerometer_accelerationMode, METH_VARARGS, SIP_MLDOC_CAST(doc_QAccelerometer_accelerationMode)},
    {SIP_MLNAME_CAST(sipName_reading), meth_QAccelerometer_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QAccelerometer_reading)},
    {SIP_MLNAME_CAST(sipName_setAccelerationMode), meth_QAccelerometer_setAccelerationMode, METH_VARARGS, SIP_MLDOC_CAST(doc_QAccelerometer_setAccelerationMode)}
};

static sipEnumMemberDef enummembers_QAccelerometer[] = {
    {sipName_Combined, static_cast<int>( ::QAccelerometer::Combined), 1},
    {sipName_Gravity, static_cast<int>( ::QAccelerometer::Gravity), 1},
    {sipName_User, static_cast<int>( ::QAccelerometer::User), 1},
};

PyDoc_STRVAR(doc_QAccelerometer, "\1QAccelerometer(parent: QObject = None)");


/* Define this type's signals. */
static const pyqt5QtSignal signals_QAccelerometer[] = {
    {"accelerationModeChanged(AccelerationMode)|(QAccelerometer::AccelerationMode)", "\1accelerationModeChanged(self, QAccelerometer.AccelerationMode)", SIP_NULLPTR, SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


static pyqt5ClassPluginDef plugin_QAccelerometer = {
    & ::QAccelerometer::staticMetaObject,
    0,
    signals_QAccelerometer,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAccelerometer = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAccelerometer,
        {SIP_NULLPTR},
        &plugin_QAccelerometer
    },
    {
        sipNameNr_QAccelerometer,
        {0, 0, 1},
        3, methods_QAccelerometer,
        3, enummembers_QAccelerometer,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QAccelerometer,
    -1,
    -1,
    supers_QAccelerometer,
    SIP_NULLPTR,
    init_type_QAccelerometer,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAccelerometer,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAccelerometer,
    cast_QAccelerometer,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 8324 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 8328 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 8331 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8334 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 51 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 8337 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8340 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 8343 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 8346 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8349 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 8352 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 8356 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 8359 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 8362 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 8365 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 8368 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 8371 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8374 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 8377 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 8380 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 8383 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 8386 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 8389 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 8392 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQSensor : public  ::QSensor
{
public:
    sipQSensor(const  ::QByteArray&, ::QObject*);
    virtual ~sipQSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool event( ::QEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQSensor(const sipQSensor &);
    sipQSensor &operator = (const sipQSensor &);

    char sipPyMethods[7];
};

sipQSensor::sipQSensor(const  ::QByteArray& a0, ::QObject*a1):  ::QSensor(a0,a1), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQSensor::~sipQSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QSensor);

    return  ::QSensor::metaObject();
}

int sipQSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QSensor,_c,_id,_a);

    return _id;
}

void *sipQSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QSensor, _clname, &sipCpp) ? sipCpp :  ::QSensor::qt_metacast(_clname));
}

bool sipQSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

void sipQSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QSensor_identifier, "identifier(self) -> QByteArray");

extern "C" {static PyObject *meth_QSensor_identifier(PyObject *, PyObject *);}
static PyObject *meth_QSensor_identifier(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->identifier());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_identifier, doc_QSensor_identifier);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setIdentifier, "setIdentifier(self, Union[QByteArray, bytes, bytearray])");

extern "C" {static PyObject *meth_QSensor_setIdentifier(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setIdentifier(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray* a0;
        int a0State = 0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSensor, &sipCpp, sipType_QByteArray, &a0, &a0State))
        {
            sipCpp->setIdentifier(*a0);
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setIdentifier, doc_QSensor_setIdentifier);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_type, "type(self) -> QByteArray");

extern "C" {static PyObject *meth_QSensor_type(PyObject *, PyObject *);}
static PyObject *meth_QSensor_type(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->type());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_type, doc_QSensor_type);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_connectToBackend, "connectToBackend(self) -> bool");

extern "C" {static PyObject *meth_QSensor_connectToBackend(PyObject *, PyObject *);}
static PyObject *meth_QSensor_connectToBackend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->connectToBackend();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_connectToBackend, doc_QSensor_connectToBackend);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_isConnectedToBackend, "isConnectedToBackend(self) -> bool");

extern "C" {static PyObject *meth_QSensor_isConnectedToBackend(PyObject *, PyObject *);}
static PyObject *meth_QSensor_isConnectedToBackend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isConnectedToBackend();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_isConnectedToBackend, doc_QSensor_isConnectedToBackend);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_isBusy, "isBusy(self) -> bool");

extern "C" {static PyObject *meth_QSensor_isBusy(PyObject *, PyObject *);}
static PyObject *meth_QSensor_isBusy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isBusy();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_isBusy, doc_QSensor_isBusy);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setActive, "setActive(self, bool)");

extern "C" {static PyObject *meth_QSensor_setActive(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setActive(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QSensor, &sipCpp, &a0))
        {
            sipCpp->setActive(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setActive, doc_QSensor_setActive);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_isActive, "isActive(self) -> bool");

extern "C" {static PyObject *meth_QSensor_isActive(PyObject *, PyObject *);}
static PyObject *meth_QSensor_isActive(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isActive();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_isActive, doc_QSensor_isActive);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_isAlwaysOn, "isAlwaysOn(self) -> bool");

extern "C" {static PyObject *meth_QSensor_isAlwaysOn(PyObject *, PyObject *);}
static PyObject *meth_QSensor_isAlwaysOn(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isAlwaysOn();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_isAlwaysOn, doc_QSensor_isAlwaysOn);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setAlwaysOn, "setAlwaysOn(self, bool)");

extern "C" {static PyObject *meth_QSensor_setAlwaysOn(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setAlwaysOn(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QSensor, &sipCpp, &a0))
        {
            sipCpp->setAlwaysOn(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setAlwaysOn, doc_QSensor_setAlwaysOn);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_skipDuplicates, "skipDuplicates(self) -> bool");

extern "C" {static PyObject *meth_QSensor_skipDuplicates(PyObject *, PyObject *);}
static PyObject *meth_QSensor_skipDuplicates(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->skipDuplicates();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_skipDuplicates, doc_QSensor_skipDuplicates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setSkipDuplicates, "setSkipDuplicates(self, bool)");

extern "C" {static PyObject *meth_QSensor_setSkipDuplicates(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setSkipDuplicates(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QSensor, &sipCpp, &a0))
        {
            sipCpp->setSkipDuplicates(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setSkipDuplicates, doc_QSensor_setSkipDuplicates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_availableDataRates, "availableDataRates(self) -> List[Tuple[int, int]]");

extern "C" {static PyObject *meth_QSensor_availableDataRates(PyObject *, PyObject *);}
static PyObject *meth_QSensor_availableDataRates(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
             ::qrangelist*sipRes;

            sipRes = new  ::qrangelist(sipCpp->availableDataRates());

            return sipConvertFromNewType(sipRes,sipType_QList_0600QPair_1800_1800,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_availableDataRates, doc_QSensor_availableDataRates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_dataRate, "dataRate(self) -> int");

extern "C" {static PyObject *meth_QSensor_dataRate(PyObject *, PyObject *);}
static PyObject *meth_QSensor_dataRate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->dataRate();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_dataRate, doc_QSensor_dataRate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setDataRate, "setDataRate(self, int)");

extern "C" {static PyObject *meth_QSensor_setDataRate(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setDataRate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QSensor, &sipCpp, &a0))
        {
            sipCpp->setDataRate(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setDataRate, doc_QSensor_setDataRate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_outputRanges, "outputRanges(self) -> List[qoutputrange]");

extern "C" {static PyObject *meth_QSensor_outputRanges(PyObject *, PyObject *);}
static PyObject *meth_QSensor_outputRanges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
             ::qoutputrangelist*sipRes;

            sipRes = new  ::qoutputrangelist(sipCpp->outputRanges());

            return sipConvertFromNewType(sipRes,sipType_QList_0100qoutputrange,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_outputRanges, doc_QSensor_outputRanges);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_outputRange, "outputRange(self) -> int");

extern "C" {static PyObject *meth_QSensor_outputRange(PyObject *, PyObject *);}
static PyObject *meth_QSensor_outputRange(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->outputRange();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_outputRange, doc_QSensor_outputRange);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setOutputRange, "setOutputRange(self, int)");

extern "C" {static PyObject *meth_QSensor_setOutputRange(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setOutputRange(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QSensor, &sipCpp, &a0))
        {
            sipCpp->setOutputRange(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setOutputRange, doc_QSensor_setOutputRange);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_description, "description(self) -> str");

extern "C" {static PyObject *meth_QSensor_description(PyObject *, PyObject *);}
static PyObject *meth_QSensor_description(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->description());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_description, doc_QSensor_description);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_error, "error(self) -> int");

extern "C" {static PyObject *meth_QSensor_error(PyObject *, PyObject *);}
static PyObject *meth_QSensor_error(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->error();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_error, doc_QSensor_error);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_addFilter, "addFilter(self, QSensorFilter)");

extern "C" {static PyObject *meth_QSensor_addFilter(PyObject *, PyObject *);}
static PyObject *meth_QSensor_addFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSensorFilter* a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QSensor, &sipCpp, sipType_QSensorFilter, &a0))
        {
            sipCpp->addFilter(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_addFilter, doc_QSensor_addFilter);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_removeFilter, "removeFilter(self, QSensorFilter)");

extern "C" {static PyObject *meth_QSensor_removeFilter(PyObject *, PyObject *);}
static PyObject *meth_QSensor_removeFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSensorFilter* a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QSensor, &sipCpp, sipType_QSensorFilter, &a0))
        {
            sipCpp->removeFilter(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_removeFilter, doc_QSensor_removeFilter);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_filters, "filters(self) -> List[QSensorFilter]");

extern "C" {static PyObject *meth_QSensor_filters(PyObject *, PyObject *);}
static PyObject *meth_QSensor_filters(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            QList< ::QSensorFilter*>*sipRes;

            sipRes = new QList< ::QSensorFilter*>(sipCpp->filters());

            return sipConvertFromNewType(sipRes,sipType_QList_0101QSensorFilter,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_filters, doc_QSensor_filters);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_reading, "reading(self) -> QSensorReading");

extern "C" {static PyObject *meth_QSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
             ::QSensorReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QSensorReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_reading, doc_QSensor_reading);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_sensorTypes, "sensorTypes() -> List[QByteArray]");

extern "C" {static PyObject *meth_QSensor_sensorTypes(PyObject *, PyObject *);}
static PyObject *meth_QSensor_sensorTypes(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            QList< ::QByteArray>*sipRes;

            sipRes = new QList< ::QByteArray>( ::QSensor::sensorTypes());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_sensorTypes, doc_QSensor_sensorTypes);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_sensorsForType, "sensorsForType(Union[QByteArray, bytes, bytearray]) -> List[QByteArray]");

extern "C" {static PyObject *meth_QSensor_sensorsForType(PyObject *, PyObject *);}
static PyObject *meth_QSensor_sensorsForType(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_QByteArray, &a0, &a0State))
        {
            QList< ::QByteArray>*sipRes;

            sipRes = new QList< ::QByteArray>( ::QSensor::sensorsForType(*a0));
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            return sipConvertFromNewType(sipRes,sipType_QList_0100QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_sensorsForType, doc_QSensor_sensorsForType);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_defaultSensorForType, "defaultSensorForType(Union[QByteArray, bytes, bytearray]) -> QByteArray");

extern "C" {static PyObject *meth_QSensor_defaultSensorForType(PyObject *, PyObject *);}
static PyObject *meth_QSensor_defaultSensorForType(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_QByteArray, &a0, &a0State))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray( ::QSensor::defaultSensorForType(*a0));
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_defaultSensorForType, doc_QSensor_defaultSensorForType);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_isFeatureSupported, "isFeatureSupported(self, QSensor.Feature) -> bool");

extern "C" {static PyObject *meth_QSensor_isFeatureSupported(PyObject *, PyObject *);}
static PyObject *meth_QSensor_isFeatureSupported(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSensor::Feature a0;
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QSensor, &sipCpp, sipType_QSensor_Feature, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->isFeatureSupported(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_isFeatureSupported, doc_QSensor_isFeatureSupported);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_axesOrientationMode, "axesOrientationMode(self) -> QSensor.AxesOrientationMode");

extern "C" {static PyObject *meth_QSensor_axesOrientationMode(PyObject *, PyObject *);}
static PyObject *meth_QSensor_axesOrientationMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
             ::QSensor::AxesOrientationMode sipRes;

            sipRes = sipCpp->axesOrientationMode();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSensor_AxesOrientationMode);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_axesOrientationMode, doc_QSensor_axesOrientationMode);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setAxesOrientationMode, "setAxesOrientationMode(self, QSensor.AxesOrientationMode)");

extern "C" {static PyObject *meth_QSensor_setAxesOrientationMode(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setAxesOrientationMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSensor::AxesOrientationMode a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QSensor, &sipCpp, sipType_QSensor_AxesOrientationMode, &a0))
        {
            sipCpp->setAxesOrientationMode(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setAxesOrientationMode, doc_QSensor_setAxesOrientationMode);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_currentOrientation, "currentOrientation(self) -> int");

extern "C" {static PyObject *meth_QSensor_currentOrientation(PyObject *, PyObject *);}
static PyObject *meth_QSensor_currentOrientation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->currentOrientation();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_currentOrientation, doc_QSensor_currentOrientation);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setCurrentOrientation, "setCurrentOrientation(self, int)");

extern "C" {static PyObject *meth_QSensor_setCurrentOrientation(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setCurrentOrientation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QSensor, &sipCpp, &a0))
        {
            sipCpp->setCurrentOrientation(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setCurrentOrientation, doc_QSensor_setCurrentOrientation);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_userOrientation, "userOrientation(self) -> int");

extern "C" {static PyObject *meth_QSensor_userOrientation(PyObject *, PyObject *);}
static PyObject *meth_QSensor_userOrientation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->userOrientation();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_userOrientation, doc_QSensor_userOrientation);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setUserOrientation, "setUserOrientation(self, int)");

extern "C" {static PyObject *meth_QSensor_setUserOrientation(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setUserOrientation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QSensor, &sipCpp, &a0))
        {
            sipCpp->setUserOrientation(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setUserOrientation, doc_QSensor_setUserOrientation);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_maxBufferSize, "maxBufferSize(self) -> int");

extern "C" {static PyObject *meth_QSensor_maxBufferSize(PyObject *, PyObject *);}
static PyObject *meth_QSensor_maxBufferSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->maxBufferSize();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_maxBufferSize, doc_QSensor_maxBufferSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setMaxBufferSize, "setMaxBufferSize(self, int)");

extern "C" {static PyObject *meth_QSensor_setMaxBufferSize(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setMaxBufferSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QSensor, &sipCpp, &a0))
        {
            sipCpp->setMaxBufferSize(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setMaxBufferSize, doc_QSensor_setMaxBufferSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_efficientBufferSize, "efficientBufferSize(self) -> int");

extern "C" {static PyObject *meth_QSensor_efficientBufferSize(PyObject *, PyObject *);}
static PyObject *meth_QSensor_efficientBufferSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->efficientBufferSize();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_efficientBufferSize, doc_QSensor_efficientBufferSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setEfficientBufferSize, "setEfficientBufferSize(self, int)");

extern "C" {static PyObject *meth_QSensor_setEfficientBufferSize(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setEfficientBufferSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QSensor, &sipCpp, &a0))
        {
            sipCpp->setEfficientBufferSize(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setEfficientBufferSize, doc_QSensor_setEfficientBufferSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_bufferSize, "bufferSize(self) -> int");

extern "C" {static PyObject *meth_QSensor_bufferSize(PyObject *, PyObject *);}
static PyObject *meth_QSensor_bufferSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->bufferSize();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_bufferSize, doc_QSensor_bufferSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_setBufferSize, "setBufferSize(self, int)");

extern "C" {static PyObject *meth_QSensor_setBufferSize(PyObject *, PyObject *);}
static PyObject *meth_QSensor_setBufferSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QSensor, &sipCpp, &a0))
        {
            sipCpp->setBufferSize(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_setBufferSize, doc_QSensor_setBufferSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_start, "start(self) -> bool");

extern "C" {static PyObject *meth_QSensor_start(PyObject *, PyObject *);}
static PyObject *meth_QSensor_start(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->start();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_start, doc_QSensor_start);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensor_stop, "stop(self)");

extern "C" {static PyObject *meth_QSensor_stop(PyObject *, PyObject *);}
static PyObject *meth_QSensor_stop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensor, &sipCpp))
        {
            sipCpp->stop();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensor, sipName_stop, doc_QSensor_stop);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QSensor(void *, const sipTypeDef *);}
static void *cast_QSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QSensor *sipCpp = reinterpret_cast< ::QSensor *>(sipCppV);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QSensor(void *, int);}
static void release_QSensor(void *sipCppV, int)
{
     ::QSensor *sipCpp = reinterpret_cast< ::QSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QSensor(sipSimpleWrapper *);}
static void dealloc_QSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQSensor *sipCpp = SIP_NULLPTR;

    {
        const  ::QByteArray* a0;
        int a0State = 0;
         ::QObject* a1 = 0;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1|JH", sipType_QByteArray, &a0, &a0State, sipType_QObject, &a1, sipOwner))
        {
            sipCpp = new sipQSensor(*a0,a1);
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QSensor[] = {{6, 0, 1}};


static PyMethodDef methods_QSensor[] = {
    {SIP_MLNAME_CAST(sipName_addFilter), meth_QSensor_addFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_addFilter)},
    {SIP_MLNAME_CAST(sipName_availableDataRates), meth_QSensor_availableDataRates, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_availableDataRates)},
    {SIP_MLNAME_CAST(sipName_axesOrientationMode), meth_QSensor_axesOrientationMode, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_axesOrientationMode)},
    {SIP_MLNAME_CAST(sipName_bufferSize), meth_QSensor_bufferSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_bufferSize)},
    {SIP_MLNAME_CAST(sipName_connectToBackend), meth_QSensor_connectToBackend, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_connectToBackend)},
    {SIP_MLNAME_CAST(sipName_currentOrientation), meth_QSensor_currentOrientation, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_currentOrientation)},
    {SIP_MLNAME_CAST(sipName_dataRate), meth_QSensor_dataRate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_dataRate)},
    {SIP_MLNAME_CAST(sipName_defaultSensorForType), meth_QSensor_defaultSensorForType, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_defaultSensorForType)},
    {SIP_MLNAME_CAST(sipName_description), meth_QSensor_description, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_description)},
    {SIP_MLNAME_CAST(sipName_efficientBufferSize), meth_QSensor_efficientBufferSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_efficientBufferSize)},
    {SIP_MLNAME_CAST(sipName_error), meth_QSensor_error, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_error)},
    {SIP_MLNAME_CAST(sipName_filters), meth_QSensor_filters, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_filters)},
    {SIP_MLNAME_CAST(sipName_identifier), meth_QSensor_identifier, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_identifier)},
    {SIP_MLNAME_CAST(sipName_isActive), meth_QSensor_isActive, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_isActive)},
    {SIP_MLNAME_CAST(sipName_isAlwaysOn), meth_QSensor_isAlwaysOn, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_isAlwaysOn)},
    {SIP_MLNAME_CAST(sipName_isBusy), meth_QSensor_isBusy, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_isBusy)},
    {SIP_MLNAME_CAST(sipName_isConnectedToBackend), meth_QSensor_isConnectedToBackend, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_isConnectedToBackend)},
    {SIP_MLNAME_CAST(sipName_isFeatureSupported), meth_QSensor_isFeatureSupported, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_isFeatureSupported)},
    {SIP_MLNAME_CAST(sipName_maxBufferSize), meth_QSensor_maxBufferSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_maxBufferSize)},
    {SIP_MLNAME_CAST(sipName_outputRange), meth_QSensor_outputRange, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_outputRange)},
    {SIP_MLNAME_CAST(sipName_outputRanges), meth_QSensor_outputRanges, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_outputRanges)},
    {SIP_MLNAME_CAST(sipName_reading), meth_QSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_reading)},
    {SIP_MLNAME_CAST(sipName_removeFilter), meth_QSensor_removeFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_removeFilter)},
    {SIP_MLNAME_CAST(sipName_sensorTypes), meth_QSensor_sensorTypes, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_sensorTypes)},
    {SIP_MLNAME_CAST(sipName_sensorsForType), meth_QSensor_sensorsForType, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_sensorsForType)},
    {SIP_MLNAME_CAST(sipName_setActive), meth_QSensor_setActive, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setActive)},
    {SIP_MLNAME_CAST(sipName_setAlwaysOn), meth_QSensor_setAlwaysOn, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setAlwaysOn)},
    {SIP_MLNAME_CAST(sipName_setAxesOrientationMode), meth_QSensor_setAxesOrientationMode, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setAxesOrientationMode)},
    {SIP_MLNAME_CAST(sipName_setBufferSize), meth_QSensor_setBufferSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setBufferSize)},
    {SIP_MLNAME_CAST(sipName_setCurrentOrientation), meth_QSensor_setCurrentOrientation, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setCurrentOrientation)},
    {SIP_MLNAME_CAST(sipName_setDataRate), meth_QSensor_setDataRate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setDataRate)},
    {SIP_MLNAME_CAST(sipName_setEfficientBufferSize), meth_QSensor_setEfficientBufferSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setEfficientBufferSize)},
    {SIP_MLNAME_CAST(sipName_setIdentifier), meth_QSensor_setIdentifier, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setIdentifier)},
    {SIP_MLNAME_CAST(sipName_setMaxBufferSize), meth_QSensor_setMaxBufferSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setMaxBufferSize)},
    {SIP_MLNAME_CAST(sipName_setOutputRange), meth_QSensor_setOutputRange, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setOutputRange)},
    {SIP_MLNAME_CAST(sipName_setSkipDuplicates), meth_QSensor_setSkipDuplicates, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setSkipDuplicates)},
    {SIP_MLNAME_CAST(sipName_setUserOrientation), meth_QSensor_setUserOrientation, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_setUserOrientation)},
    {SIP_MLNAME_CAST(sipName_skipDuplicates), meth_QSensor_skipDuplicates, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_skipDuplicates)},
    {SIP_MLNAME_CAST(sipName_start), meth_QSensor_start, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_start)},
    {SIP_MLNAME_CAST(sipName_stop), meth_QSensor_stop, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_stop)},
    {SIP_MLNAME_CAST(sipName_type), meth_QSensor_type, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_type)},
    {SIP_MLNAME_CAST(sipName_userOrientation), meth_QSensor_userOrientation, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensor_userOrientation)}
};

static sipEnumMemberDef enummembers_QSensor[] = {
    {sipName_AccelerationMode, static_cast<int>( ::QSensor::AccelerationMode), 58},
    {sipName_AlwaysOn, static_cast<int>( ::QSensor::AlwaysOn), 58},
    {sipName_AutomaticOrientation, static_cast<int>( ::QSensor::AutomaticOrientation), 57},
    {sipName_AxesOrientation, static_cast<int>( ::QSensor::AxesOrientation), 58},
    {sipName_Buffering, static_cast<int>( ::QSensor::Buffering), 58},
    {sipName_FieldOfView, static_cast<int>( ::QSensor::FieldOfView), 58},
    {sipName_FixedOrientation, static_cast<int>( ::QSensor::FixedOrientation), 57},
    {sipName_GeoValues, static_cast<int>( ::QSensor::GeoValues), 58},
    {sipName_PressureSensorTemperature, static_cast<int>( ::QSensor::PressureSensorTemperature), 58},
    {sipName_SkipDuplicates, static_cast<int>( ::QSensor::SkipDuplicates), 58},
    {sipName_UserOrientation, static_cast<int>( ::QSensor::UserOrientation), 57},
};

PyDoc_STRVAR(doc_QSensor, "\1QSensor(Union[QByteArray, bytes, bytearray], parent: QObject = None)");


/* Define this type's signals. */
static const pyqt5QtSignal signals_QSensor[] = {
    {"bufferSizeChanged(int)", "\1bufferSizeChanged(self, int)", SIP_NULLPTR, SIP_NULLPTR},
    {"efficientBufferSizeChanged(int)", "\1efficientBufferSizeChanged(self, int)", SIP_NULLPTR, SIP_NULLPTR},
    {"maxBufferSizeChanged(int)", "\1maxBufferSizeChanged(self, int)", SIP_NULLPTR, SIP_NULLPTR},
    {"userOrientationChanged(int)", "\1userOrientationChanged(self, int)", SIP_NULLPTR, SIP_NULLPTR},
    {"currentOrientationChanged(int)", "\1currentOrientationChanged(self, int)", SIP_NULLPTR, SIP_NULLPTR},
    {"axesOrientationModeChanged(AxesOrientationMode)|(QSensor::AxesOrientationMode)", "\1axesOrientationModeChanged(self, QSensor.AxesOrientationMode)", SIP_NULLPTR, SIP_NULLPTR},
    {"skipDuplicatesChanged(bool)", "\1skipDuplicatesChanged(self, bool)", SIP_NULLPTR, SIP_NULLPTR},
    {"dataRateChanged()", "\1dataRateChanged(self)", SIP_NULLPTR, SIP_NULLPTR},
    {"alwaysOnChanged()", "\1alwaysOnChanged(self)", SIP_NULLPTR, SIP_NULLPTR},
    {"availableSensorsChanged()", "\1availableSensorsChanged(self)", SIP_NULLPTR, SIP_NULLPTR},
    {"sensorError(int)", "\1sensorError(self, int)", SIP_NULLPTR, SIP_NULLPTR},
    {"readingChanged()", "\1readingChanged(self)", SIP_NULLPTR, SIP_NULLPTR},
    {"activeChanged()", "\1activeChanged(self)", SIP_NULLPTR, SIP_NULLPTR},
    {"busyChanged()", "\1busyChanged(self)", SIP_NULLPTR, SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


static pyqt5ClassPluginDef plugin_QSensor = {
    & ::QSensor::staticMetaObject,
    0,
    signals_QSensor,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSensor,
        {SIP_NULLPTR},
        &plugin_QSensor
    },
    {
        sipNameNr_QSensor,
        {0, 0, 1},
        42, methods_QSensor,
        11, enummembers_QSensor,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSensor,
    -1,
    -1,
    supers_QSensor,
    SIP_NULLPTR,
    init_type_QSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QSensor,
    cast_QSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 46 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaccelerometer.sip"
#include <qaccelerometer.h>
#line 9979 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaccelerometer.sip"
#include <qaccelerometer.h>
#line 9983 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQAccelerometerFilter : public  ::QAccelerometerFilter
{
public:
    sipQAccelerometerFilter();
    sipQAccelerometerFilter(const  ::QAccelerometerFilter&);
    virtual ~sipQAccelerometerFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QAccelerometerReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQAccelerometerFilter(const sipQAccelerometerFilter &);
    sipQAccelerometerFilter &operator = (const sipQAccelerometerFilter &);

    char sipPyMethods[1];
};

sipQAccelerometerFilter::sipQAccelerometerFilter():  ::QAccelerometerFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAccelerometerFilter::sipQAccelerometerFilter(const  ::QAccelerometerFilter& a0):  ::QAccelerometerFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQAccelerometerFilter::~sipQAccelerometerFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQAccelerometerFilter::filter( ::QAccelerometerReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QAccelerometerFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_7(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QAccelerometerReading*);

    return sipVH_QtSensors_7(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QAccelerometerFilter_filter, "filter(self, QAccelerometerReading) -> bool");

extern "C" {static PyObject *meth_QAccelerometerFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QAccelerometerFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QAccelerometerReading* a0;
         ::QAccelerometerFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QAccelerometerFilter, &sipCpp, sipType_QAccelerometerReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QAccelerometerFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAccelerometerFilter, sipName_filter, doc_QAccelerometerFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAccelerometerFilter(void *, const sipTypeDef *);}
static void *cast_QAccelerometerFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAccelerometerFilter *sipCpp = reinterpret_cast< ::QAccelerometerFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAccelerometerFilter(void *, int);}
static void release_QAccelerometerFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQAccelerometerFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QAccelerometerFilter *>(sipCppV);
}


extern "C" {static void dealloc_QAccelerometerFilter(sipSimpleWrapper *);}
static void dealloc_QAccelerometerFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQAccelerometerFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAccelerometerFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QAccelerometerFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QAccelerometerFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQAccelerometerFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQAccelerometerFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QAccelerometerFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QAccelerometerFilter, &a0))
        {
            sipCpp = new sipQAccelerometerFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAccelerometerFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QAccelerometerFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QAccelerometerFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QAccelerometerFilter_filter)}
};

PyDoc_STRVAR(doc_QAccelerometerFilter, "\1QAccelerometerFilter()\n"
"QAccelerometerFilter(QAccelerometerFilter)");


static pyqt5ClassPluginDef plugin_QAccelerometerFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAccelerometerFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAccelerometerFilter,
        {SIP_NULLPTR},
        &plugin_QAccelerometerFilter
    },
    {
        sipNameNr_QAccelerometerFilter,
        {0, 0, 1},
        1, methods_QAccelerometerFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QAccelerometerFilter,
    -1,
    -1,
    supers_QAccelerometerFilter,
    SIP_NULLPTR,
    init_type_QAccelerometerFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAccelerometerFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAccelerometerFilter,
    cast_QAccelerometerFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 10220 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 51 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 10224 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


class sipQSensorFilter : public  ::QSensorFilter
{
public:
    sipQSensorFilter();
    sipQSensorFilter(const  ::QSensorFilter&);
    virtual ~sipQSensorFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QSensorReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQSensorFilter(const sipQSensorFilter &);
    sipQSensorFilter &operator = (const sipQSensorFilter &);

    char sipPyMethods[1];
};

sipQSensorFilter::sipQSensorFilter():  ::QSensorFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQSensorFilter::sipQSensorFilter(const  ::QSensorFilter& a0):  ::QSensorFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQSensorFilter::~sipQSensorFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQSensorFilter::filter( ::QSensorReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QSensorFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QSensorReading*);

    return sipVH_QtSensors_6(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QSensorFilter_filter, "filter(self, QSensorReading) -> bool");

extern "C" {static PyObject *meth_QSensorFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QSensorFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QSensorReading* a0;
         ::QSensorFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QSensorFilter, &sipCpp, sipType_QSensorReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QSensorFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensorFilter, sipName_filter, doc_QSensorFilter_filter);

    return SIP_NULLPTR;
}


/* Call the instance's destructor. */
extern "C" {static void release_QSensorFilter(void *, int);}
static void release_QSensorFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQSensorFilter *>(sipCppV);
}


extern "C" {static void dealloc_QSensorFilter(sipSimpleWrapper *);}
static void dealloc_QSensorFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQSensorFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSensorFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QSensorFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSensorFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQSensorFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQSensorFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QSensorFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QSensorFilter, &a0))
        {
            sipCpp = new sipQSensorFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


static PyMethodDef methods_QSensorFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QSensorFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensorFilter_filter)}
};

PyDoc_STRVAR(doc_QSensorFilter, "\1QSensorFilter()\n"
"QSensorFilter(QSensorFilter)");


static pyqt5ClassPluginDef plugin_QSensorFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QSensorFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSensorFilter,
        {SIP_NULLPTR},
        &plugin_QSensorFilter
    },
    {
        sipNameNr_QSensorFilter,
        {0, 0, 1},
        1, methods_QSensorFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSensorFilter,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    SIP_NULLPTR,
    init_type_QSensorFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSensorFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QSensorFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaccelerometer.sip"
#include <qaccelerometer.h>
#line 10442 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 10446 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 10449 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10452 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10455 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10458 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 10461 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 10464 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 10467 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 10470 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 10473 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 10476 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 10479 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 10482 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 10485 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 10488 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 10491 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


PyDoc_STRVAR(doc_QAccelerometerReading_x, "x(self) -> float");

extern "C" {static PyObject *meth_QAccelerometerReading_x(PyObject *, PyObject *);}
static PyObject *meth_QAccelerometerReading_x(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QAccelerometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QAccelerometerReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->x();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAccelerometerReading, sipName_x, doc_QAccelerometerReading_x);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QAccelerometerReading_setX, "setX(self, float)");

extern "C" {static PyObject *meth_QAccelerometerReading_setX(PyObject *, PyObject *);}
static PyObject *meth_QAccelerometerReading_setX(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QAccelerometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QAccelerometerReading, &sipCpp, &a0))
        {
            sipCpp->setX(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAccelerometerReading, sipName_setX, doc_QAccelerometerReading_setX);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QAccelerometerReading_y, "y(self) -> float");

extern "C" {static PyObject *meth_QAccelerometerReading_y(PyObject *, PyObject *);}
static PyObject *meth_QAccelerometerReading_y(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QAccelerometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QAccelerometerReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->y();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAccelerometerReading, sipName_y, doc_QAccelerometerReading_y);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QAccelerometerReading_setY, "setY(self, float)");

extern "C" {static PyObject *meth_QAccelerometerReading_setY(PyObject *, PyObject *);}
static PyObject *meth_QAccelerometerReading_setY(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QAccelerometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QAccelerometerReading, &sipCpp, &a0))
        {
            sipCpp->setY(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAccelerometerReading, sipName_setY, doc_QAccelerometerReading_setY);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QAccelerometerReading_z, "z(self) -> float");

extern "C" {static PyObject *meth_QAccelerometerReading_z(PyObject *, PyObject *);}
static PyObject *meth_QAccelerometerReading_z(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QAccelerometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QAccelerometerReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->z();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAccelerometerReading, sipName_z, doc_QAccelerometerReading_z);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QAccelerometerReading_setZ, "setZ(self, float)");

extern "C" {static PyObject *meth_QAccelerometerReading_setZ(PyObject *, PyObject *);}
static PyObject *meth_QAccelerometerReading_setZ(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QAccelerometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QAccelerometerReading, &sipCpp, &a0))
        {
            sipCpp->setZ(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QAccelerometerReading, sipName_setZ, doc_QAccelerometerReading_setZ);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QAccelerometerReading(void *, const sipTypeDef *);}
static void *cast_QAccelerometerReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QAccelerometerReading *sipCpp = reinterpret_cast< ::QAccelerometerReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QAccelerometerReading(void *, int);}
static void release_QAccelerometerReading(void *sipCppV, int)
{
     ::QAccelerometerReading *sipCpp = reinterpret_cast< ::QAccelerometerReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QAccelerometerReading(sipSimpleWrapper *);}
static void dealloc_QAccelerometerReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QAccelerometerReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QAccelerometerReading[] = {{60, 255, 1}};


static PyMethodDef methods_QAccelerometerReading[] = {
    {SIP_MLNAME_CAST(sipName_setX), meth_QAccelerometerReading_setX, METH_VARARGS, SIP_MLDOC_CAST(doc_QAccelerometerReading_setX)},
    {SIP_MLNAME_CAST(sipName_setY), meth_QAccelerometerReading_setY, METH_VARARGS, SIP_MLDOC_CAST(doc_QAccelerometerReading_setY)},
    {SIP_MLNAME_CAST(sipName_setZ), meth_QAccelerometerReading_setZ, METH_VARARGS, SIP_MLDOC_CAST(doc_QAccelerometerReading_setZ)},
    {SIP_MLNAME_CAST(sipName_x), meth_QAccelerometerReading_x, METH_VARARGS, SIP_MLDOC_CAST(doc_QAccelerometerReading_x)},
    {SIP_MLNAME_CAST(sipName_y), meth_QAccelerometerReading_y, METH_VARARGS, SIP_MLDOC_CAST(doc_QAccelerometerReading_y)},
    {SIP_MLNAME_CAST(sipName_z), meth_QAccelerometerReading_z, METH_VARARGS, SIP_MLDOC_CAST(doc_QAccelerometerReading_z)}
};


static pyqt5ClassPluginDef plugin_QAccelerometerReading = {
    & ::QAccelerometerReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QAccelerometerReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QAccelerometerReading,
        {SIP_NULLPTR},
        &plugin_QAccelerometerReading
    },
    {
        sipNameNr_QAccelerometerReading,
        {0, 0, 1},
        6, methods_QAccelerometerReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QAccelerometerReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QAccelerometerReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QAccelerometerReading,
    cast_QAccelerometerReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 51 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 10774 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 10778 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 10781 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10784 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10787 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10790 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 10793 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 10796 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 10799 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 10802 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 10805 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 10808 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 10811 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 10814 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 10817 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 10820 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 10823 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart1.cpp"


PyDoc_STRVAR(doc_QSensorReading_timestamp, "timestamp(self) -> int");

extern "C" {static PyObject *meth_QSensorReading_timestamp(PyObject *, PyObject *);}
static PyObject *meth_QSensorReading_timestamp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensorReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensorReading, &sipCpp))
        {
             ::quint64 sipRes;

            sipRes = sipCpp->timestamp();

            return PyLong_FromUnsignedLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensorReading, sipName_timestamp, doc_QSensorReading_timestamp);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensorReading_setTimestamp, "setTimestamp(self, int)");

extern "C" {static PyObject *meth_QSensorReading_setTimestamp(PyObject *, PyObject *);}
static PyObject *meth_QSensorReading_setTimestamp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::quint64 a0;
         ::QSensorReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bo", &sipSelf, sipType_QSensorReading, &sipCpp, &a0))
        {
            sipCpp->setTimestamp(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensorReading, sipName_setTimestamp, doc_QSensorReading_setTimestamp);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensorReading_valueCount, "valueCount(self) -> int");

extern "C" {static PyObject *meth_QSensorReading_valueCount(PyObject *, PyObject *);}
static PyObject *meth_QSensorReading_valueCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSensorReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSensorReading, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->valueCount();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensorReading, sipName_valueCount, doc_QSensorReading_valueCount);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSensorReading_value, "value(self, int) -> Any");

extern "C" {static PyObject *meth_QSensorReading_value(PyObject *, PyObject *);}
static PyObject *meth_QSensorReading_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;
        const  ::QSensorReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QSensorReading, &sipCpp, &a0))
        {
             ::QVariant*sipRes;

            sipRes = new  ::QVariant(sipCpp->value(a0));

            return sipConvertFromNewType(sipRes,sipType_QVariant,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSensorReading, sipName_value, doc_QSensorReading_value);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QSensorReading(void *, const sipTypeDef *);}
static void *cast_QSensorReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QSensorReading *sipCpp = reinterpret_cast< ::QSensorReading *>(sipCppV);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QSensorReading(void *, int);}
static void release_QSensorReading(void *sipCppV, int)
{
     ::QSensorReading *sipCpp = reinterpret_cast< ::QSensorReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QSensorReading(sipSimpleWrapper *);}
static void dealloc_QSensorReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSensorReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QSensorReading[] = {{6, 0, 1}};


static PyMethodDef methods_QSensorReading[] = {
    {SIP_MLNAME_CAST(sipName_setTimestamp), meth_QSensorReading_setTimestamp, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensorReading_setTimestamp)},
    {SIP_MLNAME_CAST(sipName_timestamp), meth_QSensorReading_timestamp, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensorReading_timestamp)},
    {SIP_MLNAME_CAST(sipName_value), meth_QSensorReading_value, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensorReading_value)},
    {SIP_MLNAME_CAST(sipName_valueCount), meth_QSensorReading_valueCount, METH_VARARGS, SIP_MLDOC_CAST(doc_QSensorReading_valueCount)}
};


static pyqt5ClassPluginDef plugin_QSensorReading = {
    & ::QSensorReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QSensorReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSensorReading,
        {SIP_NULLPTR},
        &plugin_QSensorReading
    },
    {
        sipNameNr_QSensorReading,
        {0, 0, 1},
        4, methods_QSensorReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QSensorReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSensorReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QSensorReading,
    cast_QSensorReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};
