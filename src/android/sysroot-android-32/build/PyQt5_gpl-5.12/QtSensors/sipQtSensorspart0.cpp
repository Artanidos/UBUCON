/*
 * Module code.
 *
 * Generated by SIP 4.19.15
 *
 * Copyright (c) 2019 Riverbank Computing Limited <info@riverbankcomputing.com>
 * 
 * This file is part of PyQt5.
 * 
 * This file may be used under the terms of the GNU General Public License
 * version 3.0 as published by the Free Software Foundation and appearing in
 * the file LICENSE included in the packaging of this file.  Please review the
 * following information to ensure the GNU General Public License version 3.0
 * requirements will be met: http://www.gnu.org/copyleft/gpl.html.
 * 
 * If you do not wish to use this file under the terms of the GPL version 3.0
 * then you may purchase a commercial license.  For more information contact
 * info@riverbankcomputing.com.
 * 
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "sipAPIQtSensors.h"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 32 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 35 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 38 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 41 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 51 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 44 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaccelerometer.sip"
#include <qaccelerometer.h>
#line 47 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qaltimeter.sip"
#include <qaltimeter.h>
#line 50 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambientlightsensor.sip"
#include <qambientlightsensor.h>
#line 53 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qambienttemperaturesensor.sip"
#include <qambienttemperaturesensor.h>
#line 56 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qcompass.sip"
#include <qcompass.h>
#line 59 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qdistancesensor.sip"
#include <qdistancesensor.h>
#line 62 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qgyroscope.sip"
#include <qgyroscope.h>
#line 65 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qholstersensor.sip"
#include <qholstersensor.h>
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qhumiditysensor.sip"
#include <qhumiditysensor.h>
#line 71 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qirproximitysensor.sip"
#include <qirproximitysensor.h>
#line 74 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlidsensor.sip"
#include <qlidsensor.h>
#line 77 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlightsensor.sip"
#include <qlightsensor.h>
#line 80 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qmagnetometer.sip"
#include <qmagnetometer.h>
#line 83 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qorientationsensor.sip"
#include <qorientationsensor.h>
#line 86 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qpressuresensor.sip"
#include <qpressuresensor.h>
#line 89 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qproximitysensor.sip"
#include <qproximitysensor.h>
#line 92 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtapsensor.sip"
#include <qtapsensor.h>
#line 95 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtiltsensor.sip"
#include <qtiltsensor.h>
#line 98 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qrotationsensor.sip"
#include <qrotationsensor.h>
#line 101 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 104 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

/* Define the strings used by this module. */
const char sipStrings_QtSensors[] = {
    'Q', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 'R', 'e', 'a', 'd', 'i', 'n', 'g', ':', ':', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'A', 'm', 'b', 'i', 'e', 'n', 't', 'L', 'i', 'g', 'h', 't', 'R', 'e', 'a', 'd', 'i', 'n', 'g', ':', ':', 'L', 'i', 'g', 'h', 't', 'L', 'e', 'v', 'e', 'l', 0,
    'Q', 'A', 'c', 'c', 'e', 'l', 'e', 'r', 'o', 'm', 'e', 't', 'e', 'r', ':', ':', 'A', 'c', 'c', 'e', 'l', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'M', 'o', 'd', 'e', 0,
    'r', 'e', 't', 'u', 'r', 'n', 'D', 'o', 'u', 'b', 'l', 'e', 'T', 'a', 'p', 'E', 'v', 'e', 'n', 't', 's', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'Q', 'S', 'e', 'n', 's', 'o', 'r', ':', ':', 'A', 'x', 'e', 's', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 'M', 'o', 'd', 'e', 0,
    'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', 'B', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'a', 'x', 'e', 's', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 'M', 'o', 'd', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'Q', 'A', 'm', 'b', 'i', 'e', 'n', 't', 'T', 'e', 'm', 'p', 'e', 'r', 'a', 't', 'u', 'r', 'e', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'Q', 'T', 'a', 'p', 'R', 'e', 'a', 'd', 'i', 'n', 'g', ':', ':', 'T', 'a', 'p', 'D', 'i', 'r', 'e', 'c', 't', 'i', 'o', 'n', 0,
    'c', 'u', 'r', 'r', 'e', 'n', 't', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'P', 'r', 'e', 's', 's', 'u', 'r', 'e', 'S', 'e', 'n', 's', 'o', 'r', 'T', 'e', 'm', 'p', 'e', 'r', 'a', 't', 'u', 'r', 'e', 0,
    'Q', 'A', 'm', 'b', 'i', 'e', 'n', 't', 'T', 'e', 'm', 'p', 'e', 'r', 'a', 't', 'u', 'r', 'e', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'A', 'm', 'b', 'i', 'e', 'n', 't', 'T', 'e', 'm', 'p', 'e', 'r', 'a', 't', 'u', 'r', 'e', 'F', 'i', 'l', 't', 'e', 'r', 0,
    's', 'e', 't', 'R', 'e', 't', 'u', 'r', 'n', 'D', 'o', 'u', 'b', 'l', 'e', 'T', 'a', 'p', 'E', 'v', 'e', 'n', 't', 's', 0,
    'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 'S', 'e', 'n', 's', 'o', 'r', 's', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'a', 'c', 'c', 'e', 'l', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'M', 'o', 'd', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'u', 's', 'e', 'r', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    's', 'e', 't', 'E', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', 'B', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 0,
    's', 'e', 't', 'A', 'x', 'e', 's', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 'M', 'o', 'd', 'e', 0,
    'r', 'e', 't', 'u', 'r', 'n', 'G', 'e', 'o', 'V', 'a', 'l', 'u', 'e', 's', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'S', 'e', 'n', 's', 'o', 'r', 'F', 'i', 'l', 't', 'e', 'r', '*', '>', 0,
    'r', 'e', 't', 'u', 'r', 'n', 'D', 'o', 'u', 'b', 'l', 'e', 'T', 'a', 'p', 'E', 'v', 'e', 'n', 't', 's', 0,
    's', 'k', 'i', 'p', 'D', 'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', 's', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    's', 'e', 't', 'C', 'u', 'r', 'r', 'e', 'n', 't', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'A', 'c', 'c', 'e', 'l', 'e', 'r', 'o', 'm', 'e', 't', 'e', 'r', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'm', 'a', 'x', 'B', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'd', 'e', 'f', 'a', 'u', 'l', 't', 'S', 'e', 'n', 's', 'o', 'r', 'F', 'o', 'r', 'T', 'y', 'p', 'e', 0,
    'i', 's', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd', 'T', 'o', 'B', 'a', 'c', 'k', 'e', 'n', 'd', 0,
    'A', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'M', 'a', 'g', 'n', 'e', 't', 'o', 'm', 'e', 't', 'e', 'r', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'Q', 'A', 'm', 'b', 'i', 'e', 'n', 't', 'L', 'i', 'g', 'h', 't', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'Q', 'A', 'c', 'c', 'e', 'l', 'e', 'r', 'o', 'm', 'e', 't', 'e', 'r', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'Q', 'L', 'i', 's', 't', '<', 'q', 'o', 'u', 't', 'p', 'u', 't', 'r', 'a', 'n', 'g', 'e', '>', 0,
    'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', 'B', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 0,
    'a', 'x', 'e', 's', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 'M', 'o', 'd', 'e', 0,
    'Q', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'Q', 'M', 'a', 'g', 'n', 'e', 't', 'o', 'm', 'e', 't', 'e', 'r', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'Q', 'I', 'R', 'P', 'r', 'o', 'x', 'i', 'm', 'i', 't', 'y', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    's', 'e', 't', 'A', 'b', 's', 'o', 'l', 'u', 't', 'e', 'H', 'u', 'm', 'i', 'd', 'i', 't', 'y', 0,
    's', 'e', 't', 'R', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'H', 'u', 'm', 'i', 'd', 'i', 't', 'y', 0,
    's', 'e', 't', 'C', 'a', 'l', 'i', 'b', 'r', 'a', 't', 'i', 'o', 'n', 'L', 'e', 'v', 'e', 'l', 0,
    'Q', 'A', 'm', 'b', 'i', 'e', 'n', 't', 'L', 'i', 'g', 'h', 't', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'A', 'm', 'b', 'i', 'e', 'n', 't', 'L', 'i', 'g', 'h', 't', 'F', 'i', 'l', 't', 'e', 'r', 0,
    's', 'e', 't', 'A', 'c', 'c', 'e', 'l', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'M', 'o', 'd', 'e', 0,
    's', 'e', 't', 'U', 's', 'e', 'r', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'c', 'u', 'r', 'r', 'e', 'n', 't', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'i', 's', 'F', 'e', 'a', 't', 'u', 'r', 'e', 'S', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 0,
    'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 'D', 'a', 't', 'a', 'R', 'a', 't', 'e', 's', 0,
    'Q', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 'F', 'i', 'l', 't', 'e', 'r', 0,
    's', 'e', 't', 'R', 'e', 't', 'u', 'r', 'n', 'G', 'e', 'o', 'V', 'a', 'l', 'u', 'e', 's', 0,
    'f', 'i', 'e', 'l', 'd', 'O', 'f', 'V', 'i', 'e', 'w', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'Q', 'I', 'R', 'P', 'r', 'o', 'x', 'i', 'm', 'i', 't', 'y', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'I', 'R', 'P', 'r', 'o', 'x', 'i', 'm', 'i', 't', 'y', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'b', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    's', 'e', 't', 'S', 'k', 'i', 'p', 'D', 'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', 's', 0,
    'Q', 'P', 'r', 'o', 'x', 'i', 'm', 'i', 't', 'y', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    's', 'e', 't', 'F', 'r', 'o', 'n', 't', 'L', 'i', 'd', 'C', 'l', 'o', 's', 'e', 'd', 0,
    'Q', 'G', 'y', 'r', 'o', 's', 'c', 'o', 'p', 'e', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'Q', 'A', 'l', 't', 'i', 'm', 'e', 't', 'e', 'r', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    's', 'i', 'p', '.', 's', 'i', 'm', 'p', 'l', 'e', 'w', 'r', 'a', 'p', 'p', 'e', 'r', 0,
    'Q', 'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    's', 'e', 't', 'M', 'a', 'x', 'B', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 0,
    'c', 'o', 'n', 'n', 'e', 'c', 't', 'T', 'o', 'B', 'a', 'c', 'k', 'e', 'n', 'd', 0,
    'F', 'i', 'x', 'e', 'd', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'S', 'e', 'n', 's', 'o', 'r', ':', ':', 'F', 'e', 'a', 't', 'u', 'r', 'e', 0,
    'Q', 'P', 'r', 'o', 'x', 'i', 'm', 'i', 't', 'y', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'P', 'r', 'o', 'x', 'i', 'm', 'i', 't', 'y', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'Q', 'P', 'r', 'e', 's', 's', 'u', 'r', 'e', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    's', 'e', 't', 'B', 'a', 'c', 'k', 'L', 'i', 'd', 'C', 'l', 'o', 's', 'e', 'd', 0,
    'a', 'b', 's', 'o', 'l', 'u', 't', 'e', 'H', 'u', 'm', 'i', 'd', 'i', 't', 'y', 0,
    'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'H', 'u', 'm', 'i', 'd', 'i', 't', 'y', 0,
    'Q', 'H', 'u', 'm', 'i', 'd', 'i', 't', 'y', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'Q', 'G', 'y', 'r', 'o', 's', 'c', 'o', 'p', 'e', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'Q', 'D', 'i', 's', 't', 'a', 'n', 'c', 'e', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'c', 'a', 'l', 'i', 'b', 'r', 'a', 't', 'i', 'o', 'n', 'L', 'e', 'v', 'e', 'l', 0,
    'Q', 'A', 'l', 't', 'i', 'm', 'e', 't', 'e', 'r', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'a', 'c', 'c', 'e', 'l', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'M', 'o', 'd', 'e', 0,
    'd', 'i', 's', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'N', 'o', 't', 'i', 'f', 'y', 0,
    'Q', 'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 'F', 'i', 'l', 't', 'e', 'r', 0,
    's', 'e', 't', 'T', 'a', 'p', 'D', 'i', 'r', 'e', 'c', 't', 'i', 'o', 'n', 0,
    'd', 'a', 't', 'a', 'R', 'a', 't', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'a', 'l', 'w', 'a', 'y', 's', 'O', 'n', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'u', 's', 'e', 'r', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'A', 'x', 'e', 's', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'P', 'r', 'e', 's', 's', 'u', 'r', 'e', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'P', 'r', 'e', 's', 's', 'u', 'r', 'e', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'r', 'e', 't', 'u', 'r', 'n', 'G', 'e', 'o', 'V', 'a', 'l', 'u', 'e', 's', 0,
    'f', 'r', 'o', 'n', 't', 'L', 'i', 'd', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'Q', 'H', 'u', 'm', 'i', 'd', 'i', 't', 'y', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'H', 'u', 'm', 'i', 'd', 'i', 't', 'y', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'Q', 'H', 'o', 'l', 's', 't', 'e', 'r', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'Q', 'D', 'i', 's', 't', 'a', 'n', 'c', 'e', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'D', 'i', 's', 't', 'a', 'n', 'c', 'e', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'Q', 'C', 'o', 'm', 'p', 'a', 's', 's', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'P', 'y', 'Q', 't', '5', '.', 'Q', 't', 'S', 'e', 'n', 's', 'o', 'r', 's', 0,
    'r', 'e', 'a', 'd', 'i', 'n', 'g', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    's', 'e', 'n', 's', 'o', 'r', 's', 'F', 'o', 'r', 'T', 'y', 'p', 'e', 0,
    's', 'e', 't', 'O', 'u', 't', 'p', 'u', 't', 'R', 'a', 'n', 'g', 'e', 0,
    's', 'k', 'i', 'p', 'D', 'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', 's', 0,
    's', 'e', 't', 'O', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    's', 'e', 't', 'F', 'i', 'e', 'l', 'd', 'O', 'f', 'V', 'i', 'e', 'w', 0,
    'b', 'a', 'c', 'k', 'L', 'i', 'd', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'f', 'r', 'o', 'n', 't', 'L', 'i', 'd', 'C', 'l', 'o', 's', 'e', 'd', 0,
    's', 'e', 't', 'R', 'e', 'f', 'l', 'e', 'c', 't', 'a', 'n', 'c', 'e', 0,
    'Q', 'H', 'o', 'l', 's', 't', 'e', 'r', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'H', 'o', 'l', 's', 't', 'e', 'r', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'Q', 'C', 'o', 'm', 'p', 'a', 's', 's', 'F', 'i', 'l', 't', 'e', 'r', 0,
    's', 'e', 't', 'T', 'e', 'm', 'p', 'e', 'r', 'a', 't', 'u', 'r', 'e', 0,
    'Q', 'A', 'c', 'c', 'e', 'l', 'e', 'r', 'o', 'm', 'e', 't', 'e', 'r', 0,
    'Q', 'S', 'e', 'n', 's', 'o', 'r', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    's', 'e', 't', 'B', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 0,
    'm', 'a', 'x', 'B', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 0,
    's', 'e', 't', 'I', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', 0,
    'Q', 'M', 'a', 'g', 'n', 'e', 't', 'o', 'm', 'e', 't', 'e', 'r', 0,
    'Q', 'L', 'i', 'g', 'h', 't', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'b', 'a', 'c', 'k', 'L', 'i', 'd', 'C', 'l', 'o', 's', 'e', 'd', 0,
    's', 'e', 't', 'L', 'i', 'g', 'h', 't', 'L', 'e', 'v', 'e', 'l', 0,
    'Q', 'S', 'e', 'n', 's', 'o', 'r', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'a', 'c', 't', 'i', 'v', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    's', 'e', 't', 'F', 'r', 'o', 'm', 'E', 'u', 'l', 'e', 'r', 0,
    's', 'e', 't', 'X', 'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 0,
    's', 'e', 't', 'Y', 'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'T', 'i', 'l', 't', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    's', 'e', 't', 'D', 'o', 'u', 'b', 'l', 'e', 'T', 'a', 'p', 0,
    't', 'a', 'p', 'D', 'i', 'r', 'e', 'c', 't', 'i', 'o', 'n', 0,
    'r', 'e', 'm', 'o', 'v', 'e', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'o', 'u', 't', 'p', 'u', 't', 'R', 'a', 'n', 'g', 'e', 's', 0,
    's', 'e', 't', 'T', 'i', 'm', 'e', 's', 't', 'a', 'm', 'p', 0,
    'q', 'o', 'u', 't', 'p', 'u', 't', 'r', 'a', 'n', 'g', 'e', 0,
    'Q', 'L', 'i', 'g', 'h', 't', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'L', 'i', 'g', 'h', 't', 'F', 'i', 'l', 't', 'e', 'r', 0,
    's', 'e', 't', 'H', 'o', 'l', 's', 't', 'e', 'r', 'e', 'd', 0,
    'h', 'a', 's', 'Z', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'Q', 'T', 'i', 'l', 't', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'T', 'i', 'l', 't', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'i', 's', 'D', 'o', 'u', 'b', 'l', 'e', 'T', 'a', 'p', 0,
    'Q', 'T', 'a', 'p', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    's', 'e', 'n', 's', 'o', 'r', 'E', 'r', 'r', 'o', 'r', 0,
    'b', 'u', 's', 'y', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    's', 'e', 'n', 's', 'o', 'r', 'T', 'y', 'p', 'e', 's', 0,
    'o', 'u', 't', 'p', 'u', 't', 'R', 'a', 'n', 'g', 'e', 0,
    's', 'e', 't', 'D', 'a', 't', 'a', 'R', 'a', 't', 'e', 0,
    's', 'e', 't', 'A', 'l', 'w', 'a', 'y', 's', 'O', 'n', 0,
    's', 'e', 't', 'P', 'r', 'e', 's', 's', 'u', 'r', 'e', 0,
    'f', 'i', 'e', 'l', 'd', 'O', 'f', 'V', 'i', 'e', 'w', 0,
    'Q', 'L', 'i', 'd', 'R', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'r', 'e', 'f', 'l', 'e', 'c', 't', 'a', 'n', 'c', 'e', 0,
    's', 'e', 't', 'D', 'i', 's', 't', 'a', 'n', 'c', 'e', 0,
    't', 'e', 'm', 'p', 'e', 'r', 'a', 't', 'u', 'r', 'e', 0,
    's', 'e', 't', 'A', 'l', 't', 'i', 't', 'u', 'd', 'e', 0,
    'c', 'u', 's', 't', 'o', 'm', 'E', 'v', 'e', 'n', 't', 0,
    'e', 'v', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'd', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n', 0,
    'o', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'T', 'a', 'p', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'T', 'a', 'p', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'b', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 0,
    'i', 's', 'A', 'l', 'w', 'a', 'y', 's', 'O', 'n', 0,
    'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', 0,
    'v', 'a', 'l', 'u', 'e', 'C', 'o', 'u', 'n', 't', 0,
    'Q', 'L', 'i', 'd', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'Q', 'L', 'i', 'd', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'Q', 'G', 'y', 'r', 'o', 's', 'c', 'o', 'p', 'e', 0,
    's', 'e', 't', 'A', 'z', 'i', 'm', 'u', 't', 'h', 0,
    'l', 'i', 'g', 'h', 't', 'L', 'e', 'v', 'e', 'l', 0,
    'Q', 'A', 'l', 't', 'i', 'm', 'e', 't', 'e', 'r', 0,
    'c', 'h', 'i', 'l', 'd', 'E', 'v', 'e', 'n', 't', 0,
    't', 'i', 'm', 'e', 'r', 'E', 'v', 'e', 'n', 't', 0,
    'c', 'a', 'l', 'i', 'b', 'r', 'a', 't', 'e', 0,
    'x', 'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 0,
    'y', 'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 0,
    'a', 'd', 'd', 'F', 'i', 'l', 't', 'e', 'r', 0,
    's', 'e', 't', 'A', 'c', 't', 'i', 'v', 'e', 0,
    'B', 'u', 'f', 'f', 'e', 'r', 'i', 'n', 'g', 0,
    't', 'i', 'm', 'e', 's', 't', 'a', 'm', 'p', 0,
    'h', 'o', 'l', 's', 't', 'e', 'r', 'e', 'd', 0,
    'U', 'n', 'd', 'e', 'f', 'i', 'n', 'e', 'd', 0,
    'd', 'a', 't', 'a', 'R', 'a', 't', 'e', 0,
    'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', 0,
    's', 'e', 't', 'C', 'l', 'o', 's', 'e', 0,
    'p', 'r', 'e', 's', 's', 'u', 'r', 'e', 0,
    'F', 'a', 'c', 'e', 'D', 'o', 'w', 'n', 0,
    'd', 'i', 's', 't', 'a', 'n', 'c', 'e', 0,
    'Q', 'C', 'o', 'm', 'p', 'a', 's', 's', 0,
    'T', 'w', 'i', 'l', 'i', 'g', 'h', 't', 0,
    'a', 'l', 't', 'i', 't', 'u', 'd', 'e', 0,
    'C', 'o', 'm', 'b', 'i', 'n', 'e', 'd', 0,
    'i', 's', 'A', 'c', 't', 'i', 'v', 'e', 0,
    's', 'e', 't', 'H', 'a', 's', 'Z', 0,
    'm', 'a', 'x', 'i', 'm', 'u', 'm', 0,
    'm', 'i', 'n', 'i', 'm', 'u', 'm', 0,
    'R', 'i', 'g', 'h', 't', 'U', 'p', 0,
    'T', 'o', 'p', 'D', 'o', 'w', 'n', 0,
    'a', 'z', 'i', 'm', 'u', 't', 'h', 0,
    'G', 'r', 'a', 'v', 'i', 't', 'y', 0,
    'Q', 'S', 'e', 'n', 's', 'o', 'r', 0,
    'r', 'e', 'a', 'd', 'i', 'n', 'g', 0,
    'f', 'i', 'l', 't', 'e', 'r', 's', 0,
    'Z', '_', 'B', 'o', 't', 'h', 0,
    'Y', '_', 'B', 'o', 't', 'h', 0,
    'X', '_', 'B', 'o', 't', 'h', 0,
    'i', 's', 'B', 'u', 's', 'y', 0,
    'F', 'a', 'c', 'e', 'U', 'p', 0,
    'L', 'e', 'f', 't', 'U', 'p', 0,
    's', 'e', 't', 'L', 'u', 'x', 0,
    'B', 'r', 'i', 'g', 'h', 't', 0,
    'f', 'i', 'l', 't', 'e', 'r', 0,
    'p', 'a', 'r', 'e', 'n', 't', 0,
    'Z', '_', 'N', 'e', 'g', 0,
    'Y', '_', 'N', 'e', 'g', 0,
    'X', '_', 'N', 'e', 'g', 0,
    'Z', '_', 'P', 'o', 's', 0,
    'Y', '_', 'P', 'o', 's', 0,
    'X', '_', 'P', 'o', 's', 0,
    'T', 'o', 'p', 'U', 'p', 0,
    'S', 'u', 'n', 'n', 'y', 0,
    'L', 'i', 'g', 'h', 't', 0,
    'e', 'r', 'r', 'o', 'r', 0,
    'c', 'l', 'o', 's', 'e', 0,
    'v', 'a', 'l', 'u', 'e', 0,
    'e', 'v', 'e', 'n', 't', 0,
    's', 't', 'a', 'r', 't', 0,
    'h', 'a', 's', 'Z', 0,
    'D', 'a', 'r', 'k', 0,
    's', 'e', 't', 'Z', 0,
    's', 'e', 't', 'Y', 0,
    's', 'e', 't', 'X', 0,
    'U', 's', 'e', 'r', 0,
    't', 'y', 'p', 'e', 0,
    's', 't', 'o', 'p', 0,
    'l', 'u', 'x', 0,
    'z', 0,
};

bool sipVH_QtSensors_25(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QRotationReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QRotationReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_24(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QTiltReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QTiltReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_23(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QTapReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QTapReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_22(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QProximityReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QProximityReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_21(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QPressureReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QPressureReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_20(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QOrientationReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QOrientationReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_19(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QMagnetometerReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QMagnetometerReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_18(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QLightReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QLightReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_17(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QLidReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QLidReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_16(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QIRProximityReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QIRProximityReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_15(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QHumidityReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QHumidityReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_14(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QHolsterReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QHolsterReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_13(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QGyroscopeReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QGyroscopeReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_12(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QDistanceReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QDistanceReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_11(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QCompassReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QCompassReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_10(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QAmbientTemperatureReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QAmbientTemperatureReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_9(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QAmbientLightReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QAmbientLightReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_8(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QAltimeterReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QAltimeterReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_7(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QAccelerometerReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QAccelerometerReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_6(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QSensorReading*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QSensorReading, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_5(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QEvent*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QEvent, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtSensors_4(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QObject*a0, ::QEvent*a1)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "DD", a0, sipType_QObject, SIP_NULLPTR, a1, sipType_QEvent, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

void sipVH_QtSensors_3(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QTimerEvent*a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "D", a0, sipType_QTimerEvent, SIP_NULLPTR);
}

void sipVH_QtSensors_2(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QChildEvent*a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "D", a0, sipType_QChildEvent, SIP_NULLPTR);
}

void sipVH_QtSensors_1(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QEvent*a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "D", a0, sipType_QEvent, SIP_NULLPTR);
}

void sipVH_QtSensors_0(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QMetaMethod& a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "N", new  ::QMetaMethod(a0), sipType_QMetaMethod, SIP_NULLPTR);
}


/* Convert to a sub-class if possible. */
extern "C" {static const sipTypeDef *sipSubClass_QSensor(void **);}
static const sipTypeDef *sipSubClass_QSensor(void **sipCppRet)
{
     ::QObject *sipCpp = reinterpret_cast< ::QObject *>(*sipCppRet);
    const sipTypeDef *sipType;

#line 89 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
    static struct class_graph {
        const char *name;
        sipTypeDef **type;
        int yes, no;
    } graph[] = {
        {sipName_QSensor, &sipType_QSensor, 2, 1},
        {sipName_QSensorReading, &sipType_QSensorReading, 21, -1},
        {sipName_QAccelerometer, &sipType_QAccelerometer, -1, 3},
        {sipName_QAltimeter, &sipType_QAltimeter, -1, 4},
        {sipName_QAmbientLightSensor, &sipType_QAmbientLightSensor, -1, 5},
        {sipName_QAmbientTemperatureSensor, &sipType_QAmbientTemperatureSensor, -1, 6},
        {sipName_QCompass, &sipType_QCompass, -1, 7},
    #if QT_VERSION >= 0x050400
        {sipName_QDistanceSensor, &sipType_QDistanceSensor, -1, 8},
    #else
        {0, 0, -1, 8},
    #endif
        {sipName_QGyroscope, &sipType_QGyroscope, -1, 9},
        {sipName_QHolsterSensor, &sipType_QHolsterSensor, -1, 10},
    #if QT_VERSION >= 0x050900
        {sipName_QHumiditySensor, &sipType_QHumiditySensor, -1, 11},
    #else
        {0, 0, -1, 11},
    #endif
        {sipName_QIRProximitySensor, &sipType_QIRProximitySensor, -1, 12},
    #if QT_VERSION >= 0x050900
        {sipName_QLidSensor, &sipType_QLidSensor, -1, 13},
    #else
        {0, 0, -1, 13},
    #endif
        {sipName_QLightSensor, &sipType_QLightSensor, -1, 14},
        {sipName_QMagnetometer, &sipType_QMagnetometer, -1, 15},
        {sipName_QOrientationSensor, &sipType_QOrientationSensor, -1, 16},
        {sipName_QPressureSensor, &sipType_QPressureSensor, -1, 17},
        {sipName_QProximitySensor, &sipType_QProximitySensor, -1, 18},
        {sipName_QRotationSensor, &sipType_QRotationSensor, -1, 19},
        {sipName_QTapSensor, &sipType_QTapSensor, -1, 20},
        {sipName_QTiltSensor, &sipType_QTiltSensor, -1, -1},
        {sipName_QAccelerometerReading, &sipType_QAccelerometerReading, -1, 22},
        {sipName_QAltimeterReading, &sipType_QAltimeterReading, -1, 23},
        {sipName_QAmbientLightReading, &sipType_QAmbientLightReading, -1, 24},
        {sipName_QAmbientTemperatureReading, &sipType_QAmbientTemperatureReading, -1, 25},
        {sipName_QCompassReading, &sipType_QCompassReading, -1, 26},
    #if QT_VERSION >= 0x050400
        {sipName_QDistanceReading, &sipType_QDistanceReading, -1, 27},
    #else
        {0, 0, -1, 27},
    #endif
        {sipName_QGyroscopeReading, &sipType_QGyroscopeReading, -1, 28},
        {sipName_QHolsterReading, &sipType_QHolsterReading, -1, 29},
    #if QT_VERSION >= 0x050900
        {sipName_QHumidityReading, &sipType_QHumidityReading, -1, 30},
    #else
        {0, 0, -1, 30},
    #endif
        {sipName_QIRProximityReading, &sipType_QIRProximityReading, -1, 31},
    #if QT_VERSION >= 0x050900
        {sipName_QLidReading, &sipType_QLidReading, -1, 32},
    #else
        {0, 0, -1, 32},
    #endif
        {sipName_QLightReading, &sipType_QLightReading, -1, 33},
        {sipName_QMagnetometerReading, &sipType_QMagnetometerReading, -1, 34},
        {sipName_QOrientationReading, &sipType_QOrientationReading, -1, 35},
        {sipName_QPressureReading, &sipType_QPressureReading, -1, 36},
        {sipName_QProximityReading, &sipType_QProximityReading, -1, 37},
        {sipName_QRotationReading, &sipType_QRotationReading, -1, 38},
        {sipName_QTapReading, &sipType_QTapReading, -1, 39},
        {sipName_QTiltReading, &sipType_QTiltReading, -1, -1},
    };
    
    int i = 0;
    
    sipType = NULL;
    
    do
    {
        struct class_graph *cg = &graph[i];
    
        if (cg->name != NULL && sipCpp->inherits(cg->name))
        {
            sipType = *cg->type;
            i = cg->yes;
        }
        else
            i = cg->no;
    }
    while (i >= 0);
#line 681 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

    return sipType;
}
static sipEnumTypeDef enumTypes[] = {
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QTapReading__TapDirection, {0}, 0}, sipNameNr_TapDirection, 62, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSensor__AxesOrientationMode, {0}, 0}, sipNameNr_AxesOrientationMode, 56, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSensor__Feature, {0}, 0}, sipNameNr_Feature, 56, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QOrientationReading__Orientation, {0}, 0}, sipNameNr_Orientation, 44, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QAmbientLightReading__LightLevel, {0}, 0}, sipNameNr_LightLevel, 8, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QAccelerometer__AccelerationMode, {0}, 0}, sipNameNr_AccelerationMode, 0, SIP_NULLPTR},
};


/*
 * This defines each type in this module.
 */
sipTypeDef *sipExportedTypes_QtSensors[] = {
    &sipTypeDef_QtSensors_QAccelerometer.ctd_base,
    &enumTypes[5].etd_base,
    &sipTypeDef_QtSensors_QAccelerometerFilter.ctd_base,
    &sipTypeDef_QtSensors_QAccelerometerReading.ctd_base,
    &sipTypeDef_QtSensors_QAltimeter.ctd_base,
    &sipTypeDef_QtSensors_QAltimeterFilter.ctd_base,
    &sipTypeDef_QtSensors_QAltimeterReading.ctd_base,
    &sipTypeDef_QtSensors_QAmbientLightFilter.ctd_base,
    &sipTypeDef_QtSensors_QAmbientLightReading.ctd_base,
    &enumTypes[4].etd_base,
    &sipTypeDef_QtSensors_QAmbientLightSensor.ctd_base,
    &sipTypeDef_QtSensors_QAmbientTemperatureFilter.ctd_base,
    &sipTypeDef_QtSensors_QAmbientTemperatureReading.ctd_base,
    &sipTypeDef_QtSensors_QAmbientTemperatureSensor.ctd_base,
    &sipTypeDef_QtSensors_QCompass.ctd_base,
    &sipTypeDef_QtSensors_QCompassFilter.ctd_base,
    &sipTypeDef_QtSensors_QCompassReading.ctd_base,
    &sipTypeDef_QtSensors_QDistanceFilter.ctd_base,
    &sipTypeDef_QtSensors_QDistanceReading.ctd_base,
    &sipTypeDef_QtSensors_QDistanceSensor.ctd_base,
    &sipTypeDef_QtSensors_QGyroscope.ctd_base,
    &sipTypeDef_QtSensors_QGyroscopeFilter.ctd_base,
    &sipTypeDef_QtSensors_QGyroscopeReading.ctd_base,
    &sipTypeDef_QtSensors_QHolsterFilter.ctd_base,
    &sipTypeDef_QtSensors_QHolsterReading.ctd_base,
    &sipTypeDef_QtSensors_QHolsterSensor.ctd_base,
    &sipTypeDef_QtSensors_QHumidityFilter.ctd_base,
    &sipTypeDef_QtSensors_QHumidityReading.ctd_base,
    &sipTypeDef_QtSensors_QHumiditySensor.ctd_base,
    &sipTypeDef_QtSensors_QIRProximityFilter.ctd_base,
    &sipTypeDef_QtSensors_QIRProximityReading.ctd_base,
    &sipTypeDef_QtSensors_QIRProximitySensor.ctd_base,
    &sipTypeDef_QtSensors_QLidFilter.ctd_base,
    &sipTypeDef_QtSensors_QLidReading.ctd_base,
    &sipTypeDef_QtSensors_QLidSensor.ctd_base,
    &sipTypeDef_QtSensors_QLightFilter.ctd_base,
    &sipTypeDef_QtSensors_QLightReading.ctd_base,
    &sipTypeDef_QtSensors_QLightSensor.ctd_base,
    &sipTypeDef_QtSensors_QList_0101QSensorFilter.mtd_base,
    &sipTypeDef_QtSensors_QList_0100qoutputrange.mtd_base,
    &sipTypeDef_QtSensors_QMagnetometer.ctd_base,
    &sipTypeDef_QtSensors_QMagnetometerFilter.ctd_base,
    &sipTypeDef_QtSensors_QMagnetometerReading.ctd_base,
    &sipTypeDef_QtSensors_QOrientationFilter.ctd_base,
    &sipTypeDef_QtSensors_QOrientationReading.ctd_base,
    &enumTypes[3].etd_base,
    &sipTypeDef_QtSensors_QOrientationSensor.ctd_base,
    &sipTypeDef_QtSensors_QPressureFilter.ctd_base,
    &sipTypeDef_QtSensors_QPressureReading.ctd_base,
    &sipTypeDef_QtSensors_QPressureSensor.ctd_base,
    &sipTypeDef_QtSensors_QProximityFilter.ctd_base,
    &sipTypeDef_QtSensors_QProximityReading.ctd_base,
    &sipTypeDef_QtSensors_QProximitySensor.ctd_base,
    &sipTypeDef_QtSensors_QRotationFilter.ctd_base,
    &sipTypeDef_QtSensors_QRotationReading.ctd_base,
    &sipTypeDef_QtSensors_QRotationSensor.ctd_base,
    &sipTypeDef_QtSensors_QSensor.ctd_base,
    &enumTypes[1].etd_base,
    &enumTypes[2].etd_base,
    &sipTypeDef_QtSensors_QSensorFilter.ctd_base,
    &sipTypeDef_QtSensors_QSensorReading.ctd_base,
    &sipTypeDef_QtSensors_QTapFilter.ctd_base,
    &sipTypeDef_QtSensors_QTapReading.ctd_base,
    &enumTypes[0].etd_base,
    &sipTypeDef_QtSensors_QTapSensor.ctd_base,
    &sipTypeDef_QtSensors_QTiltFilter.ctd_base,
    &sipTypeDef_QtSensors_QTiltReading.ctd_base,
    &sipTypeDef_QtSensors_QTiltSensor.ctd_base,
    &sipTypeDef_QtSensors_qoutputrange.ctd_base,
};


/*
 * These define each typedef in this module.
 */
static sipTypedefDef typedefsTable[] = {
    {"qoutputrangelist", "QList<qoutputrange>"},
    {"qrangelist", "QList<QPair<int,int> >"},
    {"qtimestamp", "unsigned long long"},
};


/* This defines the types that this module needs to import from QtCore. */
sipImportedTypeDef sipImportedTypes_QtSensors_QtCore[] = {
    {"QByteArray"},
    {"QChildEvent"},
    {"QEvent"},
    {"QList<QByteArray>"},
    {"QList<QPair<int,int> >"},
    {"QMetaMethod"},
    {"QObject"},
    {"QString"},
    {"QTimerEvent"},
    {"QVariant"},
    {SIP_NULLPTR}
};


/*
 * This defines the virtual error handlers that this module needs to import
 * from QtCore.
 */
sipImportedVirtErrorHandlerDef sipImportedVirtErrorHandlers_QtSensors_QtCore[] = {
    {"PyQt5"},
    {SIP_NULLPTR}
};


/* This defines the modules that this module needs to import. */
static sipImportedModuleDef importsTable[] = {
    {"PyQt5.QtCore", sipImportedTypes_QtSensors_QtCore, sipImportedVirtErrorHandlers_QtSensors_QtCore, SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


/* This defines the class sub-convertors that this module defines. */
static sipSubClassConvertorDef convertorsTable[] = {
    {sipSubClass_QSensor, {6, 0, 0}, SIP_NULLPTR},
    {SIP_NULLPTR, {0, 0, 0}, SIP_NULLPTR}
};


/* This defines this module. */
sipExportedModuleDef sipModuleAPI_QtSensors = {
    0,
    SIP_API_MINOR_NR,
    sipNameNr_PyQt5_QtSensors,
    0,
    sipStrings_QtSensors,
    importsTable,
    SIP_NULLPTR,
    69,
    sipExportedTypes_QtSensors,
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    3,
    typedefsTable,
    SIP_NULLPTR,
    convertorsTable,
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};


/* The SIP API and the APIs of any imported modules. */
const sipAPIDef *sipAPI_QtSensors;

sip_qt_metaobject_func sip_QtSensors_qt_metaobject;
sip_qt_metacall_func sip_QtSensors_qt_metacall;
sip_qt_metacast_func sip_QtSensors_qt_metacast;


/* The Python module initialisation function. */
#if PY_MAJOR_VERSION >= 3
#define SIP_MODULE_ENTRY        PyInit_QtSensors
#define SIP_MODULE_TYPE         PyObject *
#define SIP_MODULE_DISCARD(r)   Py_DECREF(r)
#define SIP_MODULE_RETURN(r)    return (r)
#else
#define SIP_MODULE_ENTRY        initQtSensors
#define SIP_MODULE_TYPE         void
#define SIP_MODULE_DISCARD(r)
#define SIP_MODULE_RETURN(r)    return
#endif

#if defined(SIP_STATIC_MODULE)
extern "C" SIP_MODULE_TYPE SIP_MODULE_ENTRY()
#else
PyMODINIT_FUNC SIP_MODULE_ENTRY()
#endif
{
    static PyMethodDef sip_methods[] = {
        {SIP_NULLPTR, SIP_NULLPTR, 0, SIP_NULLPTR}
    };

#if PY_MAJOR_VERSION >= 3
    static PyModuleDef sip_module_def = {
        PyModuleDef_HEAD_INIT,
        "PyQt5.QtSensors",
        SIP_NULLPTR,
        -1,
        sip_methods,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_NULLPTR
    };
#endif

    PyObject *sipModule, *sipModuleDict;
    PyObject *sip_sipmod, *sip_capiobj;

    /* Initialise the module and get it's dictionary. */
#if PY_MAJOR_VERSION >= 3
    sipModule = PyModule_Create(&sip_module_def);
#elif PY_VERSION_HEX >= 0x02050000
    sipModule = Py_InitModule(sipName_PyQt5_QtSensors, sip_methods);
#else
    sipModule = Py_InitModule(const_cast<char *>(sipName_PyQt5_QtSensors), sip_methods);
#endif

    if (sipModule == SIP_NULLPTR)
        SIP_MODULE_RETURN(SIP_NULLPTR);

    sipModuleDict = PyModule_GetDict(sipModule);

    /* Get the SIP module's API. */
#if PY_VERSION_HEX >= 0x02050000
    sip_sipmod = PyImport_ImportModule("PyQt5.sip");
#else
    sip_sipmod = PyImport_ImportModule(const_cast<char *>("PyQt5.sip"));
#endif

    if (sip_sipmod == SIP_NULLPTR)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(SIP_NULLPTR);
    }

    sip_capiobj = PyDict_GetItemString(PyModule_GetDict(sip_sipmod), "_C_API");
    Py_DECREF(sip_sipmod);

#if defined(SIP_USE_PYCAPSULE)
    if (sip_capiobj == SIP_NULLPTR || !PyCapsule_CheckExact(sip_capiobj))
#else
    if (sip_capiobj == SIP_NULLPTR || !PyCObject_Check(sip_capiobj))
#endif
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(SIP_NULLPTR);
    }

#if defined(SIP_USE_PYCAPSULE)
    sipAPI_QtSensors = reinterpret_cast<const sipAPIDef *>(PyCapsule_GetPointer(sip_capiobj, "PyQt5.sip._C_API"));
#else
    sipAPI_QtSensors = reinterpret_cast<const sipAPIDef *>(PyCObject_AsVoidPtr(sip_capiobj));
#endif

#if defined(SIP_USE_PYCAPSULE)
    if (sipAPI_QtSensors == SIP_NULLPTR)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(SIP_NULLPTR);
    }
#endif

    /* Export the module and publish it's API. */
    if (sipExportModule(&sipModuleAPI_QtSensors,SIP_API_MAJOR_NR,SIP_API_MINOR_NR,0) < 0)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(SIP_NULLPTR);
    }

    sip_QtSensors_qt_metaobject = (sip_qt_metaobject_func)sipImportSymbol("qtcore_qt_metaobject");
    sip_QtSensors_qt_metacall = (sip_qt_metacall_func)sipImportSymbol("qtcore_qt_metacall");
    sip_QtSensors_qt_metacast = (sip_qt_metacast_func)sipImportSymbol("qtcore_qt_metacast");

    if (!sip_QtSensors_qt_metacast)
        Py_FatalError("Unable to import qtcore_qt_metacast");

    /* Initialise the module now all its dependencies have been set up. */
    if (sipInitModule(&sipModuleAPI_QtSensors,sipModuleDict) < 0)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(SIP_NULLPTR);
    }

    SIP_MODULE_RETURN(sipModule);
}

#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 979 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 983 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


extern "C" {static void assign_QList_0101QSensorFilter(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0101QSensorFilter(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QSensorFilter*> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QSensorFilter*> *>(sipSrc);
}


extern "C" {static void *array_QList_0101QSensorFilter(SIP_SSIZE_T);}
static void *array_QList_0101QSensorFilter(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QSensorFilter*>[sipNrElem];
}


extern "C" {static void *copy_QList_0101QSensorFilter(const void *, SIP_SSIZE_T);}
static void *copy_QList_0101QSensorFilter(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QSensorFilter*>(reinterpret_cast<const QList< ::QSensorFilter*> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0101QSensorFilter(void *, int);}
static void release_QList_0101QSensorFilter(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QSensorFilter*> *>(ptr);
}



extern "C" {static int convertTo_QList_0101QSensorFilter(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0101QSensorFilter(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QSensorFilter*> **sipCppPtr = reinterpret_cast<QList< ::QSensorFilter*> **>(sipCppPtrV);

#line 184 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QSensorFilter *> *ql = new QList<QSensorFilter *>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        QSensorFilter *t = reinterpret_cast<QSensorFilter *>(
                sipForceConvertToType(itm, sipType_QSensorFilter, sipTransferObj, 0,
                        0, sipIsErr));
 
        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QSensorFilter' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(t);

        Py_DECREF(itm);
    }

    Py_DECREF(iter);
 
    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 1091 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0101QSensorFilter(void *, PyObject *);}
static PyObject *convertFrom_QList_0101QSensorFilter(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QSensorFilter*> *sipCpp = reinterpret_cast<QList< ::QSensorFilter*> *>(sipCppV);

#line 153 "sip/QtCore/qpycore_qlist.sip"
    int gc_enabled = sipEnableGC(0);
    PyObject *l = PyList_New(sipCpp->size());

    if (l)
    {
        for (int i = 0; i < sipCpp->size(); ++i)
        {
            QSensorFilter *t = sipCpp->at(i);

            // The explicit (void *) cast allows QSensorFilter to be const.
            PyObject *tobj = sipConvertFromType((void *)t, sipType_QSensorFilter,
                    sipTransferObj);

            if (!tobj)
            {
                Py_DECREF(l);
                l = 0;

                break;
            }

            PyList_SetItem(l, i, tobj);
        }
    }

    sipEnableGC(gc_enabled);

    return l;
#line 1129 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtSensors_QList_0101QSensorFilter = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_533,     /* QList<QSensorFilter*> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0101QSensorFilter,
    array_QList_0101QSensorFilter,
    copy_QList_0101QSensorFilter,
    release_QList_0101QSensorFilter,
    convertTo_QList_0101QSensorFilter,
    convertFrom_QList_0101QSensorFilter
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1161 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 1165 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


extern "C" {static void assign_QList_0100qoutputrange(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100qoutputrange(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::qoutputrange> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::qoutputrange> *>(sipSrc);
}


extern "C" {static void *array_QList_0100qoutputrange(SIP_SSIZE_T);}
static void *array_QList_0100qoutputrange(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::qoutputrange>[sipNrElem];
}


extern "C" {static void *copy_QList_0100qoutputrange(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100qoutputrange(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::qoutputrange>(reinterpret_cast<const QList< ::qoutputrange> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100qoutputrange(void *, int);}
static void release_QList_0100qoutputrange(void *ptr, int)
{
    delete reinterpret_cast<QList< ::qoutputrange> *>(ptr);
}



extern "C" {static int convertTo_QList_0100qoutputrange(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100qoutputrange(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::qoutputrange> **sipCppPtr = reinterpret_cast<QList< ::qoutputrange> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<qoutputrange> *ql = new QList<qoutputrange>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        qoutputrange *t = reinterpret_cast<qoutputrange *>(
                sipForceConvertToType(itm, sipType_qoutputrange, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'qoutputrange' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_qoutputrange, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 1275 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100qoutputrange(void *, PyObject *);}
static PyObject *convertFrom_QList_0100qoutputrange(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::qoutputrange> *sipCpp = reinterpret_cast<QList< ::qoutputrange> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        qoutputrange *t = new qoutputrange(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_qoutputrange,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 1308 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtSensors_QList_0100qoutputrange = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_790,     /* QList<qoutputrange> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100qoutputrange,
    array_QList_0100qoutputrange,
    copy_QList_0100qoutputrange,
    release_QList_0100qoutputrange,
    convertTo_QList_0100qoutputrange,
    convertFrom_QList_0100qoutputrange
};

#line 57 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qrotationsensor.sip"
#include <qrotationsensor.h>
#line 1340 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 1344 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qrotationsensor.sip"
#include <qrotationsensor.h>
#line 1347 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 1350 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 1353 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1356 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1359 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 1362 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 1365 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1368 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 1371 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 1375 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 1378 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 1381 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 1384 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 1387 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 1390 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1393 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 1396 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 1399 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 1402 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 1405 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 1408 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 1411 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQRotationSensor : public  ::QRotationSensor
{
public:
    sipQRotationSensor( ::QObject*);
    virtual ~sipQRotationSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQRotationSensor(const sipQRotationSensor &);
    sipQRotationSensor &operator = (const sipQRotationSensor &);

    char sipPyMethods[7];
};

sipQRotationSensor::sipQRotationSensor( ::QObject*a0):  ::QRotationSensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQRotationSensor::~sipQRotationSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQRotationSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QRotationSensor);

    return  ::QRotationSensor::metaObject();
}

int sipQRotationSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QRotationSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QRotationSensor,_c,_id,_a);

    return _id;
}

void *sipQRotationSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QRotationSensor, _clname, &sipCpp) ? sipCpp :  ::QRotationSensor::qt_metacast(_clname));
}

void sipQRotationSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QRotationSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQRotationSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QRotationSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQRotationSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QRotationSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQRotationSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QRotationSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQRotationSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QRotationSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQRotationSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QRotationSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQRotationSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QRotationSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QRotationSensor_reading, "reading(self) -> QRotationReading");

extern "C" {static PyObject *meth_QRotationSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QRotationSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QRotationSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QRotationSensor, &sipCpp))
        {
             ::QRotationReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QRotationReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QRotationSensor, sipName_reading, doc_QRotationSensor_reading);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QRotationSensor_hasZ, "hasZ(self) -> bool");

extern "C" {static PyObject *meth_QRotationSensor_hasZ(PyObject *, PyObject *);}
static PyObject *meth_QRotationSensor_hasZ(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QRotationSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QRotationSensor, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->hasZ();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QRotationSensor, sipName_hasZ, doc_QRotationSensor_hasZ);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QRotationSensor_setHasZ, "setHasZ(self, bool)");

extern "C" {static PyObject *meth_QRotationSensor_setHasZ(PyObject *, PyObject *);}
static PyObject *meth_QRotationSensor_setHasZ(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool a0;
         ::QRotationSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QRotationSensor, &sipCpp, &a0))
        {
            sipCpp->setHasZ(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QRotationSensor, sipName_setHasZ, doc_QRotationSensor_setHasZ);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QRotationSensor(void *, const sipTypeDef *);}
static void *cast_QRotationSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QRotationSensor *sipCpp = reinterpret_cast< ::QRotationSensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QRotationSensor(void *, int);}
static void release_QRotationSensor(void *sipCppV, int)
{
     ::QRotationSensor *sipCpp = reinterpret_cast< ::QRotationSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QRotationSensor(sipSimpleWrapper *);}
static void dealloc_QRotationSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQRotationSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QRotationSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QRotationSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QRotationSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQRotationSensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQRotationSensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QRotationSensor[] = {{56, 255, 1}};


static PyMethodDef methods_QRotationSensor[] = {
    {SIP_MLNAME_CAST(sipName_hasZ), meth_QRotationSensor_hasZ, METH_VARARGS, SIP_MLDOC_CAST(doc_QRotationSensor_hasZ)},
    {SIP_MLNAME_CAST(sipName_reading), meth_QRotationSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QRotationSensor_reading)},
    {SIP_MLNAME_CAST(sipName_setHasZ), meth_QRotationSensor_setHasZ, METH_VARARGS, SIP_MLDOC_CAST(doc_QRotationSensor_setHasZ)}
};

PyDoc_STRVAR(doc_QRotationSensor, "\1QRotationSensor(parent: QObject = None)");


/* Define this type's signals. */
static const pyqt5QtSignal signals_QRotationSensor[] = {
    {"hasZChanged(bool)", "\1hasZChanged(self, bool)", SIP_NULLPTR, SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


static pyqt5ClassPluginDef plugin_QRotationSensor = {
    & ::QRotationSensor::staticMetaObject,
    0,
    signals_QRotationSensor,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QRotationSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QRotationSensor,
        {SIP_NULLPTR},
        &plugin_QRotationSensor
    },
    {
        sipNameNr_QRotationSensor,
        {0, 0, 1},
        3, methods_QRotationSensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QRotationSensor,
    -1,
    -1,
    supers_QRotationSensor,
    SIP_NULLPTR,
    init_type_QRotationSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QRotationSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QRotationSensor,
    cast_QRotationSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 44 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qrotationsensor.sip"
#include <qrotationsensor.h>
#line 1835 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qrotationsensor.sip"
#include <qrotationsensor.h>
#line 1839 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQRotationFilter : public  ::QRotationFilter
{
public:
    sipQRotationFilter();
    sipQRotationFilter(const  ::QRotationFilter&);
    virtual ~sipQRotationFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QRotationReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQRotationFilter(const sipQRotationFilter &);
    sipQRotationFilter &operator = (const sipQRotationFilter &);

    char sipPyMethods[1];
};

sipQRotationFilter::sipQRotationFilter():  ::QRotationFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQRotationFilter::sipQRotationFilter(const  ::QRotationFilter& a0):  ::QRotationFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQRotationFilter::~sipQRotationFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQRotationFilter::filter( ::QRotationReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QRotationFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QRotationReading*);

    return sipVH_QtSensors_25(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QRotationFilter_filter, "filter(self, QRotationReading) -> bool");

extern "C" {static PyObject *meth_QRotationFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QRotationFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QRotationReading* a0;
         ::QRotationFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QRotationFilter, &sipCpp, sipType_QRotationReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QRotationFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QRotationFilter, sipName_filter, doc_QRotationFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QRotationFilter(void *, const sipTypeDef *);}
static void *cast_QRotationFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QRotationFilter *sipCpp = reinterpret_cast< ::QRotationFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QRotationFilter(void *, int);}
static void release_QRotationFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQRotationFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QRotationFilter *>(sipCppV);
}


extern "C" {static void dealloc_QRotationFilter(sipSimpleWrapper *);}
static void dealloc_QRotationFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQRotationFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QRotationFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QRotationFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QRotationFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQRotationFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQRotationFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QRotationFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QRotationFilter, &a0))
        {
            sipCpp = new sipQRotationFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QRotationFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QRotationFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QRotationFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QRotationFilter_filter)}
};

PyDoc_STRVAR(doc_QRotationFilter, "\1QRotationFilter()\n"
"QRotationFilter(QRotationFilter)");


static pyqt5ClassPluginDef plugin_QRotationFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QRotationFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QRotationFilter,
        {SIP_NULLPTR},
        &plugin_QRotationFilter
    },
    {
        sipNameNr_QRotationFilter,
        {0, 0, 1},
        1, methods_QRotationFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QRotationFilter,
    -1,
    -1,
    supers_QRotationFilter,
    SIP_NULLPTR,
    init_type_QRotationFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QRotationFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QRotationFilter,
    cast_QRotationFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qrotationsensor.sip"
#include <qrotationsensor.h>
#line 2076 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 2080 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 2083 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2086 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2089 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2092 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 2095 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 2098 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2101 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 2104 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2107 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 2110 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 2113 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 2116 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 2119 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 2122 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 2125 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


PyDoc_STRVAR(doc_QRotationReading_x, "x(self) -> float");

extern "C" {static PyObject *meth_QRotationReading_x(PyObject *, PyObject *);}
static PyObject *meth_QRotationReading_x(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QRotationReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QRotationReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->x();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QRotationReading, sipName_x, doc_QRotationReading_x);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QRotationReading_y, "y(self) -> float");

extern "C" {static PyObject *meth_QRotationReading_y(PyObject *, PyObject *);}
static PyObject *meth_QRotationReading_y(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QRotationReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QRotationReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->y();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QRotationReading, sipName_y, doc_QRotationReading_y);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QRotationReading_z, "z(self) -> float");

extern "C" {static PyObject *meth_QRotationReading_z(PyObject *, PyObject *);}
static PyObject *meth_QRotationReading_z(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QRotationReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QRotationReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->z();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QRotationReading, sipName_z, doc_QRotationReading_z);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QRotationReading_setFromEuler, "setFromEuler(self, float, float, float)");

extern "C" {static PyObject *meth_QRotationReading_setFromEuler(PyObject *, PyObject *);}
static PyObject *meth_QRotationReading_setFromEuler(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::qreal a1;
         ::qreal a2;
         ::QRotationReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bddd", &sipSelf, sipType_QRotationReading, &sipCpp, &a0, &a1, &a2))
        {
            sipCpp->setFromEuler(a0,a1,a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QRotationReading, sipName_setFromEuler, doc_QRotationReading_setFromEuler);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QRotationReading(void *, const sipTypeDef *);}
static void *cast_QRotationReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QRotationReading *sipCpp = reinterpret_cast< ::QRotationReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QRotationReading(void *, int);}
static void release_QRotationReading(void *sipCppV, int)
{
     ::QRotationReading *sipCpp = reinterpret_cast< ::QRotationReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QRotationReading(sipSimpleWrapper *);}
static void dealloc_QRotationReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QRotationReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QRotationReading[] = {{60, 255, 1}};


static PyMethodDef methods_QRotationReading[] = {
    {SIP_MLNAME_CAST(sipName_setFromEuler), meth_QRotationReading_setFromEuler, METH_VARARGS, SIP_MLDOC_CAST(doc_QRotationReading_setFromEuler)},
    {SIP_MLNAME_CAST(sipName_x), meth_QRotationReading_x, METH_VARARGS, SIP_MLDOC_CAST(doc_QRotationReading_x)},
    {SIP_MLNAME_CAST(sipName_y), meth_QRotationReading_y, METH_VARARGS, SIP_MLDOC_CAST(doc_QRotationReading_y)},
    {SIP_MLNAME_CAST(sipName_z), meth_QRotationReading_z, METH_VARARGS, SIP_MLDOC_CAST(doc_QRotationReading_z)}
};


static pyqt5ClassPluginDef plugin_QRotationReading = {
    & ::QRotationReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QRotationReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QRotationReading,
        {SIP_NULLPTR},
        &plugin_QRotationReading
    },
    {
        sipNameNr_QRotationReading,
        {0, 0, 1},
        4, methods_QRotationReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QRotationReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QRotationReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QRotationReading,
    cast_QRotationReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 57 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtiltsensor.sip"
#include <qtiltsensor.h>
#line 2352 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 2356 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtiltsensor.sip"
#include <qtiltsensor.h>
#line 2359 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 2362 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 2365 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2368 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2371 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 2374 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 2377 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2380 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 2383 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 2387 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 2390 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2393 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2396 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 2399 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 2402 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2405 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 2408 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 2411 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 2414 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 2417 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 2420 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 2423 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQTiltSensor : public  ::QTiltSensor
{
public:
    sipQTiltSensor( ::QObject*);
    virtual ~sipQTiltSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQTiltSensor(const sipQTiltSensor &);
    sipQTiltSensor &operator = (const sipQTiltSensor &);

    char sipPyMethods[7];
};

sipQTiltSensor::sipQTiltSensor( ::QObject*a0):  ::QTiltSensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQTiltSensor::~sipQTiltSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQTiltSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QTiltSensor);

    return  ::QTiltSensor::metaObject();
}

int sipQTiltSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QTiltSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QTiltSensor,_c,_id,_a);

    return _id;
}

void *sipQTiltSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QTiltSensor, _clname, &sipCpp) ? sipCpp :  ::QTiltSensor::qt_metacast(_clname));
}

void sipQTiltSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QTiltSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTiltSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QTiltSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTiltSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QTiltSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTiltSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QTiltSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTiltSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QTiltSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQTiltSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QTiltSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQTiltSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QTiltSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QTiltSensor_reading, "reading(self) -> QTiltReading");

extern "C" {static PyObject *meth_QTiltSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QTiltSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTiltSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTiltSensor, &sipCpp))
        {
             ::QTiltReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QTiltReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTiltSensor, sipName_reading, doc_QTiltSensor_reading);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTiltSensor_calibrate, "calibrate(self)");

extern "C" {static PyObject *meth_QTiltSensor_calibrate(PyObject *, PyObject *);}
static PyObject *meth_QTiltSensor_calibrate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QTiltSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTiltSensor, &sipCpp))
        {
            sipCpp->calibrate();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTiltSensor, sipName_calibrate, doc_QTiltSensor_calibrate);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QTiltSensor(void *, const sipTypeDef *);}
static void *cast_QTiltSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QTiltSensor *sipCpp = reinterpret_cast< ::QTiltSensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QTiltSensor(void *, int);}
static void release_QTiltSensor(void *sipCppV, int)
{
     ::QTiltSensor *sipCpp = reinterpret_cast< ::QTiltSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QTiltSensor(sipSimpleWrapper *);}
static void dealloc_QTiltSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQTiltSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QTiltSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QTiltSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QTiltSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQTiltSensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQTiltSensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QTiltSensor[] = {{56, 255, 1}};


static PyMethodDef methods_QTiltSensor[] = {
    {SIP_MLNAME_CAST(sipName_calibrate), meth_QTiltSensor_calibrate, METH_VARARGS, SIP_MLDOC_CAST(doc_QTiltSensor_calibrate)},
    {SIP_MLNAME_CAST(sipName_reading), meth_QTiltSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QTiltSensor_reading)}
};

PyDoc_STRVAR(doc_QTiltSensor, "\1QTiltSensor(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QTiltSensor = {
    & ::QTiltSensor::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QTiltSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QTiltSensor,
        {SIP_NULLPTR},
        &plugin_QTiltSensor
    },
    {
        sipNameNr_QTiltSensor,
        {0, 0, 1},
        2, methods_QTiltSensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QTiltSensor,
    -1,
    -1,
    supers_QTiltSensor,
    SIP_NULLPTR,
    init_type_QTiltSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QTiltSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QTiltSensor,
    cast_QTiltSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 44 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtiltsensor.sip"
#include <qtiltsensor.h>
#line 2810 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtiltsensor.sip"
#include <qtiltsensor.h>
#line 2814 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQTiltFilter : public  ::QTiltFilter
{
public:
    sipQTiltFilter();
    sipQTiltFilter(const  ::QTiltFilter&);
    virtual ~sipQTiltFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QTiltReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQTiltFilter(const sipQTiltFilter &);
    sipQTiltFilter &operator = (const sipQTiltFilter &);

    char sipPyMethods[1];
};

sipQTiltFilter::sipQTiltFilter():  ::QTiltFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQTiltFilter::sipQTiltFilter(const  ::QTiltFilter& a0):  ::QTiltFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQTiltFilter::~sipQTiltFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQTiltFilter::filter( ::QTiltReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QTiltFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_24(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTiltReading*);

    return sipVH_QtSensors_24(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QTiltFilter_filter, "filter(self, QTiltReading) -> bool");

extern "C" {static PyObject *meth_QTiltFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QTiltFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QTiltReading* a0;
         ::QTiltFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QTiltFilter, &sipCpp, sipType_QTiltReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QTiltFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTiltFilter, sipName_filter, doc_QTiltFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QTiltFilter(void *, const sipTypeDef *);}
static void *cast_QTiltFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QTiltFilter *sipCpp = reinterpret_cast< ::QTiltFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QTiltFilter(void *, int);}
static void release_QTiltFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQTiltFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QTiltFilter *>(sipCppV);
}


extern "C" {static void dealloc_QTiltFilter(sipSimpleWrapper *);}
static void dealloc_QTiltFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQTiltFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QTiltFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QTiltFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QTiltFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQTiltFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQTiltFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QTiltFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QTiltFilter, &a0))
        {
            sipCpp = new sipQTiltFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QTiltFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QTiltFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QTiltFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QTiltFilter_filter)}
};

PyDoc_STRVAR(doc_QTiltFilter, "\1QTiltFilter()\n"
"QTiltFilter(QTiltFilter)");


static pyqt5ClassPluginDef plugin_QTiltFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QTiltFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QTiltFilter,
        {SIP_NULLPTR},
        &plugin_QTiltFilter
    },
    {
        sipNameNr_QTiltFilter,
        {0, 0, 1},
        1, methods_QTiltFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QTiltFilter,
    -1,
    -1,
    supers_QTiltFilter,
    SIP_NULLPTR,
    init_type_QTiltFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QTiltFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QTiltFilter,
    cast_QTiltFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtiltsensor.sip"
#include <qtiltsensor.h>
#line 3051 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 3055 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 3058 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3061 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3064 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3067 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 3070 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 3073 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3076 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 3079 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3082 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 3085 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 3088 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 3091 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 3094 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 3097 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 3100 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


PyDoc_STRVAR(doc_QTiltReading_yRotation, "yRotation(self) -> float");

extern "C" {static PyObject *meth_QTiltReading_yRotation(PyObject *, PyObject *);}
static PyObject *meth_QTiltReading_yRotation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTiltReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTiltReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->yRotation();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTiltReading, sipName_yRotation, doc_QTiltReading_yRotation);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTiltReading_setYRotation, "setYRotation(self, float)");

extern "C" {static PyObject *meth_QTiltReading_setYRotation(PyObject *, PyObject *);}
static PyObject *meth_QTiltReading_setYRotation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QTiltReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QTiltReading, &sipCpp, &a0))
        {
            sipCpp->setYRotation(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTiltReading, sipName_setYRotation, doc_QTiltReading_setYRotation);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTiltReading_xRotation, "xRotation(self) -> float");

extern "C" {static PyObject *meth_QTiltReading_xRotation(PyObject *, PyObject *);}
static PyObject *meth_QTiltReading_xRotation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTiltReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTiltReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->xRotation();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTiltReading, sipName_xRotation, doc_QTiltReading_xRotation);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTiltReading_setXRotation, "setXRotation(self, float)");

extern "C" {static PyObject *meth_QTiltReading_setXRotation(PyObject *, PyObject *);}
static PyObject *meth_QTiltReading_setXRotation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QTiltReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QTiltReading, &sipCpp, &a0))
        {
            sipCpp->setXRotation(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTiltReading, sipName_setXRotation, doc_QTiltReading_setXRotation);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QTiltReading(void *, const sipTypeDef *);}
static void *cast_QTiltReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QTiltReading *sipCpp = reinterpret_cast< ::QTiltReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QTiltReading(void *, int);}
static void release_QTiltReading(void *sipCppV, int)
{
     ::QTiltReading *sipCpp = reinterpret_cast< ::QTiltReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QTiltReading(sipSimpleWrapper *);}
static void dealloc_QTiltReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QTiltReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QTiltReading[] = {{60, 255, 1}};


static PyMethodDef methods_QTiltReading[] = {
    {SIP_MLNAME_CAST(sipName_setXRotation), meth_QTiltReading_setXRotation, METH_VARARGS, SIP_MLDOC_CAST(doc_QTiltReading_setXRotation)},
    {SIP_MLNAME_CAST(sipName_setYRotation), meth_QTiltReading_setYRotation, METH_VARARGS, SIP_MLDOC_CAST(doc_QTiltReading_setYRotation)},
    {SIP_MLNAME_CAST(sipName_xRotation), meth_QTiltReading_xRotation, METH_VARARGS, SIP_MLDOC_CAST(doc_QTiltReading_xRotation)},
    {SIP_MLNAME_CAST(sipName_yRotation), meth_QTiltReading_yRotation, METH_VARARGS, SIP_MLDOC_CAST(doc_QTiltReading_yRotation)}
};


static pyqt5ClassPluginDef plugin_QTiltReading = {
    & ::QTiltReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QTiltReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QTiltReading,
        {SIP_NULLPTR},
        &plugin_QTiltReading
    },
    {
        sipNameNr_QTiltReading,
        {0, 0, 1},
        4, methods_QTiltReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QTiltReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QTiltReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QTiltReading,
    cast_QTiltReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 74 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtapsensor.sip"
#include <qtapsensor.h>
#line 3325 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 3329 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtapsensor.sip"
#include <qtapsensor.h>
#line 3332 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 3335 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 3338 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3341 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3344 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 3347 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 3350 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3353 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 3356 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 3360 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 3363 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3366 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3369 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3372 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 3375 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3378 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 3381 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 3384 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 3387 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 3390 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 3393 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 3396 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQTapSensor : public  ::QTapSensor
{
public:
    sipQTapSensor( ::QObject*);
    virtual ~sipQTapSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQTapSensor(const sipQTapSensor &);
    sipQTapSensor &operator = (const sipQTapSensor &);

    char sipPyMethods[7];
};

sipQTapSensor::sipQTapSensor( ::QObject*a0):  ::QTapSensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQTapSensor::~sipQTapSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQTapSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QTapSensor);

    return  ::QTapSensor::metaObject();
}

int sipQTapSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QTapSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QTapSensor,_c,_id,_a);

    return _id;
}

void *sipQTapSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QTapSensor, _clname, &sipCpp) ? sipCpp :  ::QTapSensor::qt_metacast(_clname));
}

void sipQTapSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QTapSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTapSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QTapSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTapSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QTapSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTapSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QTapSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTapSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QTapSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQTapSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QTapSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQTapSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QTapSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QTapSensor_reading, "reading(self) -> QTapReading");

extern "C" {static PyObject *meth_QTapSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QTapSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTapSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTapSensor, &sipCpp))
        {
             ::QTapReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QTapReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTapSensor, sipName_reading, doc_QTapSensor_reading);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTapSensor_returnDoubleTapEvents, "returnDoubleTapEvents(self) -> bool");

extern "C" {static PyObject *meth_QTapSensor_returnDoubleTapEvents(PyObject *, PyObject *);}
static PyObject *meth_QTapSensor_returnDoubleTapEvents(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTapSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTapSensor, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->returnDoubleTapEvents();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTapSensor, sipName_returnDoubleTapEvents, doc_QTapSensor_returnDoubleTapEvents);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTapSensor_setReturnDoubleTapEvents, "setReturnDoubleTapEvents(self, bool)");

extern "C" {static PyObject *meth_QTapSensor_setReturnDoubleTapEvents(PyObject *, PyObject *);}
static PyObject *meth_QTapSensor_setReturnDoubleTapEvents(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool a0;
         ::QTapSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QTapSensor, &sipCpp, &a0))
        {
            sipCpp->setReturnDoubleTapEvents(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTapSensor, sipName_setReturnDoubleTapEvents, doc_QTapSensor_setReturnDoubleTapEvents);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QTapSensor(void *, const sipTypeDef *);}
static void *cast_QTapSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QTapSensor *sipCpp = reinterpret_cast< ::QTapSensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QTapSensor(void *, int);}
static void release_QTapSensor(void *sipCppV, int)
{
     ::QTapSensor *sipCpp = reinterpret_cast< ::QTapSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QTapSensor(sipSimpleWrapper *);}
static void dealloc_QTapSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQTapSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QTapSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QTapSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QTapSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQTapSensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQTapSensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QTapSensor[] = {{56, 255, 1}};


static PyMethodDef methods_QTapSensor[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QTapSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QTapSensor_reading)},
    {SIP_MLNAME_CAST(sipName_returnDoubleTapEvents), meth_QTapSensor_returnDoubleTapEvents, METH_VARARGS, SIP_MLDOC_CAST(doc_QTapSensor_returnDoubleTapEvents)},
    {SIP_MLNAME_CAST(sipName_setReturnDoubleTapEvents), meth_QTapSensor_setReturnDoubleTapEvents, METH_VARARGS, SIP_MLDOC_CAST(doc_QTapSensor_setReturnDoubleTapEvents)}
};

PyDoc_STRVAR(doc_QTapSensor, "\1QTapSensor(parent: QObject = None)");


/* Define this type's signals. */
static const pyqt5QtSignal signals_QTapSensor[] = {
    {"returnDoubleTapEventsChanged(bool)", "\1returnDoubleTapEventsChanged(self, bool)", SIP_NULLPTR, SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


static pyqt5ClassPluginDef plugin_QTapSensor = {
    & ::QTapSensor::staticMetaObject,
    0,
    signals_QTapSensor,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QTapSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QTapSensor,
        {SIP_NULLPTR},
        &plugin_QTapSensor
    },
    {
        sipNameNr_QTapSensor,
        {0, 0, 1},
        3, methods_QTapSensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QTapSensor,
    -1,
    -1,
    supers_QTapSensor,
    SIP_NULLPTR,
    init_type_QTapSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QTapSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QTapSensor,
    cast_QTapSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 61 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtapsensor.sip"
#include <qtapsensor.h>
#line 3820 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtapsensor.sip"
#include <qtapsensor.h>
#line 3824 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQTapFilter : public  ::QTapFilter
{
public:
    sipQTapFilter();
    sipQTapFilter(const  ::QTapFilter&);
    virtual ~sipQTapFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QTapReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQTapFilter(const sipQTapFilter &);
    sipQTapFilter &operator = (const sipQTapFilter &);

    char sipPyMethods[1];
};

sipQTapFilter::sipQTapFilter():  ::QTapFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQTapFilter::sipQTapFilter(const  ::QTapFilter& a0):  ::QTapFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQTapFilter::~sipQTapFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQTapFilter::filter( ::QTapReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QTapFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_23(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTapReading*);

    return sipVH_QtSensors_23(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QTapFilter_filter, "filter(self, QTapReading) -> bool");

extern "C" {static PyObject *meth_QTapFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QTapFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QTapReading* a0;
         ::QTapFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QTapFilter, &sipCpp, sipType_QTapReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QTapFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTapFilter, sipName_filter, doc_QTapFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QTapFilter(void *, const sipTypeDef *);}
static void *cast_QTapFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QTapFilter *sipCpp = reinterpret_cast< ::QTapFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QTapFilter(void *, int);}
static void release_QTapFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQTapFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QTapFilter *>(sipCppV);
}


extern "C" {static void dealloc_QTapFilter(sipSimpleWrapper *);}
static void dealloc_QTapFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQTapFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QTapFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QTapFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QTapFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQTapFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQTapFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QTapFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QTapFilter, &a0))
        {
            sipCpp = new sipQTapFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QTapFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QTapFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QTapFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QTapFilter_filter)}
};

PyDoc_STRVAR(doc_QTapFilter, "\1QTapFilter()\n"
"QTapFilter(QTapFilter)");


static pyqt5ClassPluginDef plugin_QTapFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QTapFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QTapFilter,
        {SIP_NULLPTR},
        &plugin_QTapFilter
    },
    {
        sipNameNr_QTapFilter,
        {0, 0, 1},
        1, methods_QTapFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QTapFilter,
    -1,
    -1,
    supers_QTapFilter,
    SIP_NULLPTR,
    init_type_QTapFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QTapFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QTapFilter,
    cast_QTapFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qtapsensor.sip"
#include <qtapsensor.h>
#line 4061 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 4065 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 4068 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4071 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4074 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4077 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 4080 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 4083 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4086 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 4089 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4092 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4095 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 4098 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4101 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 4104 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 4107 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 4110 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


PyDoc_STRVAR(doc_QTapReading_tapDirection, "tapDirection(self) -> QTapReading.TapDirection");

extern "C" {static PyObject *meth_QTapReading_tapDirection(PyObject *, PyObject *);}
static PyObject *meth_QTapReading_tapDirection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTapReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTapReading, &sipCpp))
        {
             ::QTapReading::TapDirection sipRes;

            sipRes = sipCpp->tapDirection();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QTapReading_TapDirection);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTapReading, sipName_tapDirection, doc_QTapReading_tapDirection);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTapReading_setTapDirection, "setTapDirection(self, QTapReading.TapDirection)");

extern "C" {static PyObject *meth_QTapReading_setTapDirection(PyObject *, PyObject *);}
static PyObject *meth_QTapReading_setTapDirection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QTapReading::TapDirection a0;
         ::QTapReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QTapReading, &sipCpp, sipType_QTapReading_TapDirection, &a0))
        {
            sipCpp->setTapDirection(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTapReading, sipName_setTapDirection, doc_QTapReading_setTapDirection);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTapReading_isDoubleTap, "isDoubleTap(self) -> bool");

extern "C" {static PyObject *meth_QTapReading_isDoubleTap(PyObject *, PyObject *);}
static PyObject *meth_QTapReading_isDoubleTap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTapReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTapReading, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isDoubleTap();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTapReading, sipName_isDoubleTap, doc_QTapReading_isDoubleTap);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTapReading_setDoubleTap, "setDoubleTap(self, bool)");

extern "C" {static PyObject *meth_QTapReading_setDoubleTap(PyObject *, PyObject *);}
static PyObject *meth_QTapReading_setDoubleTap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool a0;
         ::QTapReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QTapReading, &sipCpp, &a0))
        {
            sipCpp->setDoubleTap(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTapReading, sipName_setDoubleTap, doc_QTapReading_setDoubleTap);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QTapReading(void *, const sipTypeDef *);}
static void *cast_QTapReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QTapReading *sipCpp = reinterpret_cast< ::QTapReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QTapReading(void *, int);}
static void release_QTapReading(void *sipCppV, int)
{
     ::QTapReading *sipCpp = reinterpret_cast< ::QTapReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QTapReading(sipSimpleWrapper *);}
static void dealloc_QTapReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QTapReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QTapReading[] = {{60, 255, 1}};


static PyMethodDef methods_QTapReading[] = {
    {SIP_MLNAME_CAST(sipName_isDoubleTap), meth_QTapReading_isDoubleTap, METH_VARARGS, SIP_MLDOC_CAST(doc_QTapReading_isDoubleTap)},
    {SIP_MLNAME_CAST(sipName_setDoubleTap), meth_QTapReading_setDoubleTap, METH_VARARGS, SIP_MLDOC_CAST(doc_QTapReading_setDoubleTap)},
    {SIP_MLNAME_CAST(sipName_setTapDirection), meth_QTapReading_setTapDirection, METH_VARARGS, SIP_MLDOC_CAST(doc_QTapReading_setTapDirection)},
    {SIP_MLNAME_CAST(sipName_tapDirection), meth_QTapReading_tapDirection, METH_VARARGS, SIP_MLDOC_CAST(doc_QTapReading_tapDirection)}
};

static sipEnumMemberDef enummembers_QTapReading[] = {
    {sipName_Undefined, static_cast<int>( ::QTapReading::Undefined), 63},
    {sipName_X, static_cast<int>( ::QTapReading::X), 63},
    {sipName_X_Both, static_cast<int>( ::QTapReading::X_Both), 63},
    {sipName_X_Neg, static_cast<int>( ::QTapReading::X_Neg), 63},
    {sipName_X_Pos, static_cast<int>( ::QTapReading::X_Pos), 63},
    {sipName_Y, static_cast<int>( ::QTapReading::Y), 63},
    {sipName_Y_Both, static_cast<int>( ::QTapReading::Y_Both), 63},
    {sipName_Y_Neg, static_cast<int>( ::QTapReading::Y_Neg), 63},
    {sipName_Y_Pos, static_cast<int>( ::QTapReading::Y_Pos), 63},
    {sipName_Z, static_cast<int>( ::QTapReading::Z), 63},
    {sipName_Z_Both, static_cast<int>( ::QTapReading::Z_Both), 63},
    {sipName_Z_Neg, static_cast<int>( ::QTapReading::Z_Neg), 63},
    {sipName_Z_Pos, static_cast<int>( ::QTapReading::Z_Pos), 63},
};


static pyqt5ClassPluginDef plugin_QTapReading = {
    & ::QTapReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QTapReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QTapReading,
        {SIP_NULLPTR},
        &plugin_QTapReading
    },
    {
        sipNameNr_QTapReading,
        {0, 0, 1},
        4, methods_QTapReading,
        13, enummembers_QTapReading,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QTapReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QTapReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QTapReading,
    cast_QTapReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 4351 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"



/* Call the instance's destructor. */
extern "C" {static void release_qoutputrange(void *, int);}
static void release_qoutputrange(void *sipCppV, int)
{
    delete reinterpret_cast< ::qoutputrange *>(sipCppV);
}


extern "C" {static void assign_qoutputrange(void *, SIP_SSIZE_T, void *);}
static void assign_qoutputrange(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::qoutputrange *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::qoutputrange *>(sipSrc);
}


extern "C" {static void *array_qoutputrange(SIP_SSIZE_T);}
static void *array_qoutputrange(SIP_SSIZE_T sipNrElem)
{
    return new  ::qoutputrange[sipNrElem];
}


extern "C" {static void *copy_qoutputrange(const void *, SIP_SSIZE_T);}
static void *copy_qoutputrange(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::qoutputrange(reinterpret_cast<const  ::qoutputrange *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_qoutputrange(sipSimpleWrapper *);}
static void dealloc_qoutputrange(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_qoutputrange(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_qoutputrange(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_qoutputrange(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::qoutputrange *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new  ::qoutputrange();

            return sipCpp;
        }
    }

    {
        const  ::qoutputrange* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_qoutputrange, &a0))
        {
            sipCpp = new  ::qoutputrange(*a0);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


extern "C" {static PyObject *varget_qoutputrange_accuracy(void *, PyObject *, PyObject *);}
static PyObject *varget_qoutputrange_accuracy(void *sipSelf, PyObject *, PyObject *)
{
     ::qreal sipVal;
     ::qoutputrange *sipCpp = reinterpret_cast< ::qoutputrange *>(sipSelf);

    sipVal = sipCpp->accuracy;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_qoutputrange_accuracy(void *, PyObject *, PyObject *);}
static int varset_qoutputrange_accuracy(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::qreal sipVal;
     ::qoutputrange *sipCpp = reinterpret_cast< ::qoutputrange *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != SIP_NULLPTR)
        return -1;

    sipCpp->accuracy = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_qoutputrange_maximum(void *, PyObject *, PyObject *);}
static PyObject *varget_qoutputrange_maximum(void *sipSelf, PyObject *, PyObject *)
{
     ::qreal sipVal;
     ::qoutputrange *sipCpp = reinterpret_cast< ::qoutputrange *>(sipSelf);

    sipVal = sipCpp->maximum;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_qoutputrange_maximum(void *, PyObject *, PyObject *);}
static int varset_qoutputrange_maximum(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::qreal sipVal;
     ::qoutputrange *sipCpp = reinterpret_cast< ::qoutputrange *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != SIP_NULLPTR)
        return -1;

    sipCpp->maximum = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_qoutputrange_minimum(void *, PyObject *, PyObject *);}
static PyObject *varget_qoutputrange_minimum(void *sipSelf, PyObject *, PyObject *)
{
     ::qreal sipVal;
     ::qoutputrange *sipCpp = reinterpret_cast< ::qoutputrange *>(sipSelf);

    sipVal = sipCpp->minimum;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_qoutputrange_minimum(void *, PyObject *, PyObject *);}
static int varset_qoutputrange_minimum(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::qreal sipVal;
     ::qoutputrange *sipCpp = reinterpret_cast< ::qoutputrange *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != SIP_NULLPTR)
        return -1;

    sipCpp->minimum = sipVal;

    return 0;
}

sipVariableDef variables_qoutputrange[] = {
    {InstanceVariable, sipName_accuracy, (PyMethodDef *)varget_qoutputrange_accuracy, (PyMethodDef *)varset_qoutputrange_accuracy, SIP_NULLPTR, SIP_NULLPTR},
    {InstanceVariable, sipName_maximum, (PyMethodDef *)varget_qoutputrange_maximum, (PyMethodDef *)varset_qoutputrange_maximum, SIP_NULLPTR, SIP_NULLPTR},
    {InstanceVariable, sipName_minimum, (PyMethodDef *)varget_qoutputrange_minimum, (PyMethodDef *)varset_qoutputrange_minimum, SIP_NULLPTR, SIP_NULLPTR},
};

PyDoc_STRVAR(doc_qoutputrange, "\1qoutputrange()\n"
"qoutputrange(qoutputrange)");


static pyqt5ClassPluginDef plugin_qoutputrange = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_qoutputrange = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_qoutputrange,
        {SIP_NULLPTR},
        &plugin_qoutputrange
    },
    {
        sipNameNr_qoutputrange,
        {0, 0, 1},
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        3, variables_qoutputrange,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_qoutputrange,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    SIP_NULLPTR,
    init_type_qoutputrange,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_qoutputrange,
    assign_qoutputrange,
    array_qoutputrange,
    copy_qoutputrange,
    release_qoutputrange,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 55 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qproximitysensor.sip"
#include <qproximitysensor.h>
#line 4580 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 4584 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qproximitysensor.sip"
#include <qproximitysensor.h>
#line 4587 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 4590 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 4593 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4596 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4599 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 4602 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 4605 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4608 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 4611 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 4615 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 4618 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4621 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4624 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4627 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 4630 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4633 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4636 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 4639 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4642 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 4645 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 4648 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 4651 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQProximitySensor : public  ::QProximitySensor
{
public:
    sipQProximitySensor( ::QObject*);
    virtual ~sipQProximitySensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQProximitySensor(const sipQProximitySensor &);
    sipQProximitySensor &operator = (const sipQProximitySensor &);

    char sipPyMethods[7];
};

sipQProximitySensor::sipQProximitySensor( ::QObject*a0):  ::QProximitySensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQProximitySensor::~sipQProximitySensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQProximitySensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QProximitySensor);

    return  ::QProximitySensor::metaObject();
}

int sipQProximitySensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QProximitySensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QProximitySensor,_c,_id,_a);

    return _id;
}

void *sipQProximitySensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QProximitySensor, _clname, &sipCpp) ? sipCpp :  ::QProximitySensor::qt_metacast(_clname));
}

void sipQProximitySensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QProximitySensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQProximitySensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QProximitySensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQProximitySensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QProximitySensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQProximitySensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QProximitySensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQProximitySensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QProximitySensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQProximitySensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QProximitySensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQProximitySensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QProximitySensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QProximitySensor_reading, "reading(self) -> QProximityReading");

extern "C" {static PyObject *meth_QProximitySensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QProximitySensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QProximitySensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QProximitySensor, &sipCpp))
        {
             ::QProximityReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QProximityReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QProximitySensor, sipName_reading, doc_QProximitySensor_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QProximitySensor(void *, const sipTypeDef *);}
static void *cast_QProximitySensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QProximitySensor *sipCpp = reinterpret_cast< ::QProximitySensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QProximitySensor(void *, int);}
static void release_QProximitySensor(void *sipCppV, int)
{
     ::QProximitySensor *sipCpp = reinterpret_cast< ::QProximitySensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QProximitySensor(sipSimpleWrapper *);}
static void dealloc_QProximitySensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQProximitySensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QProximitySensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QProximitySensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QProximitySensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQProximitySensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQProximitySensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QProximitySensor[] = {{56, 255, 1}};


static PyMethodDef methods_QProximitySensor[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QProximitySensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QProximitySensor_reading)}
};

PyDoc_STRVAR(doc_QProximitySensor, "\1QProximitySensor(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QProximitySensor = {
    & ::QProximitySensor::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QProximitySensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QProximitySensor,
        {SIP_NULLPTR},
        &plugin_QProximitySensor
    },
    {
        sipNameNr_QProximitySensor,
        {0, 0, 1},
        1, methods_QProximitySensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QProximitySensor,
    -1,
    -1,
    supers_QProximitySensor,
    SIP_NULLPTR,
    init_type_QProximitySensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QProximitySensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QProximitySensor,
    cast_QProximitySensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 42 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qproximitysensor.sip"
#include <qproximitysensor.h>
#line 5010 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qproximitysensor.sip"
#include <qproximitysensor.h>
#line 5014 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQProximityFilter : public  ::QProximityFilter
{
public:
    sipQProximityFilter();
    sipQProximityFilter(const  ::QProximityFilter&);
    virtual ~sipQProximityFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QProximityReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQProximityFilter(const sipQProximityFilter &);
    sipQProximityFilter &operator = (const sipQProximityFilter &);

    char sipPyMethods[1];
};

sipQProximityFilter::sipQProximityFilter():  ::QProximityFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQProximityFilter::sipQProximityFilter(const  ::QProximityFilter& a0):  ::QProximityFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQProximityFilter::~sipQProximityFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQProximityFilter::filter( ::QProximityReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QProximityFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_22(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QProximityReading*);

    return sipVH_QtSensors_22(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QProximityFilter_filter, "filter(self, QProximityReading) -> bool");

extern "C" {static PyObject *meth_QProximityFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QProximityFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QProximityReading* a0;
         ::QProximityFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QProximityFilter, &sipCpp, sipType_QProximityReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QProximityFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QProximityFilter, sipName_filter, doc_QProximityFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QProximityFilter(void *, const sipTypeDef *);}
static void *cast_QProximityFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QProximityFilter *sipCpp = reinterpret_cast< ::QProximityFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QProximityFilter(void *, int);}
static void release_QProximityFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQProximityFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QProximityFilter *>(sipCppV);
}


extern "C" {static void dealloc_QProximityFilter(sipSimpleWrapper *);}
static void dealloc_QProximityFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQProximityFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QProximityFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QProximityFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QProximityFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQProximityFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQProximityFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QProximityFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QProximityFilter, &a0))
        {
            sipCpp = new sipQProximityFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QProximityFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QProximityFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QProximityFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QProximityFilter_filter)}
};

PyDoc_STRVAR(doc_QProximityFilter, "\1QProximityFilter()\n"
"QProximityFilter(QProximityFilter)");


static pyqt5ClassPluginDef plugin_QProximityFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QProximityFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QProximityFilter,
        {SIP_NULLPTR},
        &plugin_QProximityFilter
    },
    {
        sipNameNr_QProximityFilter,
        {0, 0, 1},
        1, methods_QProximityFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QProximityFilter,
    -1,
    -1,
    supers_QProximityFilter,
    SIP_NULLPTR,
    init_type_QProximityFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QProximityFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QProximityFilter,
    cast_QProximityFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qproximitysensor.sip"
#include <qproximitysensor.h>
#line 5251 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 5255 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 5258 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5261 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5264 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5267 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 5270 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 5273 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5276 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 5279 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5282 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 5285 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 5288 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 5291 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 5294 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 5297 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 5300 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


PyDoc_STRVAR(doc_QProximityReading_close, "close(self) -> bool");

extern "C" {static PyObject *meth_QProximityReading_close(PyObject *, PyObject *);}
static PyObject *meth_QProximityReading_close(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QProximityReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QProximityReading, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->close();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QProximityReading, sipName_close, doc_QProximityReading_close);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QProximityReading_setClose, "setClose(self, bool)");

extern "C" {static PyObject *meth_QProximityReading_setClose(PyObject *, PyObject *);}
static PyObject *meth_QProximityReading_setClose(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool a0;
         ::QProximityReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QProximityReading, &sipCpp, &a0))
        {
            sipCpp->setClose(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QProximityReading, sipName_setClose, doc_QProximityReading_setClose);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QProximityReading(void *, const sipTypeDef *);}
static void *cast_QProximityReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QProximityReading *sipCpp = reinterpret_cast< ::QProximityReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QProximityReading(void *, int);}
static void release_QProximityReading(void *sipCppV, int)
{
     ::QProximityReading *sipCpp = reinterpret_cast< ::QProximityReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QProximityReading(sipSimpleWrapper *);}
static void dealloc_QProximityReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QProximityReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QProximityReading[] = {{60, 255, 1}};


static PyMethodDef methods_QProximityReading[] = {
    {SIP_MLNAME_CAST(sipName_close), meth_QProximityReading_close, METH_VARARGS, SIP_MLDOC_CAST(doc_QProximityReading_close)},
    {SIP_MLNAME_CAST(sipName_setClose), meth_QProximityReading_setClose, METH_VARARGS, SIP_MLDOC_CAST(doc_QProximityReading_setClose)}
};


static pyqt5ClassPluginDef plugin_QProximityReading = {
    & ::QProximityReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QProximityReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QProximityReading,
        {SIP_NULLPTR},
        &plugin_QProximityReading
    },
    {
        sipNameNr_QProximityReading,
        {0, 0, 1},
        2, methods_QProximityReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QProximityReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QProximityReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QProximityReading,
    cast_QProximityReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 61 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qpressuresensor.sip"
#include <qpressuresensor.h>
#line 5467 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 5471 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qpressuresensor.sip"
#include <qpressuresensor.h>
#line 5474 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 5477 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 5480 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5483 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5486 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 5489 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 5492 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5495 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 5498 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 5502 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 5505 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5508 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5511 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 5514 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 5517 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5520 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 5523 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 5526 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 5529 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 5532 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 5535 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 5538 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQPressureSensor : public  ::QPressureSensor
{
public:
    sipQPressureSensor( ::QObject*);
    virtual ~sipQPressureSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQPressureSensor(const sipQPressureSensor &);
    sipQPressureSensor &operator = (const sipQPressureSensor &);

    char sipPyMethods[7];
};

sipQPressureSensor::sipQPressureSensor( ::QObject*a0):  ::QPressureSensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQPressureSensor::~sipQPressureSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQPressureSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QPressureSensor);

    return  ::QPressureSensor::metaObject();
}

int sipQPressureSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QPressureSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QPressureSensor,_c,_id,_a);

    return _id;
}

void *sipQPressureSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QPressureSensor, _clname, &sipCpp) ? sipCpp :  ::QPressureSensor::qt_metacast(_clname));
}

void sipQPressureSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QPressureSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQPressureSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QPressureSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQPressureSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QPressureSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQPressureSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QPressureSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQPressureSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QPressureSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQPressureSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QPressureSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQPressureSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QPressureSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QPressureSensor_reading, "reading(self) -> QPressureReading");

extern "C" {static PyObject *meth_QPressureSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QPressureSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QPressureSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QPressureSensor, &sipCpp))
        {
             ::QPressureReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QPressureReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QPressureSensor, sipName_reading, doc_QPressureSensor_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QPressureSensor(void *, const sipTypeDef *);}
static void *cast_QPressureSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QPressureSensor *sipCpp = reinterpret_cast< ::QPressureSensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QPressureSensor(void *, int);}
static void release_QPressureSensor(void *sipCppV, int)
{
     ::QPressureSensor *sipCpp = reinterpret_cast< ::QPressureSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QPressureSensor(sipSimpleWrapper *);}
static void dealloc_QPressureSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQPressureSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QPressureSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QPressureSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QPressureSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQPressureSensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQPressureSensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QPressureSensor[] = {{56, 255, 1}};


static PyMethodDef methods_QPressureSensor[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QPressureSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QPressureSensor_reading)}
};

PyDoc_STRVAR(doc_QPressureSensor, "\1QPressureSensor(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QPressureSensor = {
    & ::QPressureSensor::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QPressureSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QPressureSensor,
        {SIP_NULLPTR},
        &plugin_QPressureSensor
    },
    {
        sipNameNr_QPressureSensor,
        {0, 0, 1},
        1, methods_QPressureSensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QPressureSensor,
    -1,
    -1,
    supers_QPressureSensor,
    SIP_NULLPTR,
    init_type_QPressureSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QPressureSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QPressureSensor,
    cast_QPressureSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 48 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qpressuresensor.sip"
#include <qpressuresensor.h>
#line 5897 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qpressuresensor.sip"
#include <qpressuresensor.h>
#line 5901 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQPressureFilter : public  ::QPressureFilter
{
public:
    sipQPressureFilter();
    sipQPressureFilter(const  ::QPressureFilter&);
    virtual ~sipQPressureFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QPressureReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQPressureFilter(const sipQPressureFilter &);
    sipQPressureFilter &operator = (const sipQPressureFilter &);

    char sipPyMethods[1];
};

sipQPressureFilter::sipQPressureFilter():  ::QPressureFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQPressureFilter::sipQPressureFilter(const  ::QPressureFilter& a0):  ::QPressureFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQPressureFilter::~sipQPressureFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQPressureFilter::filter( ::QPressureReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QPressureFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_21(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QPressureReading*);

    return sipVH_QtSensors_21(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QPressureFilter_filter, "filter(self, QPressureReading) -> bool");

extern "C" {static PyObject *meth_QPressureFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QPressureFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QPressureReading* a0;
         ::QPressureFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QPressureFilter, &sipCpp, sipType_QPressureReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QPressureFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QPressureFilter, sipName_filter, doc_QPressureFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QPressureFilter(void *, const sipTypeDef *);}
static void *cast_QPressureFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QPressureFilter *sipCpp = reinterpret_cast< ::QPressureFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QPressureFilter(void *, int);}
static void release_QPressureFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQPressureFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QPressureFilter *>(sipCppV);
}


extern "C" {static void dealloc_QPressureFilter(sipSimpleWrapper *);}
static void dealloc_QPressureFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQPressureFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QPressureFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QPressureFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QPressureFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQPressureFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQPressureFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QPressureFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QPressureFilter, &a0))
        {
            sipCpp = new sipQPressureFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QPressureFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QPressureFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QPressureFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QPressureFilter_filter)}
};

PyDoc_STRVAR(doc_QPressureFilter, "\1QPressureFilter()\n"
"QPressureFilter(QPressureFilter)");


static pyqt5ClassPluginDef plugin_QPressureFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QPressureFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QPressureFilter,
        {SIP_NULLPTR},
        &plugin_QPressureFilter
    },
    {
        sipNameNr_QPressureFilter,
        {0, 0, 1},
        1, methods_QPressureFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QPressureFilter,
    -1,
    -1,
    supers_QPressureFilter,
    SIP_NULLPTR,
    init_type_QPressureFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QPressureFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QPressureFilter,
    cast_QPressureFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qpressuresensor.sip"
#include <qpressuresensor.h>
#line 6138 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 6142 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 6145 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6148 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6151 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6154 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 6157 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 6160 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6163 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 6166 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6169 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6172 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 6175 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6178 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 6181 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 6184 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 6187 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


PyDoc_STRVAR(doc_QPressureReading_pressure, "pressure(self) -> float");

extern "C" {static PyObject *meth_QPressureReading_pressure(PyObject *, PyObject *);}
static PyObject *meth_QPressureReading_pressure(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QPressureReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QPressureReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->pressure();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QPressureReading, sipName_pressure, doc_QPressureReading_pressure);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QPressureReading_setPressure, "setPressure(self, float)");

extern "C" {static PyObject *meth_QPressureReading_setPressure(PyObject *, PyObject *);}
static PyObject *meth_QPressureReading_setPressure(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QPressureReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QPressureReading, &sipCpp, &a0))
        {
            sipCpp->setPressure(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QPressureReading, sipName_setPressure, doc_QPressureReading_setPressure);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QPressureReading_temperature, "temperature(self) -> float");

extern "C" {static PyObject *meth_QPressureReading_temperature(PyObject *, PyObject *);}
static PyObject *meth_QPressureReading_temperature(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QPressureReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QPressureReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->temperature();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QPressureReading, sipName_temperature, doc_QPressureReading_temperature);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QPressureReading_setTemperature, "setTemperature(self, float)");

extern "C" {static PyObject *meth_QPressureReading_setTemperature(PyObject *, PyObject *);}
static PyObject *meth_QPressureReading_setTemperature(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QPressureReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QPressureReading, &sipCpp, &a0))
        {
            sipCpp->setTemperature(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QPressureReading, sipName_setTemperature, doc_QPressureReading_setTemperature);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QPressureReading(void *, const sipTypeDef *);}
static void *cast_QPressureReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QPressureReading *sipCpp = reinterpret_cast< ::QPressureReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QPressureReading(void *, int);}
static void release_QPressureReading(void *sipCppV, int)
{
     ::QPressureReading *sipCpp = reinterpret_cast< ::QPressureReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QPressureReading(sipSimpleWrapper *);}
static void dealloc_QPressureReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QPressureReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QPressureReading[] = {{60, 255, 1}};


static PyMethodDef methods_QPressureReading[] = {
    {SIP_MLNAME_CAST(sipName_pressure), meth_QPressureReading_pressure, METH_VARARGS, SIP_MLDOC_CAST(doc_QPressureReading_pressure)},
    {SIP_MLNAME_CAST(sipName_setPressure), meth_QPressureReading_setPressure, METH_VARARGS, SIP_MLDOC_CAST(doc_QPressureReading_setPressure)},
    {SIP_MLNAME_CAST(sipName_setTemperature), meth_QPressureReading_setTemperature, METH_VARARGS, SIP_MLDOC_CAST(doc_QPressureReading_setTemperature)},
    {SIP_MLNAME_CAST(sipName_temperature), meth_QPressureReading_temperature, METH_VARARGS, SIP_MLDOC_CAST(doc_QPressureReading_temperature)}
};


static pyqt5ClassPluginDef plugin_QPressureReading = {
    & ::QPressureReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QPressureReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QPressureReading,
        {SIP_NULLPTR},
        &plugin_QPressureReading
    },
    {
        sipNameNr_QPressureReading,
        {0, 0, 1},
        4, methods_QPressureReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QPressureReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QPressureReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QPressureReading,
    cast_QPressureReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 66 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qorientationsensor.sip"
#include <qorientationsensor.h>
#line 6412 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 6416 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qorientationsensor.sip"
#include <qorientationsensor.h>
#line 6419 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 6422 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 6425 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6428 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6431 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 6434 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 6437 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6440 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 6443 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 6447 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 6450 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6453 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6456 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6459 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 6462 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6465 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6468 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 6471 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6474 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 6477 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 6480 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 6483 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQOrientationSensor : public  ::QOrientationSensor
{
public:
    sipQOrientationSensor( ::QObject*);
    virtual ~sipQOrientationSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQOrientationSensor(const sipQOrientationSensor &);
    sipQOrientationSensor &operator = (const sipQOrientationSensor &);

    char sipPyMethods[7];
};

sipQOrientationSensor::sipQOrientationSensor( ::QObject*a0):  ::QOrientationSensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQOrientationSensor::~sipQOrientationSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQOrientationSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QOrientationSensor);

    return  ::QOrientationSensor::metaObject();
}

int sipQOrientationSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QOrientationSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QOrientationSensor,_c,_id,_a);

    return _id;
}

void *sipQOrientationSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QOrientationSensor, _clname, &sipCpp) ? sipCpp :  ::QOrientationSensor::qt_metacast(_clname));
}

void sipQOrientationSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QOrientationSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQOrientationSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QOrientationSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQOrientationSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QOrientationSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQOrientationSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QOrientationSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQOrientationSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QOrientationSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQOrientationSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QOrientationSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQOrientationSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QOrientationSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QOrientationSensor_reading, "reading(self) -> QOrientationReading");

extern "C" {static PyObject *meth_QOrientationSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QOrientationSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QOrientationSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QOrientationSensor, &sipCpp))
        {
             ::QOrientationReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QOrientationReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QOrientationSensor, sipName_reading, doc_QOrientationSensor_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QOrientationSensor(void *, const sipTypeDef *);}
static void *cast_QOrientationSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QOrientationSensor *sipCpp = reinterpret_cast< ::QOrientationSensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QOrientationSensor(void *, int);}
static void release_QOrientationSensor(void *sipCppV, int)
{
     ::QOrientationSensor *sipCpp = reinterpret_cast< ::QOrientationSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QOrientationSensor(sipSimpleWrapper *);}
static void dealloc_QOrientationSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQOrientationSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QOrientationSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QOrientationSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QOrientationSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQOrientationSensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQOrientationSensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QOrientationSensor[] = {{56, 255, 1}};


static PyMethodDef methods_QOrientationSensor[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QOrientationSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QOrientationSensor_reading)}
};

PyDoc_STRVAR(doc_QOrientationSensor, "\1QOrientationSensor(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QOrientationSensor = {
    & ::QOrientationSensor::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QOrientationSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QOrientationSensor,
        {SIP_NULLPTR},
        &plugin_QOrientationSensor
    },
    {
        sipNameNr_QOrientationSensor,
        {0, 0, 1},
        1, methods_QOrientationSensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QOrientationSensor,
    -1,
    -1,
    supers_QOrientationSensor,
    SIP_NULLPTR,
    init_type_QOrientationSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QOrientationSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QOrientationSensor,
    cast_QOrientationSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 53 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qorientationsensor.sip"
#include <qorientationsensor.h>
#line 6842 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qorientationsensor.sip"
#include <qorientationsensor.h>
#line 6846 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQOrientationFilter : public  ::QOrientationFilter
{
public:
    sipQOrientationFilter();
    sipQOrientationFilter(const  ::QOrientationFilter&);
    virtual ~sipQOrientationFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QOrientationReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQOrientationFilter(const sipQOrientationFilter &);
    sipQOrientationFilter &operator = (const sipQOrientationFilter &);

    char sipPyMethods[1];
};

sipQOrientationFilter::sipQOrientationFilter():  ::QOrientationFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQOrientationFilter::sipQOrientationFilter(const  ::QOrientationFilter& a0):  ::QOrientationFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQOrientationFilter::~sipQOrientationFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQOrientationFilter::filter( ::QOrientationReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QOrientationFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QOrientationReading*);

    return sipVH_QtSensors_20(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QOrientationFilter_filter, "filter(self, QOrientationReading) -> bool");

extern "C" {static PyObject *meth_QOrientationFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QOrientationFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QOrientationReading* a0;
         ::QOrientationFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QOrientationFilter, &sipCpp, sipType_QOrientationReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QOrientationFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QOrientationFilter, sipName_filter, doc_QOrientationFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QOrientationFilter(void *, const sipTypeDef *);}
static void *cast_QOrientationFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QOrientationFilter *sipCpp = reinterpret_cast< ::QOrientationFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QOrientationFilter(void *, int);}
static void release_QOrientationFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQOrientationFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QOrientationFilter *>(sipCppV);
}


extern "C" {static void dealloc_QOrientationFilter(sipSimpleWrapper *);}
static void dealloc_QOrientationFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQOrientationFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QOrientationFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QOrientationFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QOrientationFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQOrientationFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQOrientationFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QOrientationFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QOrientationFilter, &a0))
        {
            sipCpp = new sipQOrientationFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QOrientationFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QOrientationFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QOrientationFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QOrientationFilter_filter)}
};

PyDoc_STRVAR(doc_QOrientationFilter, "\1QOrientationFilter()\n"
"QOrientationFilter(QOrientationFilter)");


static pyqt5ClassPluginDef plugin_QOrientationFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QOrientationFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QOrientationFilter,
        {SIP_NULLPTR},
        &plugin_QOrientationFilter
    },
    {
        sipNameNr_QOrientationFilter,
        {0, 0, 1},
        1, methods_QOrientationFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QOrientationFilter,
    -1,
    -1,
    supers_QOrientationFilter,
    SIP_NULLPTR,
    init_type_QOrientationFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QOrientationFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QOrientationFilter,
    cast_QOrientationFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qorientationsensor.sip"
#include <qorientationsensor.h>
#line 7083 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 7087 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 7090 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7093 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7096 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7099 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 7102 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 7105 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7108 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 7111 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7114 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 7117 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 7120 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 7123 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 7126 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 7129 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 7132 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


PyDoc_STRVAR(doc_QOrientationReading_orientation, "orientation(self) -> QOrientationReading.Orientation");

extern "C" {static PyObject *meth_QOrientationReading_orientation(PyObject *, PyObject *);}
static PyObject *meth_QOrientationReading_orientation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QOrientationReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QOrientationReading, &sipCpp))
        {
             ::QOrientationReading::Orientation sipRes;

            sipRes = sipCpp->orientation();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QOrientationReading_Orientation);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QOrientationReading, sipName_orientation, doc_QOrientationReading_orientation);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QOrientationReading_setOrientation, "setOrientation(self, QOrientationReading.Orientation)");

extern "C" {static PyObject *meth_QOrientationReading_setOrientation(PyObject *, PyObject *);}
static PyObject *meth_QOrientationReading_setOrientation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QOrientationReading::Orientation a0;
         ::QOrientationReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QOrientationReading, &sipCpp, sipType_QOrientationReading_Orientation, &a0))
        {
            sipCpp->setOrientation(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QOrientationReading, sipName_setOrientation, doc_QOrientationReading_setOrientation);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QOrientationReading(void *, const sipTypeDef *);}
static void *cast_QOrientationReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QOrientationReading *sipCpp = reinterpret_cast< ::QOrientationReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QOrientationReading(void *, int);}
static void release_QOrientationReading(void *sipCppV, int)
{
     ::QOrientationReading *sipCpp = reinterpret_cast< ::QOrientationReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QOrientationReading(sipSimpleWrapper *);}
static void dealloc_QOrientationReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QOrientationReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QOrientationReading[] = {{60, 255, 1}};


static PyMethodDef methods_QOrientationReading[] = {
    {SIP_MLNAME_CAST(sipName_orientation), meth_QOrientationReading_orientation, METH_VARARGS, SIP_MLDOC_CAST(doc_QOrientationReading_orientation)},
    {SIP_MLNAME_CAST(sipName_setOrientation), meth_QOrientationReading_setOrientation, METH_VARARGS, SIP_MLDOC_CAST(doc_QOrientationReading_setOrientation)}
};

static sipEnumMemberDef enummembers_QOrientationReading[] = {
    {sipName_FaceDown, static_cast<int>( ::QOrientationReading::FaceDown), 45},
    {sipName_FaceUp, static_cast<int>( ::QOrientationReading::FaceUp), 45},
    {sipName_LeftUp, static_cast<int>( ::QOrientationReading::LeftUp), 45},
    {sipName_RightUp, static_cast<int>( ::QOrientationReading::RightUp), 45},
    {sipName_TopDown, static_cast<int>( ::QOrientationReading::TopDown), 45},
    {sipName_TopUp, static_cast<int>( ::QOrientationReading::TopUp), 45},
    {sipName_Undefined, static_cast<int>( ::QOrientationReading::Undefined), 45},
};


static pyqt5ClassPluginDef plugin_QOrientationReading = {
    & ::QOrientationReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QOrientationReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QOrientationReading,
        {SIP_NULLPTR},
        &plugin_QOrientationReading
    },
    {
        sipNameNr_QOrientationReading,
        {0, 0, 1},
        2, methods_QOrientationReading,
        7, enummembers_QOrientationReading,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QOrientationReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QOrientationReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QOrientationReading,
    cast_QOrientationReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 61 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qmagnetometer.sip"
#include <qmagnetometer.h>
#line 7309 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 7313 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qmagnetometer.sip"
#include <qmagnetometer.h>
#line 7316 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 7319 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 7322 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7325 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7328 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 7331 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 7334 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7337 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 7340 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 7344 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 7347 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7350 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7353 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7356 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 7359 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7362 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 7365 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 7368 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 7371 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 7374 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 7377 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 7380 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQMagnetometer : public  ::QMagnetometer
{
public:
    sipQMagnetometer( ::QObject*);
    virtual ~sipQMagnetometer();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQMagnetometer(const sipQMagnetometer &);
    sipQMagnetometer &operator = (const sipQMagnetometer &);

    char sipPyMethods[7];
};

sipQMagnetometer::sipQMagnetometer( ::QObject*a0):  ::QMagnetometer(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQMagnetometer::~sipQMagnetometer()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQMagnetometer::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QMagnetometer);

    return  ::QMagnetometer::metaObject();
}

int sipQMagnetometer::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QMagnetometer::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QMagnetometer,_c,_id,_a);

    return _id;
}

void *sipQMagnetometer::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QMagnetometer, _clname, &sipCpp) ? sipCpp :  ::QMagnetometer::qt_metacast(_clname));
}

void sipQMagnetometer::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QMagnetometer::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQMagnetometer::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QMagnetometer::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQMagnetometer::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QMagnetometer::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQMagnetometer::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QMagnetometer::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQMagnetometer::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QMagnetometer::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQMagnetometer::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QMagnetometer::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQMagnetometer::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QMagnetometer::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QMagnetometer_reading, "reading(self) -> QMagnetometerReading");

extern "C" {static PyObject *meth_QMagnetometer_reading(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometer_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QMagnetometer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QMagnetometer, &sipCpp))
        {
             ::QMagnetometerReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QMagnetometerReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometer, sipName_reading, doc_QMagnetometer_reading);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QMagnetometer_returnGeoValues, "returnGeoValues(self) -> bool");

extern "C" {static PyObject *meth_QMagnetometer_returnGeoValues(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometer_returnGeoValues(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QMagnetometer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QMagnetometer, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->returnGeoValues();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometer, sipName_returnGeoValues, doc_QMagnetometer_returnGeoValues);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QMagnetometer_setReturnGeoValues, "setReturnGeoValues(self, bool)");

extern "C" {static PyObject *meth_QMagnetometer_setReturnGeoValues(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometer_setReturnGeoValues(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool a0;
         ::QMagnetometer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QMagnetometer, &sipCpp, &a0))
        {
            sipCpp->setReturnGeoValues(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometer, sipName_setReturnGeoValues, doc_QMagnetometer_setReturnGeoValues);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QMagnetometer(void *, const sipTypeDef *);}
static void *cast_QMagnetometer(void *sipCppV, const sipTypeDef *targetType)
{
     ::QMagnetometer *sipCpp = reinterpret_cast< ::QMagnetometer *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QMagnetometer(void *, int);}
static void release_QMagnetometer(void *sipCppV, int)
{
     ::QMagnetometer *sipCpp = reinterpret_cast< ::QMagnetometer *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QMagnetometer(sipSimpleWrapper *);}
static void dealloc_QMagnetometer(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQMagnetometer *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QMagnetometer(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QMagnetometer(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QMagnetometer(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQMagnetometer *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQMagnetometer(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QMagnetometer[] = {{56, 255, 1}};


static PyMethodDef methods_QMagnetometer[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QMagnetometer_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometer_reading)},
    {SIP_MLNAME_CAST(sipName_returnGeoValues), meth_QMagnetometer_returnGeoValues, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometer_returnGeoValues)},
    {SIP_MLNAME_CAST(sipName_setReturnGeoValues), meth_QMagnetometer_setReturnGeoValues, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometer_setReturnGeoValues)}
};

PyDoc_STRVAR(doc_QMagnetometer, "\1QMagnetometer(parent: QObject = None)");


/* Define this type's signals. */
static const pyqt5QtSignal signals_QMagnetometer[] = {
    {"returnGeoValuesChanged(bool)", "\1returnGeoValuesChanged(self, bool)", SIP_NULLPTR, SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


static pyqt5ClassPluginDef plugin_QMagnetometer = {
    & ::QMagnetometer::staticMetaObject,
    0,
    signals_QMagnetometer,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QMagnetometer = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QMagnetometer,
        {SIP_NULLPTR},
        &plugin_QMagnetometer
    },
    {
        sipNameNr_QMagnetometer,
        {0, 0, 1},
        3, methods_QMagnetometer,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QMagnetometer,
    -1,
    -1,
    supers_QMagnetometer,
    SIP_NULLPTR,
    init_type_QMagnetometer,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QMagnetometer,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QMagnetometer,
    cast_QMagnetometer,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 48 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qmagnetometer.sip"
#include <qmagnetometer.h>
#line 7804 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qmagnetometer.sip"
#include <qmagnetometer.h>
#line 7808 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQMagnetometerFilter : public  ::QMagnetometerFilter
{
public:
    sipQMagnetometerFilter();
    sipQMagnetometerFilter(const  ::QMagnetometerFilter&);
    virtual ~sipQMagnetometerFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QMagnetometerReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQMagnetometerFilter(const sipQMagnetometerFilter &);
    sipQMagnetometerFilter &operator = (const sipQMagnetometerFilter &);

    char sipPyMethods[1];
};

sipQMagnetometerFilter::sipQMagnetometerFilter():  ::QMagnetometerFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQMagnetometerFilter::sipQMagnetometerFilter(const  ::QMagnetometerFilter& a0):  ::QMagnetometerFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQMagnetometerFilter::~sipQMagnetometerFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQMagnetometerFilter::filter( ::QMagnetometerReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QMagnetometerFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_19(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QMagnetometerReading*);

    return sipVH_QtSensors_19(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QMagnetometerFilter_filter, "filter(self, QMagnetometerReading) -> bool");

extern "C" {static PyObject *meth_QMagnetometerFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometerFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QMagnetometerReading* a0;
         ::QMagnetometerFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QMagnetometerFilter, &sipCpp, sipType_QMagnetometerReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QMagnetometerFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometerFilter, sipName_filter, doc_QMagnetometerFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QMagnetometerFilter(void *, const sipTypeDef *);}
static void *cast_QMagnetometerFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QMagnetometerFilter *sipCpp = reinterpret_cast< ::QMagnetometerFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QMagnetometerFilter(void *, int);}
static void release_QMagnetometerFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQMagnetometerFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QMagnetometerFilter *>(sipCppV);
}


extern "C" {static void dealloc_QMagnetometerFilter(sipSimpleWrapper *);}
static void dealloc_QMagnetometerFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQMagnetometerFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QMagnetometerFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QMagnetometerFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QMagnetometerFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQMagnetometerFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQMagnetometerFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QMagnetometerFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QMagnetometerFilter, &a0))
        {
            sipCpp = new sipQMagnetometerFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QMagnetometerFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QMagnetometerFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QMagnetometerFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometerFilter_filter)}
};

PyDoc_STRVAR(doc_QMagnetometerFilter, "\1QMagnetometerFilter()\n"
"QMagnetometerFilter(QMagnetometerFilter)");


static pyqt5ClassPluginDef plugin_QMagnetometerFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QMagnetometerFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QMagnetometerFilter,
        {SIP_NULLPTR},
        &plugin_QMagnetometerFilter
    },
    {
        sipNameNr_QMagnetometerFilter,
        {0, 0, 1},
        1, methods_QMagnetometerFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QMagnetometerFilter,
    -1,
    -1,
    supers_QMagnetometerFilter,
    SIP_NULLPTR,
    init_type_QMagnetometerFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QMagnetometerFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QMagnetometerFilter,
    cast_QMagnetometerFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qmagnetometer.sip"
#include <qmagnetometer.h>
#line 8045 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 8049 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 8052 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 8055 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 8058 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 8061 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 8064 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 8067 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8070 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 8073 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8076 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 8079 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 8082 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 8085 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 8088 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 8091 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 8094 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


PyDoc_STRVAR(doc_QMagnetometerReading_x, "x(self) -> float");

extern "C" {static PyObject *meth_QMagnetometerReading_x(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometerReading_x(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QMagnetometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QMagnetometerReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->x();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometerReading, sipName_x, doc_QMagnetometerReading_x);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QMagnetometerReading_setX, "setX(self, float)");

extern "C" {static PyObject *meth_QMagnetometerReading_setX(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometerReading_setX(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QMagnetometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QMagnetometerReading, &sipCpp, &a0))
        {
            sipCpp->setX(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometerReading, sipName_setX, doc_QMagnetometerReading_setX);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QMagnetometerReading_y, "y(self) -> float");

extern "C" {static PyObject *meth_QMagnetometerReading_y(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometerReading_y(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QMagnetometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QMagnetometerReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->y();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometerReading, sipName_y, doc_QMagnetometerReading_y);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QMagnetometerReading_setY, "setY(self, float)");

extern "C" {static PyObject *meth_QMagnetometerReading_setY(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometerReading_setY(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QMagnetometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QMagnetometerReading, &sipCpp, &a0))
        {
            sipCpp->setY(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometerReading, sipName_setY, doc_QMagnetometerReading_setY);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QMagnetometerReading_z, "z(self) -> float");

extern "C" {static PyObject *meth_QMagnetometerReading_z(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometerReading_z(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QMagnetometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QMagnetometerReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->z();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometerReading, sipName_z, doc_QMagnetometerReading_z);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QMagnetometerReading_setZ, "setZ(self, float)");

extern "C" {static PyObject *meth_QMagnetometerReading_setZ(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometerReading_setZ(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QMagnetometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QMagnetometerReading, &sipCpp, &a0))
        {
            sipCpp->setZ(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometerReading, sipName_setZ, doc_QMagnetometerReading_setZ);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QMagnetometerReading_calibrationLevel, "calibrationLevel(self) -> float");

extern "C" {static PyObject *meth_QMagnetometerReading_calibrationLevel(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometerReading_calibrationLevel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QMagnetometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QMagnetometerReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->calibrationLevel();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometerReading, sipName_calibrationLevel, doc_QMagnetometerReading_calibrationLevel);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QMagnetometerReading_setCalibrationLevel, "setCalibrationLevel(self, float)");

extern "C" {static PyObject *meth_QMagnetometerReading_setCalibrationLevel(PyObject *, PyObject *);}
static PyObject *meth_QMagnetometerReading_setCalibrationLevel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QMagnetometerReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QMagnetometerReading, &sipCpp, &a0))
        {
            sipCpp->setCalibrationLevel(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QMagnetometerReading, sipName_setCalibrationLevel, doc_QMagnetometerReading_setCalibrationLevel);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QMagnetometerReading(void *, const sipTypeDef *);}
static void *cast_QMagnetometerReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QMagnetometerReading *sipCpp = reinterpret_cast< ::QMagnetometerReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QMagnetometerReading(void *, int);}
static void release_QMagnetometerReading(void *sipCppV, int)
{
     ::QMagnetometerReading *sipCpp = reinterpret_cast< ::QMagnetometerReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QMagnetometerReading(sipSimpleWrapper *);}
static void dealloc_QMagnetometerReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QMagnetometerReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QMagnetometerReading[] = {{60, 255, 1}};


static PyMethodDef methods_QMagnetometerReading[] = {
    {SIP_MLNAME_CAST(sipName_calibrationLevel), meth_QMagnetometerReading_calibrationLevel, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometerReading_calibrationLevel)},
    {SIP_MLNAME_CAST(sipName_setCalibrationLevel), meth_QMagnetometerReading_setCalibrationLevel, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometerReading_setCalibrationLevel)},
    {SIP_MLNAME_CAST(sipName_setX), meth_QMagnetometerReading_setX, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometerReading_setX)},
    {SIP_MLNAME_CAST(sipName_setY), meth_QMagnetometerReading_setY, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometerReading_setY)},
    {SIP_MLNAME_CAST(sipName_setZ), meth_QMagnetometerReading_setZ, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometerReading_setZ)},
    {SIP_MLNAME_CAST(sipName_x), meth_QMagnetometerReading_x, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometerReading_x)},
    {SIP_MLNAME_CAST(sipName_y), meth_QMagnetometerReading_y, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometerReading_y)},
    {SIP_MLNAME_CAST(sipName_z), meth_QMagnetometerReading_z, METH_VARARGS, SIP_MLDOC_CAST(doc_QMagnetometerReading_z)}
};


static pyqt5ClassPluginDef plugin_QMagnetometerReading = {
    & ::QMagnetometerReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QMagnetometerReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QMagnetometerReading,
        {SIP_NULLPTR},
        &plugin_QMagnetometerReading
    },
    {
        sipNameNr_QMagnetometerReading,
        {0, 0, 1},
        8, methods_QMagnetometerReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QMagnetometerReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QMagnetometerReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QMagnetometerReading,
    cast_QMagnetometerReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 55 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlightsensor.sip"
#include <qlightsensor.h>
#line 8435 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 8439 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlightsensor.sip"
#include <qlightsensor.h>
#line 8442 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 8445 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 8448 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8451 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8454 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 8457 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 8460 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8463 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 8466 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 8470 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 8473 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 8476 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 8479 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 8482 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 8485 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8488 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 8491 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 8494 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 8497 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 8500 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 8503 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 8506 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQLightSensor : public  ::QLightSensor
{
public:
    sipQLightSensor( ::QObject*);
    virtual ~sipQLightSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQLightSensor(const sipQLightSensor &);
    sipQLightSensor &operator = (const sipQLightSensor &);

    char sipPyMethods[7];
};

sipQLightSensor::sipQLightSensor( ::QObject*a0):  ::QLightSensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQLightSensor::~sipQLightSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQLightSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QLightSensor);

    return  ::QLightSensor::metaObject();
}

int sipQLightSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QLightSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QLightSensor,_c,_id,_a);

    return _id;
}

void *sipQLightSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QLightSensor, _clname, &sipCpp) ? sipCpp :  ::QLightSensor::qt_metacast(_clname));
}

void sipQLightSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QLightSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQLightSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QLightSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQLightSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QLightSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQLightSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QLightSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQLightSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QLightSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQLightSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QLightSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQLightSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QLightSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QLightSensor_reading, "reading(self) -> QLightReading");

extern "C" {static PyObject *meth_QLightSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QLightSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QLightSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QLightSensor, &sipCpp))
        {
             ::QLightReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QLightReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLightSensor, sipName_reading, doc_QLightSensor_reading);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QLightSensor_fieldOfView, "fieldOfView(self) -> float");

extern "C" {static PyObject *meth_QLightSensor_fieldOfView(PyObject *, PyObject *);}
static PyObject *meth_QLightSensor_fieldOfView(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QLightSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QLightSensor, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->fieldOfView();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLightSensor, sipName_fieldOfView, doc_QLightSensor_fieldOfView);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QLightSensor_setFieldOfView, "setFieldOfView(self, float)");

extern "C" {static PyObject *meth_QLightSensor_setFieldOfView(PyObject *, PyObject *);}
static PyObject *meth_QLightSensor_setFieldOfView(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QLightSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QLightSensor, &sipCpp, &a0))
        {
            sipCpp->setFieldOfView(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLightSensor, sipName_setFieldOfView, doc_QLightSensor_setFieldOfView);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QLightSensor(void *, const sipTypeDef *);}
static void *cast_QLightSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QLightSensor *sipCpp = reinterpret_cast< ::QLightSensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QLightSensor(void *, int);}
static void release_QLightSensor(void *sipCppV, int)
{
     ::QLightSensor *sipCpp = reinterpret_cast< ::QLightSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QLightSensor(sipSimpleWrapper *);}
static void dealloc_QLightSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQLightSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QLightSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QLightSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QLightSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQLightSensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQLightSensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QLightSensor[] = {{56, 255, 1}};


static PyMethodDef methods_QLightSensor[] = {
    {SIP_MLNAME_CAST(sipName_fieldOfView), meth_QLightSensor_fieldOfView, METH_VARARGS, SIP_MLDOC_CAST(doc_QLightSensor_fieldOfView)},
    {SIP_MLNAME_CAST(sipName_reading), meth_QLightSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QLightSensor_reading)},
    {SIP_MLNAME_CAST(sipName_setFieldOfView), meth_QLightSensor_setFieldOfView, METH_VARARGS, SIP_MLDOC_CAST(doc_QLightSensor_setFieldOfView)}
};

PyDoc_STRVAR(doc_QLightSensor, "\1QLightSensor(parent: QObject = None)");


/* Define this type's signals. */
static const pyqt5QtSignal signals_QLightSensor[] = {
    {"fieldOfViewChanged(qreal)", "\1fieldOfViewChanged(self, float)", SIP_NULLPTR, SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


static pyqt5ClassPluginDef plugin_QLightSensor = {
    & ::QLightSensor::staticMetaObject,
    0,
    signals_QLightSensor,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QLightSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QLightSensor,
        {SIP_NULLPTR},
        &plugin_QLightSensor
    },
    {
        sipNameNr_QLightSensor,
        {0, 0, 1},
        3, methods_QLightSensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QLightSensor,
    -1,
    -1,
    supers_QLightSensor,
    SIP_NULLPTR,
    init_type_QLightSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QLightSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QLightSensor,
    cast_QLightSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 42 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlightsensor.sip"
#include <qlightsensor.h>
#line 8930 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlightsensor.sip"
#include <qlightsensor.h>
#line 8934 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQLightFilter : public  ::QLightFilter
{
public:
    sipQLightFilter();
    sipQLightFilter(const  ::QLightFilter&);
    virtual ~sipQLightFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QLightReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQLightFilter(const sipQLightFilter &);
    sipQLightFilter &operator = (const sipQLightFilter &);

    char sipPyMethods[1];
};

sipQLightFilter::sipQLightFilter():  ::QLightFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQLightFilter::sipQLightFilter(const  ::QLightFilter& a0):  ::QLightFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQLightFilter::~sipQLightFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQLightFilter::filter( ::QLightReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QLightFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QLightReading*);

    return sipVH_QtSensors_18(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QLightFilter_filter, "filter(self, QLightReading) -> bool");

extern "C" {static PyObject *meth_QLightFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QLightFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QLightReading* a0;
         ::QLightFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QLightFilter, &sipCpp, sipType_QLightReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QLightFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLightFilter, sipName_filter, doc_QLightFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QLightFilter(void *, const sipTypeDef *);}
static void *cast_QLightFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QLightFilter *sipCpp = reinterpret_cast< ::QLightFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QLightFilter(void *, int);}
static void release_QLightFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQLightFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QLightFilter *>(sipCppV);
}


extern "C" {static void dealloc_QLightFilter(sipSimpleWrapper *);}
static void dealloc_QLightFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQLightFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QLightFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QLightFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QLightFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQLightFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQLightFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QLightFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QLightFilter, &a0))
        {
            sipCpp = new sipQLightFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QLightFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QLightFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QLightFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QLightFilter_filter)}
};

PyDoc_STRVAR(doc_QLightFilter, "\1QLightFilter()\n"
"QLightFilter(QLightFilter)");


static pyqt5ClassPluginDef plugin_QLightFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QLightFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QLightFilter,
        {SIP_NULLPTR},
        &plugin_QLightFilter
    },
    {
        sipNameNr_QLightFilter,
        {0, 0, 1},
        1, methods_QLightFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QLightFilter,
    -1,
    -1,
    supers_QLightFilter,
    SIP_NULLPTR,
    init_type_QLightFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QLightFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QLightFilter,
    cast_QLightFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlightsensor.sip"
#include <qlightsensor.h>
#line 9171 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 9175 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 9178 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 9181 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 9184 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 9187 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 9190 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 9193 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9196 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 9199 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9202 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 9205 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 9208 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 9211 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 9214 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 9217 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 9220 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


PyDoc_STRVAR(doc_QLightReading_lux, "lux(self) -> float");

extern "C" {static PyObject *meth_QLightReading_lux(PyObject *, PyObject *);}
static PyObject *meth_QLightReading_lux(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QLightReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QLightReading, &sipCpp))
        {
             ::qreal sipRes;

            sipRes = sipCpp->lux();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLightReading, sipName_lux, doc_QLightReading_lux);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QLightReading_setLux, "setLux(self, float)");

extern "C" {static PyObject *meth_QLightReading_setLux(PyObject *, PyObject *);}
static PyObject *meth_QLightReading_setLux(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qreal a0;
         ::QLightReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_QLightReading, &sipCpp, &a0))
        {
            sipCpp->setLux(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLightReading, sipName_setLux, doc_QLightReading_setLux);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QLightReading(void *, const sipTypeDef *);}
static void *cast_QLightReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QLightReading *sipCpp = reinterpret_cast< ::QLightReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QLightReading(void *, int);}
static void release_QLightReading(void *sipCppV, int)
{
     ::QLightReading *sipCpp = reinterpret_cast< ::QLightReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QLightReading(sipSimpleWrapper *);}
static void dealloc_QLightReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QLightReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QLightReading[] = {{60, 255, 1}};


static PyMethodDef methods_QLightReading[] = {
    {SIP_MLNAME_CAST(sipName_lux), meth_QLightReading_lux, METH_VARARGS, SIP_MLDOC_CAST(doc_QLightReading_lux)},
    {SIP_MLNAME_CAST(sipName_setLux), meth_QLightReading_setLux, METH_VARARGS, SIP_MLDOC_CAST(doc_QLightReading_setLux)}
};


static pyqt5ClassPluginDef plugin_QLightReading = {
    & ::QLightReading::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QLightReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QLightReading,
        {SIP_NULLPTR},
        &plugin_QLightReading
    },
    {
        sipNameNr_QLightReading,
        {0, 0, 1},
        2, methods_QLightReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QLightReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QLightReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QLightReading,
    cast_QLightReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 61 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlidsensor.sip"
#include <qlidsensor.h>
#line 9387 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 9391 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlidsensor.sip"
#include <qlidsensor.h>
#line 9394 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 9397 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 9400 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9403 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9406 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 9409 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 9412 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9415 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 9418 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 9422 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 9425 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 9428 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 9431 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 9434 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 9437 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9440 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 9443 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 9446 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 9449 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 9452 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 9455 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 9458 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQLidSensor : public  ::QLidSensor
{
public:
    sipQLidSensor( ::QObject*);
    virtual ~sipQLidSensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQLidSensor(const sipQLidSensor &);
    sipQLidSensor &operator = (const sipQLidSensor &);

    char sipPyMethods[7];
};

sipQLidSensor::sipQLidSensor( ::QObject*a0):  ::QLidSensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQLidSensor::~sipQLidSensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQLidSensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QLidSensor);

    return  ::QLidSensor::metaObject();
}

int sipQLidSensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QLidSensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QLidSensor,_c,_id,_a);

    return _id;
}

void *sipQLidSensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QLidSensor, _clname, &sipCpp) ? sipCpp :  ::QLidSensor::qt_metacast(_clname));
}

void sipQLidSensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QLidSensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQLidSensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QLidSensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQLidSensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QLidSensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQLidSensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QLidSensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQLidSensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QLidSensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQLidSensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QLidSensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQLidSensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QLidSensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QLidSensor_reading, "reading(self) -> QLidReading");

extern "C" {static PyObject *meth_QLidSensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QLidSensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QLidSensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QLidSensor, &sipCpp))
        {
             ::QLidReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QLidReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLidSensor, sipName_reading, doc_QLidSensor_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QLidSensor(void *, const sipTypeDef *);}
static void *cast_QLidSensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QLidSensor *sipCpp = reinterpret_cast< ::QLidSensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QLidSensor(void *, int);}
static void release_QLidSensor(void *sipCppV, int)
{
     ::QLidSensor *sipCpp = reinterpret_cast< ::QLidSensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QLidSensor(sipSimpleWrapper *);}
static void dealloc_QLidSensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQLidSensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QLidSensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QLidSensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QLidSensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQLidSensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQLidSensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QLidSensor[] = {{56, 255, 1}};


static PyMethodDef methods_QLidSensor[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QLidSensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QLidSensor_reading)}
};

PyDoc_STRVAR(doc_QLidSensor, "\1QLidSensor(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QLidSensor = {
    & ::QLidSensor::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QLidSensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QLidSensor,
        {SIP_NULLPTR},
        &plugin_QLidSensor
    },
    {
        sipNameNr_QLidSensor,
        {0, 0, 1},
        1, methods_QLidSensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QLidSensor,
    -1,
    -1,
    supers_QLidSensor,
    SIP_NULLPTR,
    init_type_QLidSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QLidSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QLidSensor,
    cast_QLidSensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 48 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlidsensor.sip"
#include <qlidsensor.h>
#line 9817 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlidsensor.sip"
#include <qlidsensor.h>
#line 9821 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQLidFilter : public  ::QLidFilter
{
public:
    sipQLidFilter();
    sipQLidFilter(const  ::QLidFilter&);
    virtual ~sipQLidFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool filter( ::QLidReading*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQLidFilter(const sipQLidFilter &);
    sipQLidFilter &operator = (const sipQLidFilter &);

    char sipPyMethods[1];
};

sipQLidFilter::sipQLidFilter():  ::QLidFilter(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQLidFilter::sipQLidFilter(const  ::QLidFilter& a0):  ::QLidFilter(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQLidFilter::~sipQLidFilter()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipQLidFilter::filter( ::QLidReading*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QLidFilter,sipName_filter);

    if (!sipMeth)
        return 0;

    extern bool sipVH_QtSensors_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QLidReading*);

    return sipVH_QtSensors_17(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QLidFilter_filter, "filter(self, QLidReading) -> bool");

extern "C" {static PyObject *meth_QLidFilter_filter(PyObject *, PyObject *);}
static PyObject *meth_QLidFilter_filter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QLidReading* a0;
         ::QLidFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QLidFilter, &sipCpp, sipType_QLidReading, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QLidFilter, sipName_filter);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->filter(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLidFilter, sipName_filter, doc_QLidFilter_filter);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QLidFilter(void *, const sipTypeDef *);}
static void *cast_QLidFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QLidFilter *sipCpp = reinterpret_cast< ::QLidFilter *>(sipCppV);

    if (targetType == sipType_QSensorFilter)
        return static_cast< ::QSensorFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QLidFilter(void *, int);}
static void release_QLidFilter(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQLidFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QLidFilter *>(sipCppV);
}


extern "C" {static void dealloc_QLidFilter(sipSimpleWrapper *);}
static void dealloc_QLidFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQLidFilter *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QLidFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QLidFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QLidFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQLidFilter *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipQLidFilter();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QLidFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QLidFilter, &a0))
        {
            sipCpp = new sipQLidFilter(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QLidFilter[] = {{59, 255, 1}};


static PyMethodDef methods_QLidFilter[] = {
    {SIP_MLNAME_CAST(sipName_filter), meth_QLidFilter_filter, METH_VARARGS, SIP_MLDOC_CAST(doc_QLidFilter_filter)}
};

PyDoc_STRVAR(doc_QLidFilter, "\1QLidFilter()\n"
"QLidFilter(QLidFilter)");


static pyqt5ClassPluginDef plugin_QLidFilter = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QLidFilter = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QLidFilter,
        {SIP_NULLPTR},
        &plugin_QLidFilter
    },
    {
        sipNameNr_QLidFilter,
        {0, 0, 1},
        1, methods_QLidFilter,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QLidFilter,
    -1,
    -1,
    supers_QLidFilter,
    SIP_NULLPTR,
    init_type_QLidFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QLidFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QLidFilter,
    cast_QLidFilter,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qlidsensor.sip"
#include <qlidsensor.h>
#line 10058 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 10062 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 10065 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10068 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10071 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10074 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 10077 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 10080 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 10083 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 10086 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 10089 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 10092 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 10095 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 10098 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 10101 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 10104 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 10107 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


PyDoc_STRVAR(doc_QLidReading_backLidClosed, "backLidClosed(self) -> bool");

extern "C" {static PyObject *meth_QLidReading_backLidClosed(PyObject *, PyObject *);}
static PyObject *meth_QLidReading_backLidClosed(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QLidReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QLidReading, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->backLidClosed();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLidReading, sipName_backLidClosed, doc_QLidReading_backLidClosed);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QLidReading_setBackLidClosed, "setBackLidClosed(self, bool)");

extern "C" {static PyObject *meth_QLidReading_setBackLidClosed(PyObject *, PyObject *);}
static PyObject *meth_QLidReading_setBackLidClosed(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool a0;
         ::QLidReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QLidReading, &sipCpp, &a0))
        {
            sipCpp->setBackLidClosed(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLidReading, sipName_setBackLidClosed, doc_QLidReading_setBackLidClosed);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QLidReading_frontLidClosed, "frontLidClosed(self) -> bool");

extern "C" {static PyObject *meth_QLidReading_frontLidClosed(PyObject *, PyObject *);}
static PyObject *meth_QLidReading_frontLidClosed(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QLidReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QLidReading, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->frontLidClosed();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLidReading, sipName_frontLidClosed, doc_QLidReading_frontLidClosed);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QLidReading_setFrontLidClosed, "setFrontLidClosed(self, bool)");

extern "C" {static PyObject *meth_QLidReading_setFrontLidClosed(PyObject *, PyObject *);}
static PyObject *meth_QLidReading_setFrontLidClosed(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool a0;
         ::QLidReading *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QLidReading, &sipCpp, &a0))
        {
            sipCpp->setFrontLidClosed(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QLidReading, sipName_setFrontLidClosed, doc_QLidReading_setFrontLidClosed);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QLidReading(void *, const sipTypeDef *);}
static void *cast_QLidReading(void *sipCppV, const sipTypeDef *targetType)
{
     ::QLidReading *sipCpp = reinterpret_cast< ::QLidReading *>(sipCppV);

    if (targetType == sipType_QSensorReading)
        return static_cast< ::QSensorReading *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QLidReading(void *, int);}
static void release_QLidReading(void *sipCppV, int)
{
     ::QLidReading *sipCpp = reinterpret_cast< ::QLidReading *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QLidReading(sipSimpleWrapper *);}
static void dealloc_QLidReading(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QLidReading(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QLidReading[] = {{60, 255, 1}};


static PyMethodDef methods_QLidReading[] = {
    {SIP_MLNAME_CAST(sipName_backLidClosed), meth_QLidReading_backLidClosed, METH_VARARGS, SIP_MLDOC_CAST(doc_QLidReading_backLidClosed)},
    {SIP_MLNAME_CAST(sipName_frontLidClosed), meth_QLidReading_frontLidClosed, METH_VARARGS, SIP_MLDOC_CAST(doc_QLidReading_frontLidClosed)},
    {SIP_MLNAME_CAST(sipName_setBackLidClosed), meth_QLidReading_setBackLidClosed, METH_VARARGS, SIP_MLDOC_CAST(doc_QLidReading_setBackLidClosed)},
    {SIP_MLNAME_CAST(sipName_setFrontLidClosed), meth_QLidReading_setFrontLidClosed, METH_VARARGS, SIP_MLDOC_CAST(doc_QLidReading_setFrontLidClosed)}
};


/* Define this type's signals. */
static const pyqt5QtSignal signals_QLidReading[] = {
    {"frontLidChanged(bool)", "\1frontLidChanged(self, bool)", SIP_NULLPTR, SIP_NULLPTR},
    {"backLidChanged(bool)", "\1backLidChanged(self, bool)", SIP_NULLPTR, SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


static pyqt5ClassPluginDef plugin_QLidReading = {
    & ::QLidReading::staticMetaObject,
    0,
    signals_QLidReading,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QLidReading = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QLidReading,
        {SIP_NULLPTR},
        &plugin_QLidReading
    },
    {
        sipNameNr_QLidReading,
        {0, 0, 1},
        4, methods_QLidReading,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    supers_QLidReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QLidReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QLidReading,
    cast_QLidReading,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 55 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qirproximitysensor.sip"
#include <qirproximitysensor.h>
#line 10340 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 10344 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qirproximitysensor.sip"
#include <qirproximitysensor.h>
#line 10347 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 85 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 10350 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 10353 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 10356 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 10359 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 10362 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 10365 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 10368 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtSensors/qsensor.sip"
#include <qsensor.h>
#line 10371 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 460 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 10375 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 10378 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10381 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10384 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 10387 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 10390 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 10393 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 10396 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 10399 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 10402 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 10405 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 10408 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 10411 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtSensors/sipQtSensorspart0.cpp"


class sipQIRProximitySensor : public  ::QIRProximitySensor
{
public:
    sipQIRProximitySensor( ::QObject*);
    virtual ~sipQIRProximitySensor();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQIRProximitySensor(const sipQIRProximitySensor &);
    sipQIRProximitySensor &operator = (const sipQIRProximitySensor &);

    char sipPyMethods[7];
};

sipQIRProximitySensor::sipQIRProximitySensor( ::QObject*a0):  ::QIRProximitySensor(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQIRProximitySensor::~sipQIRProximitySensor()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQIRProximitySensor::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtSensors_qt_metaobject(sipPySelf,sipType_QIRProximitySensor);

    return  ::QIRProximitySensor::metaObject();
}

int sipQIRProximitySensor::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QIRProximitySensor::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtSensors_qt_metacall(sipPySelf,sipType_QIRProximitySensor,_c,_id,_a);

    return _id;
}

void *sipQIRProximitySensor::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtSensors_qt_metacast(sipPySelf, sipType_QIRProximitySensor, _clname, &sipCpp) ? sipCpp :  ::QIRProximitySensor::qt_metacast(_clname));
}

void sipQIRProximitySensor::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QIRProximitySensor::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQIRProximitySensor::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QIRProximitySensor::connectNotify(a0);
        return;
    }

    extern void sipVH_QtSensors_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtSensors_0(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQIRProximitySensor::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QIRProximitySensor::customEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtSensors_1(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQIRProximitySensor::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QIRProximitySensor::childEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtSensors_2(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQIRProximitySensor::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QIRProximitySensor::timerEvent(a0);
        return;
    }

    extern void sipVH_QtSensors_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtSensors_3(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQIRProximitySensor::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QIRProximitySensor::eventFilter(a0,a1);

    extern bool sipVH_QtSensors_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtSensors_4(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQIRProximitySensor::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QIRProximitySensor::event(a0);

    extern bool sipVH_QtSensors_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtSensors_5(sipGILState, sipImportedVirtErrorHandlers_QtSensors_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QIRProximitySensor_reading, "reading(self) -> QIRProximityReading");

extern "C" {static PyObject *meth_QIRProximitySensor_reading(PyObject *, PyObject *);}
static PyObject *meth_QIRProximitySensor_reading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QIRProximitySensor *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QIRProximitySensor, &sipCpp))
        {
             ::QIRProximityReading*sipRes;

            sipRes = sipCpp->reading();

            return sipConvertFromType(sipRes,sipType_QIRProximityReading,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QIRProximitySensor, sipName_reading, doc_QIRProximitySensor_reading);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QIRProximitySensor(void *, const sipTypeDef *);}
static void *cast_QIRProximitySensor(void *sipCppV, const sipTypeDef *targetType)
{
     ::QIRProximitySensor *sipCpp = reinterpret_cast< ::QIRProximitySensor *>(sipCppV);

    if (targetType == sipType_QSensor)
        return static_cast< ::QSensor *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QIRProximitySensor(void *, int);}
static void release_QIRProximitySensor(void *sipCppV, int)
{
     ::QIRProximitySensor *sipCpp = reinterpret_cast< ::QIRProximitySensor *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QIRProximitySensor(sipSimpleWrapper *);}
static void dealloc_QIRProximitySensor(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQIRProximitySensor *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QIRProximitySensor(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QIRProximitySensor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QIRProximitySensor(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQIRProximitySensor *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQIRProximitySensor(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QIRProximitySensor[] = {{56, 255, 1}};


static PyMethodDef methods_QIRProximitySensor[] = {
    {SIP_MLNAME_CAST(sipName_reading), meth_QIRProximitySensor_reading, METH_VARARGS, SIP_MLDOC_CAST(doc_QIRProximitySensor_reading)}
};

PyDoc_STRVAR(doc_QIRProximitySensor, "\1QIRProximitySensor(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QIRProximitySensor = {
    & ::QIRProximitySensor::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtSensors_QIRProximitySensor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QIRProximitySensor,
        {SIP_NULLPTR},
        &plugin_QIRProximitySensor
    },
    {
        sipNameNr_QIRProximitySensor,
        {0, 0, 1},
        1, methods_QIRProximitySensor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QIRProximitySensor,
    -1,
    -1,
    supers_QIRProximitySensor,
    SIP_NULLPTR,
    init_type_QIRProximitySensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QIRProximitySensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QIRProximitySensor,
    cast_QIRProximitySensor,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};
