/*
 * Module code.
 *
 * Generated by SIP 4.19.15
 *
 * Copyright (c) 2019 Riverbank Computing Limited <info@riverbankcomputing.com>
 * 
 * This file is part of PyQt5.
 * 
 * This file may be used under the terms of the GNU General Public License
 * version 3.0 as published by the Free Software Foundation and appearing in
 * the file LICENSE included in the packaging of this file.  Please review the
 * following information to ensure the GNU General Public License version 3.0
 * requirements will be met: http://www.gnu.org/copyleft/gpl.html.
 * 
 * If you do not wish to use this file under the terms of the GPL version 3.0
 * then you may purchase a commercial license.  For more information contact
 * info@riverbankcomputing.com.
 * 
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "sipAPIQtNetwork.h"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhostaddress.sip"
#include <qhostaddress.h>
#line 32 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 35 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhstspolicy.sip"
#include <qhstspolicy.h>
#line 38 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qlocalserver.sip"
#include <qlocalserver.h>
#line 41 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkconfigmanager.sip"
#include <qnetworkconfigmanager.h>
#line 44 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 86 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkinterface.sip"
#include <qnetworkinterface.h>
#line 47 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 50 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 53 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 56 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 59 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 62 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractnetworkcache.sip"
#include <qabstractnetworkcache.h>
#line 65 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 96 "sip/QtCore/qurl.sip"
#include <qurl.h>
#line 68 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qiodevice.sip"
#include <qiodevice.h>
#line 71 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qiodevice.sip"
#include <qiodevice.h>
#line 74 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 77 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 160 "sip/QtCore/qglobal.sip"
#include <QtGlobal>
#line 80 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 83 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qlocalsocket.sip"
#include <qlocalsocket.h>
#line 86 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 189 "sip/QtCore/qglobal.sip"
#include <QtGlobal>
#line 89 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkreply.sip"
#include <qnetworkreply.h>
#line 92 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkaccessmanager.sip"
#include <qnetworkaccessmanager.h>
#line 95 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkrequest.sip"
#include <qnetworkrequest.h>
#line 98 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 101 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkcookie.sip"
#include <qnetworkcookie.h>
#line 104 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 107 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkproxy.sip"
#include <qnetworkproxy.h>
#line 110 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 91 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkproxy.sip"
#include <qnetworkproxy.h>
#line 113 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslconfiguration.sip"
#include <qsslconfiguration.h>
#line 116 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 119 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslerror.sip"
#include <qsslerror.h>
#line 122 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qtcpsocket.sip"
#include <qtcpsocket.h>
#line 125 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qdatastream.sip"
#include <qdatastream.h>
#line 128 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 131 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 134 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qauthenticator.sip"
#include <qauthenticator.h>
#line 137 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qdnslookup.sip"
#include <qdnslookup.h>
#line 140 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 42 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qdnslookup.sip"
#include <qdnslookup.h>
#line 143 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 58 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qdnslookup.sip"
#include <qdnslookup.h>
#line 146 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 75 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qdnslookup.sip"
#include <qdnslookup.h>
#line 149 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 94 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qdnslookup.sip"
#include <qdnslookup.h>
#line 152 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhostaddress.sip"
#include <qhostaddress.h>
#line 155 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhostinfo.sip"
#include <qhostinfo.h>
#line 158 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhstspolicy.sip"
#include <qhstspolicy.h>
#line 161 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhttpmultipart.sip"
#include <qhttpmultipart.h>
#line 164 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qlocalserver.sip"
#include <qlocalserver.h>
#line 167 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkconfigmanager.sip"
#include <qnetworkconfigmanager.h>
#line 170 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkconfiguration.sip"
#include <qnetworkconfiguration.h>
#line 173 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkconfiguration.sip"
#include <qnetworkconfiguration.h>
#line 176 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkdatagram.sip"
#include <qnetworkdatagram.h>
#line 179 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkinterface.sip"
#include <qnetworkinterface.h>
#line 182 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 86 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkinterface.sip"
#include <qnetworkinterface.h>
#line 185 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkproxy.sip"
#include <qnetworkproxy.h>
#line 188 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworksession.sip"
#include <qnetworksession.h>
#line 191 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 194 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcertificate.sip"
#include <qsslcertificate.h>
#line 197 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcertificateextension.sip"
#include <qsslcertificateextension.h>
#line 200 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcipher.sip"
#include <qsslcipher.h>
#line 203 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssldiffiehellmanparameters.sip"
#include <qssldiffiehellmanparameters.h>
#line 206 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslellipticcurve.sip"
#include <qsslellipticcurve.h>
#line 209 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslkey.sip"
#include <qsslkey.h>
#line 212 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslpresharedkeyauthenticator.sip"
#include <qsslpresharedkeyauthenticator.h>
#line 215 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

/* Define the strings used by this module. */
const char sipStrings_QtNetwork[] = {
    'Q', 'M', 'u', 'l', 't', 'i', 'M', 'a', 'p', '<', 'Q', 'S', 's', 'l', ':', ':', 'A', 'l', 't', 'e', 'r', 'n', 'a', 't', 'i', 'v', 'e', 'N', 'a', 'm', 'e', 'E', 'n', 't', 'r', 'y', 'T', 'y', 'p', 'e', ',', 'Q', 'S', 't', 'r', 'i', 'n', 'g', '>', 0,
    'Q', 'S', 's', 'l', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', ':', ':', 'N', 'e', 'x', 't', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'N', 'e', 'g', 'o', 't', 'i', 'a', 't', 'i', 'o', 'n', 'S', 't', 'a', 't', 'u', 's', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'A', 'c', 'c', 'e', 's', 's', 'M', 'a', 'n', 'a', 'g', 'e', 'r', ':', ':', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'A', 'c', 'c', 'e', 's', 's', 'i', 'b', 'i', 'l', 'i', 't', 'y', 0,
    'Q', 'H', 'a', 's', 'h', '<', 'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'R', 'e', 'q', 'u', 'e', 's', 't', ':', ':', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', ',', 'Q', 'V', 'a', 'r', 'i', 'a', 'n', 't', '>', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'A', 'd', 'd', 'r', 'e', 's', 's', 'E', 'n', 't', 'r', 'y', ':', ':', 'D', 'n', 's', 'E', 'l', 'i', 'g', 'i', 'b', 'i', 'l', 'i', 't', 'y', 'S', 't', 'a', 't', 'u', 's', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'M', 'a', 'n', 'a', 'g', 'e', 'r', ':', ':', 'C', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'i', 'e', 's', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'M', 'a', 'n', 'a', 'g', 'e', 'r', ':', ':', 'C', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'y', 0,
    'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 'D', 'i', 's', 'a', 'b', 'l', 'e', 'S', 'e', 'r', 'v', 'e', 'r', 'C', 'i', 'p', 'h', 'e', 'r', 'P', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', 0,
    'E', 'm', 'i', 't', 'A', 'l', 'l', 'U', 'p', 'l', 'o', 'a', 'd', 'P', 'r', 'o', 'g', 'r', 'e', 's', 's', 'S', 'i', 'g', 'n', 'a', 'l', 's', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'i', 's', 'S', 't', 'r', 'i', 'c', 't', 'T', 'r', 'a', 'n', 's', 'p', 'o', 'r', 't', 'S', 'e', 'c', 'u', 'r', 'i', 't', 'y', 'S', 't', 'o', 'r', 'e', 'E', 'n', 'a', 'b', 'l', 'e', 'd', 0,
    'Q', 'A', 'b', 's', 't', 'r', 'a', 'c', 't', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'L', 'a', 'y', 'e', 'r', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'P', 'a', 'i', 'r', '<', 'Q', 'B', 'y', 't', 'e', 'A', 'r', 'r', 'a', 'y', ',', 'Q', 'B', 'y', 't', 'e', 'A', 'r', 'r', 'a', 'y', '>', ' ', '>', 0,
    'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 'D', 'i', 's', 'a', 'b', 'l', 'e', 'S', 'e', 'r', 'v', 'e', 'r', 'N', 'a', 'm', 'e', 'I', 'n', 'd', 'i', 'c', 'a', 't', 'i', 'o', 'n', 0,
    'A', 'u', 't', 'h', 'o', 'r', 'i', 't', 'y', 'I', 's', 's', 'u', 'e', 'r', 'S', 'e', 'r', 'i', 'a', 'l', 'N', 'u', 'm', 'b', 'e', 'r', 'M', 'i', 's', 'm', 'a', 't', 'c', 'h', 0,
    'U', 'n', 'a', 'b', 'l', 'e', 'T', 'o', 'D', 'e', 'c', 'r', 'y', 'p', 't', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'S', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', 0,
    'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 'D', 'i', 's', 'a', 'b', 'l', 'e', 'L', 'e', 'g', 'a', 'c', 'y', 'R', 'e', 'n', 'e', 'g', 'o', 't', 'i', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'S', 's', 'l', 'D', 'i', 'f', 'f', 'i', 'e', 'H', 'e', 'l', 'l', 'm', 'a', 'n', 'P', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', 's', ':', ':', 'E', 'r', 'r', 'o', 'r', 0,
    'N', 'e', 'x', 't', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'N', 'e', 'g', 'o', 't', 'i', 'a', 't', 'i', 'o', 'n', 'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 0,
    'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 'D', 'i', 's', 'a', 'b', 'l', 'e', 'S', 'e', 's', 's', 'i', 'o', 'n', 'P', 'e', 'r', 's', 'i', 's', 't', 'e', 'n', 'c', 'e', 0,
    'e', 'n', 'a', 'b', 'l', 'e', 'S', 't', 'r', 'i', 'c', 't', 'T', 'r', 'a', 'n', 's', 'p', 'o', 'r', 't', 'S', 'e', 'c', 'u', 'r', 'i', 't', 'y', 'S', 't', 'o', 'r', 'e', 0,
    'p', 'r', 'e', 'S', 'h', 'a', 'r', 'e', 'd', 'K', 'e', 'y', 'A', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'R', 'e', 'q', 'u', 'i', 'r', 'e', 'd', 0,
    'U', 'n', 'a', 'b', 'l', 'e', 'T', 'o', 'G', 'e', 't', 'L', 'o', 'c', 'a', 'l', 'I', 's', 's', 'u', 'e', 'r', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    'N', 'e', 'x', 't', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'N', 'e', 'g', 'o', 't', 'i', 'a', 't', 'i', 'o', 'n', 'N', 'e', 'g', 'o', 't', 'i', 'a', 't', 'e', 'd', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'R', 'e', 'q', 'u', 'e', 's', 't', ':', ':', 'C', 'a', 'c', 'h', 'e', 'L', 'o', 'a', 'd', 'C', 'o', 'n', 't', 'r', 'o', 'l', 0,
    's', 'e', 't', 'S', 's', 'l', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'I', 'm', 'p', 'l', 'e', 'm', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'C', 'o', 'n', 't', 'e', 'n', 't', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'N', 'o', 't', 'P', 'e', 'r', 'm', 'i', 't', 't', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', ':', ':', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 'F', 'l', 'a', 'g', 's', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', ':', ':', 'B', 'e', 'a', 'r', 'e', 'r', 'T', 'y', 'p', 'e', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', ':', ':', 'S', 't', 'a', 't', 'e', 'F', 'l', 'a', 'g', 's', 0,
    's', 'e', 't', 'S', 't', 'r', 'i', 'c', 't', 'T', 'r', 'a', 'n', 's', 'p', 'o', 'r', 't', 'S', 'e', 'c', 'u', 'r', 'i', 't', 'y', 'E', 'n', 'a', 'b', 'l', 'e', 'd', 0,
    'B', 'a', 'c', 'k', 'g', 'r', 'o', 'u', 'n', 'd', 'R', 'e', 'q', 'u', 'e', 's', 't', 'N', 'o', 't', 'A', 'l', 'l', 'o', 'w', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', ':', ':', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 'T', 'y', 'p', 'e', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', ':', ':', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 'F', 'l', 'a', 'g', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', ':', ':', 'S', 't', 'a', 't', 'e', 'F', 'l', 'a', 'g', 0,
    'i', 's', 'S', 't', 'r', 'i', 'c', 't', 'T', 'r', 'a', 'n', 's', 'p', 'o', 'r', 't', 'S', 'e', 'c', 'u', 'r', 'i', 't', 'y', 'E', 'n', 'a', 'b', 'l', 'e', 'd', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'A', 'c', 'c', 'e', 's', 's', 'M', 'a', 'n', 'a', 'g', 'e', 'r', ':', ':', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'H', 'o', 's', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', ':', ':', 'C', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', 'M', 'o', 'd', 'e', 'F', 'l', 'a', 'g', 0,
    'P', 'r', 'o', 'x', 'y', 'A', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'R', 'e', 'q', 'u', 'i', 'r', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'S', 's', 'l', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'E', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', '>', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'R', 'e', 'q', 'u', 'e', 's', 't', ':', ':', 'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'P', 'o', 'l', 'i', 'c', 'y', 0,
    'a', 'd', 'd', 'S', 't', 'r', 'i', 'c', 't', 'T', 'r', 'a', 'n', 's', 'p', 'o', 'r', 't', 'S', 'e', 'c', 'u', 'r', 'i', 't', 'y', 'H', 'o', 's', 't', 's', 0,
    'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 'S', 'o', 'c', 'k', 'e', 't', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'E', 'r', 'r', 'o', 'r', 0,
    'U', 'n', 'a', 'b', 'l', 'e', 'T', 'o', 'V', 'e', 'r', 'i', 'f', 'y', 'F', 'i', 'r', 's', 't', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 'D', 'i', 's', 'a', 'b', 'l', 'e', 'S', 'e', 's', 's', 'i', 'o', 'n', 'S', 'h', 'a', 'r', 'i', 'n', 'g', 0,
    'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 'D', 'i', 's', 'a', 'b', 'l', 'e', 'S', 'e', 's', 's', 'i', 'o', 'n', 'T', 'i', 'c', 'k', 'e', 't', 's', 0,
    'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 'D', 'i', 's', 'a', 'b', 'l', 'e', 'E', 'm', 'p', 't', 'y', 'F', 'r', 'a', 'g', 'm', 'e', 'n', 't', 's', 0,
    'Q', 'S', 's', 'l', ':', ':', 'A', 'l', 't', 'e', 'r', 'n', 'a', 't', 'i', 'v', 'e', 'N', 'a', 'm', 'e', 'E', 'n', 't', 'r', 'y', 'T', 'y', 'p', 'e', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'S', 'e', 's', 's', 'i', 'o', 'n', ':', ':', 'U', 's', 'a', 'g', 'e', 'P', 'o', 'l', 'i', 'c', 'i', 'e', 's', 0,
    'O', 'r', 'i', 'g', 'i', 'n', 'a', 'l', 'C', 'o', 'n', 't', 'e', 'n', 't', 'L', 'e', 'n', 'g', 't', 'h', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'H', 't', 't', 'p', 'P', 'i', 'p', 'e', 'l', 'i', 'n', 'i', 'n', 'g', 'W', 'a', 's', 'U', 's', 'e', 'd', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'H', 't', 't', 'p', 'P', 'i', 'p', 'e', 'l', 'i', 'n', 'i', 'n', 'g', 'A', 'l', 'l', 'o', 'w', 'e', 'd', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'D', 'o', 'N', 'o', 't', 'B', 'u', 'f', 'f', 'e', 'r', 'U', 'p', 'l', 'o', 'a', 'd', 'D', 'a', 't', 'a', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    's', 's', 'l', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'I', 'm', 'p', 'l', 'e', 'm', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', ':', ':', 'P', 'u', 'r', 'p', 'o', 's', 'e', 0,
    's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 'S', 'c', 'h', 'e', 'm', 'e', 's', 'I', 'm', 'p', 'l', 'e', 'm', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'L', 'o', 'c', 'a', 'l', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'L', 'o', 'c', 'a', 'l', 'S', 'o', 'c', 'k', 'e', 't', 'S', 't', 'a', 't', 'e', 0,
    'Q', 'L', 'o', 'c', 'a', 'l', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'L', 'o', 'c', 'a', 'l', 'S', 'o', 'c', 'k', 'e', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'U', 'n', 'f', 'i', 'n', 'i', 's', 'h', 'e', 'd', 'S', 'o', 'c', 'k', 'e', 't', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'E', 'r', 'r', 'o', 'r', 0,
    'S', 'o', 'c', 'k', 'e', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', 'N', 'o', 't', 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'D', 'n', 's', 'M', 'a', 'i', 'l', 'E', 'x', 'c', 'h', 'a', 'n', 'g', 'e', 'R', 'e', 'c', 'o', 'r', 'd', '>', 0,
    'Q', 'S', 's', 'l', 'P', 'r', 'e', 'S', 'h', 'a', 'r', 'e', 'd', 'K', 'e', 'y', 'A', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'o', 'r', 0,
    'U', 'n', 'a', 'b', 'l', 'e', 'T', 'o', 'D', 'e', 'c', 'o', 'd', 'e', 'I', 's', 's', 'u', 'e', 'r', 'P', 'u', 'b', 'l', 'i', 'c', 'K', 'e', 'y', 0,
    's', 'e', 't', 'B', 'a', 'c', 'k', 'e', 'n', 'd', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'n', 'e', 'x', 't', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'N', 'e', 'g', 'o', 't', 'i', 'a', 't', 'i', 'o', 'n', 'S', 't', 'a', 't', 'u', 's', 0,
    'p', 'r', 'e', 'f', 'e', 'r', 'r', 'e', 'd', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'S', 'e', 's', 's', 'i', 'o', 'n', ':', ':', 'S', 'e', 's', 's', 'i', 'o', 'n', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'R', 'e', 'q', 'u', 'e', 's', 't', ':', ':', 'K', 'n', 'o', 'w', 'n', 'H', 'e', 'a', 'd', 'e', 'r', 's', 0,
    'i', 'g', 'n', 'o', 'r', 'e', 'S', 's', 'l', 'E', 'r', 'r', 'o', 'r', 's', 'I', 'm', 'p', 'l', 'e', 'm', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', 0,
    'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'I', 'n', 'v', 'a', 'l', 'i', 'd', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'P', 'r', 'o', 'x', 'y', 'Q', 'u', 'e', 'r', 'y', ':', ':', 'Q', 'u', 'e', 'r', 'y', 'T', 'y', 'p', 'e', 0,
    'R', 'e', 'c', 'e', 'i', 'v', 'e', 'B', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 'S', 'o', 'c', 'k', 'e', 't', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'Q', 'A', 'b', 's', 't', 'r', 'a', 'c', 't', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'S', 'o', 'c', 'k', 'e', 't', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', '>', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'D', 'n', 's', 'H', 'o', 's', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', 'R', 'e', 'c', 'o', 'r', 'd', '>', 0,
    's', 's', 'l', 'L', 'i', 'b', 'r', 'a', 'r', 'y', 'B', 'u', 'i', 'l', 'd', 'V', 'e', 'r', 's', 'i', 'o', 'n', 'S', 't', 'r', 'i', 'n', 'g', 0,
    's', 's', 'l', 'L', 'i', 'b', 'r', 'a', 'r', 'y', 'B', 'u', 'i', 'l', 'd', 'V', 'e', 'r', 's', 'i', 'o', 'n', 'N', 'u', 'm', 'b', 'e', 'r', 0,
    'S', 'e', 'l', 'f', 'S', 'i', 'g', 'n', 'e', 'd', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'I', 'n', 'C', 'h', 'a', 'i', 'n', 0,
    'U', 'n', 'a', 'b', 'l', 'e', 'T', 'o', 'G', 'e', 't', 'I', 's', 's', 'u', 'e', 'r', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    'Q', 'S', 's', 'l', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ':', ':', 'S', 'u', 'b', 'j', 'e', 'c', 't', 'I', 'n', 'f', 'o', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'S', 'e', 's', 's', 'i', 'o', 'n', ':', ':', 'U', 's', 'a', 'g', 'e', 'P', 'o', 'l', 'i', 'c', 'y', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'R', 'e', 'q', 'u', 'e', 's', 't', ':', ':', 'L', 'o', 'a', 'd', 'C', 'o', 'n', 't', 'r', 'o', 'l', 0,
    'A', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'R', 'e', 'u', 's', 'e', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 'E', 'n', 'c', 'r', 'y', 'p', 't', 'e', 'd', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'N', 'o', 't', 'I', 'm', 'p', 'l', 'e', 'm', 'e', 'n', 't', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'T', 'e', 'm', 'p', 'o', 'r', 'a', 'r', 'y', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'F', 'a', 'i', 'l', 'u', 'r', 'e', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'M', 'a', 'n', 'a', 'g', 'e', 'r', 0,
    's', 't', 'r', 'i', 'c', 't', 'T', 'r', 'a', 'n', 's', 'p', 'o', 'r', 't', 'S', 'e', 'c', 'u', 'r', 'i', 't', 'y', 'H', 'o', 's', 't', 's', 0,
    'Q', 'H', 'o', 's', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', ':', ':', 'C', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', 'M', 'o', 'd', 'e', 0,
    'Q', 'H', 'o', 's', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', ':', ':', 'S', 'p', 'e', 'c', 'i', 'a', 'l', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'Q', 'A', 'b', 's', 't', 'r', 'a', 'c', 't', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'S', 'o', 'c', 'k', 'e', 't', 'S', 't', 'a', 't', 'e', 0,
    'Q', 'A', 'b', 's', 't', 'r', 'a', 'c', 't', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'S', 'o', 'c', 'k', 'e', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'A', 'd', 'd', 'r', 'e', 's', 's', 'E', 'n', 't', 'r', 'y', '>', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'D', 'n', 's', 'D', 'o', 'm', 'a', 'i', 'n', 'N', 'a', 'm', 'e', 'R', 'e', 'c', 'o', 'r', 'd', '>', 0,
    'Q', 'S', 's', 'l', 'D', 'i', 'f', 'f', 'i', 'e', 'H', 'e', 'l', 'l', 'm', 'a', 'n', 'P', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', 's', 0,
    's', 'e', 't', 'P', 'r', 'e', 'S', 'h', 'a', 'r', 'e', 'd', 'K', 'e', 'y', 'I', 'd', 'e', 'n', 't', 'i', 't', 'y', 'H', 'i', 'n', 't', 0,
    'N', 'e', 'x', 't', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'N', 'e', 'g', 'o', 't', 'i', 'a', 't', 'i', 'o', 'n', 'N', 'o', 'n', 'e', 0,
    'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 'D', 'i', 's', 'a', 'b', 'l', 'e', 'C', 'o', 'm', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'R', 'e', 'p', 'l', 'y', ':', ':', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'P', 'r', 'o', 'x', 'y', ':', ':', 'C', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'i', 'e', 's', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', ':', ':', 'T', 'y', 'p', 'e', 0,
    'c', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'F', 'r', 'o', 'm', 'I', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', 0,
    'Q', 'L', 'o', 'c', 'a', 'l', 'S', 'e', 'r', 'v', 'e', 'r', ':', ':', 'S', 'o', 'c', 'k', 'e', 't', 'O', 'p', 't', 'i', 'o', 'n', 's', 0,
    'Q', 'H', 't', 't', 'p', 'M', 'u', 'l', 't', 'i', 'P', 'a', 'r', 't', ':', ':', 'C', 'o', 'n', 't', 'e', 'n', 't', 'T', 'y', 'p', 'e', 0,
    'Q', 'A', 'b', 's', 't', 'r', 'a', 'c', 't', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'P', 'a', 'u', 's', 'e', 'M', 'o', 'd', 'e', 's', 0,
    'p', 'r', 'o', 'x', 'y', 'A', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'R', 'e', 'q', 'u', 'i', 'r', 'e', 'd', 0,
    'P', 'r', 'o', 'x', 'y', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 'T', 'i', 'm', 'e', 'o', 'u', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'P', 'r', 'o', 'x', 'y', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 'R', 'e', 'f', 'u', 's', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'U', 'n', 'k', 'n', 'o', 'w', 'n', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'L', 'a', 'y', 'e', 'r', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    'Q', 'A', 'b', 's', 't', 'r', 'a', 'c', 't', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'S', 'o', 'c', 'k', 'e', 't', 'T', 'y', 'p', 'e', 0,
    'Q', 'V', 'e', 'c', 't', 'o', 'r', '<', 'Q', 'S', 's', 'l', 'E', 'l', 'l', 'i', 'p', 't', 'i', 'c', 'C', 'u', 'r', 'v', 'e', '>', 0,
    'Q', 'S', 's', 'l', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'P', 'e', 'e', 'r', 'V', 'e', 'r', 'i', 'f', 'y', 'M', 'o', 'd', 'e', 0,
    'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'S', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', 'F', 'a', 'i', 'l', 'e', 'd', 0,
    's', 'e', 't', 'D', 'i', 'f', 'f', 'i', 'e', 'H', 'e', 'l', 'l', 'm', 'a', 'n', 'P', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', 's', 0,
    'D', 'i', 's', 't', 'i', 'n', 'g', 'u', 'i', 's', 'h', 'e', 'd', 'N', 'a', 'm', 'e', 'Q', 'u', 'a', 'l', 'i', 'f', 'i', 'e', 'r', 0,
    'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'N', 'o', 't', 'S', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'U', 's', 'e', 'r', 'V', 'e', 'r', 'i', 'f', 'i', 'e', 'd', 'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'P', 'o', 'l', 'i', 'c', 'y', 0,
    's', 'e', 't', 'M', 'a', 'x', 'i', 'm', 'u', 'm', 'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 's', 'A', 'l', 'l', 'o', 'w', 'e', 'd', 0,
    'B', 'a', 'c', 'k', 'g', 'r', 'o', 'u', 'n', 'd', 'R', 'e', 'q', 'u', 'e', 's', 't', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'C', 'o', 'o', 'k', 'i', 'e', 'S', 'a', 'v', 'e', 'C', 'o', 'n', 't', 'r', 'o', 'l', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'C', 'o', 'o', 'k', 'i', 'e', 'L', 'o', 'a', 'd', 'C', 'o', 'n', 't', 'r', 'o', 'l', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'S', 'o', 'u', 'r', 'c', 'e', 'I', 's', 'F', 'r', 'o', 'm', 'C', 'a', 'c', 'h', 'e', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'i', 'o', 'n', 'T', 'a', 'r', 'g', 'e', 't', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'R', 'e', 'q', 'u', 'e', 's', 't', ':', ':', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    's', 'e', 't', 'A', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'x', 'y', 'F', 'a', 'c', 't', 'o', 'r', 'y', 0,
    'Q', 'L', 'o', 'c', 'a', 'l', 'S', 'e', 'r', 'v', 'e', 'r', ':', ':', 'S', 'o', 'c', 'k', 'e', 't', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'Q', 'A', 'b', 's', 't', 'r', 'a', 'c', 't', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'P', 'a', 'u', 's', 'e', 'M', 'o', 'd', 'e', 0,
    'S', 'e', 'n', 'd', 'B', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 'S', 'o', 'c', 'k', 'e', 't', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'P', 'r', 'o', 'x', 'y', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 'C', 'l', 'o', 's', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'M', 'a', 'p', '<', 'Q', 'B', 'y', 't', 'e', 'A', 'r', 'r', 'a', 'y', ',', 'Q', 'V', 'a', 'r', 'i', 'a', 'n', 't', '>', 0,
    'm', 'a', 'x', 'i', 'm', 'u', 'm', 'P', 'r', 'e', 'S', 'h', 'a', 'r', 'e', 'd', 'K', 'e', 'y', 'L', 'e', 'n', 'g', 't', 'h', 0,
    's', 'e', 's', 's', 'i', 'o', 'n', 'T', 'i', 'c', 'k', 'e', 't', 'L', 'i', 'f', 'e', 'T', 'i', 'm', 'e', 'H', 'i', 'n', 't', 0,
    'N', 'o', 'B', 'a', 'c', 'k', 'g', 'r', 'o', 'u', 'n', 'd', 'T', 'r', 'a', 'f', 'f', 'i', 'c', 'P', 'o', 'l', 'i', 'c', 'y', 0,
    'n', 'e', 'w', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'A', 'c', 't', 'i', 'v', 'a', 't', 'e', 'd', 0,
    'I', 'n', 'v', 'a', 'l', 'i', 'd', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'R', 'e', 'q', 'u', 'e', 's', 't', ':', ':', 'P', 'r', 'i', 'o', 'r', 'i', 't', 'y', 0,
    'C', 'a', 'c', 'h', 'e', 'S', 'a', 'v', 'e', 'C', 'o', 'n', 't', 'r', 'o', 'l', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'C', 'a', 'c', 'h', 'e', 'L', 'o', 'a', 'd', 'C', 'o', 'n', 't', 'r', 'o', 'l', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'H', 't', 't', 'p', 'R', 'e', 'a', 's', 'o', 'n', 'P', 'h', 'r', 'a', 's', 'e', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'N', 'e', 't', 'w', 'o', 'r', 'k', 'S', 'e', 's', 's', 'i', 'o', 'n', 'F', 'a', 'i', 'l', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    's', 'e', 't', 'U', 's', 'e', 'S', 'y', 's', 't', 'e', 'm', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'P', 'r', 'o', 'x', 'y', ':', ':', 'C', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'y', 0,
    'C', 'a', 'n', 'S', 't', 'a', 'r', 't', 'A', 'n', 'd', 'S', 't', 'o', 'p', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 's', 0,
    'C', 'o', 'n', 'v', 'e', 'r', 't', 'U', 'n', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'Q', 'A', 'b', 's', 't', 'r', 'a', 'c', 't', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'B', 'i', 'n', 'd', 'M', 'o', 'd', 'e', 0,
    'Q', 'A', 'b', 's', 't', 'r', 'a', 'c', 't', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'B', 'i', 'n', 'd', 'F', 'l', 'a', 'g', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', '>', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'D', 'n', 's', 'S', 'e', 'r', 'v', 'i', 'c', 'e', 'R', 'e', 'c', 'o', 'r', 'd', '>', 0,
    's', 'e', 't', 'D', 'e', 'f', 'a', 'u', 'l', 't', 'C', 'a', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 's', 0,
    'a', 'd', 'd', 'D', 'e', 'f', 'a', 'u', 'l', 't', 'C', 'a', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 's', 0,
    'p', 'r', 'e', 'S', 'h', 'a', 'r', 'e', 'd', 'K', 'e', 'y', 'I', 'd', 'e', 'n', 't', 'i', 't', 'y', 'H', 'i', 'n', 't', 0,
    's', 'e', 't', 'L', 'o', 'c', 'a', 'l', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'C', 'h', 'a', 'i', 'n', 0,
    'Q', 'S', 's', 'l', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'E', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', 0,
    'S', 'a', 'm', 'e', 'O', 'r', 'i', 'g', 'i', 'n', 'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'P', 'o', 'l', 'i', 'c', 'y', 0,
    'N', 'o', 'L', 'e', 's', 's', 'S', 'a', 'f', 'e', 'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'P', 'o', 'l', 'i', 'c', 'y', 0,
    'F', 'o', 'l', 'l', 'o', 'w', 'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 's', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'C', 'o', 'n', 't', 'e', 'n', 't', 'D', 'i', 's', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'H', 'o', 's', 't', 'N', 'a', 'm', 'e', 'L', 'o', 'o', 'k', 'u', 'p', 'C', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'y', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'P', 'r', 'o', 'x', 'y', ':', ':', 'P', 'r', 'o', 'x', 'y', 'T', 'y', 'p', 'e', 0,
    'n', 'e', 't', 'w', 'o', 'r', 'k', 'A', 'c', 'c', 'e', 's', 's', 'i', 'b', 'l', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    's', 'e', 't', 'M', 'a', 'x', 'P', 'e', 'n', 'd', 'i', 'n', 'g', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 's', 0,
    'Q', 'H', 's', 't', 's', 'P', 'o', 'l', 'i', 'c', 'y', ':', ':', 'P', 'o', 'l', 'i', 'c', 'y', 'F', 'l', 'a', 'g', 's', 0,
    'Q', 'H', 'o', 's', 't', 'I', 'n', 'f', 'o', ':', ':', 'H', 'o', 's', 't', 'I', 'n', 'f', 'o', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'P', 'a', 'i', 'r', '<', 'Q', 'H', 'o', 's', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', ',', 'i', 'n', 't', '>', 0,
    's', 's', 'l', 'L', 'i', 'b', 'r', 'a', 'r', 'y', 'V', 'e', 'r', 's', 'i', 'o', 'n', 'S', 't', 'r', 'i', 'n', 'g', 0,
    's', 's', 'l', 'L', 'i', 'b', 'r', 'a', 'r', 'y', 'V', 'e', 'r', 's', 'i', 'o', 'n', 'N', 'u', 'm', 'b', 'e', 'r', 0,
    'e', 'n', 'c', 'r', 'y', 'p', 't', 'e', 'd', 'B', 'y', 't', 'e', 's', 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0,
    'a', 'd', 'd', 'D', 'e', 'f', 'a', 'u', 'l', 't', 'C', 'a', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    's', 'e', 't', 'B', 'a', 'c', 'k', 'e', 'n', 'd', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'd', 'i', 'f', 'f', 'i', 'e', 'H', 'e', 'l', 'l', 'm', 'a', 'n', 'P', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', 's', 0,
    's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 'E', 'l', 'l', 'i', 'p', 't', 'i', 'c', 'C', 'u', 'r', 'v', 'e', 's', 0,
    's', 'e', 't', 'A', 'l', 'l', 'o', 'w', 'e', 'd', 'N', 'e', 'x', 't', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 's', 0,
    's', 'e', 't', 'D', 'e', 'f', 'a', 'u', 'l', 't', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    's', 'u', 'b', 'j', 'e', 'c', 't', 'A', 'l', 't', 'e', 'r', 'n', 'a', 't', 'i', 'v', 'e', 'N', 'a', 'm', 'e', 's', 0,
    'm', 'a', 'x', 'i', 'm', 'u', 'm', 'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 's', 'A', 'l', 'l', 'o', 'w', 'e', 'd', 0,
    'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'P', 'o', 'l', 'i', 'c', 'y', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'H', 't', 't', 'p', 'S', 't', 'a', 't', 'u', 's', 'C', 'o', 'd', 'e', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'S', 'e', 'r', 'v', 'i', 'c', 'e', 'U', 'n', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 'E', 'r', 'r', 'o', 'r', 0,
    'u', 's', 'e', 's', 'S', 'y', 's', 't', 'e', 'm', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    's', 'e', 't', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'S', 'c', 't', 'p', 'L', 'i', 's', 't', 'e', 'n', 'i', 'n', 'g', 'C', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'y', 0,
    'S', 'c', 't', 'p', 'T', 'u', 'n', 'n', 'e', 'l', 'i', 'n', 'g', 'C', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'y', 0,
    'm', 'a', 'x', 'i', 'm', 'u', 'm', 'T', 'r', 'a', 'n', 's', 'm', 'i', 's', 's', 'i', 'o', 'n', 'U', 'n', 'i', 't', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'o', 'k', 'i', 'e', ':', ':', 'R', 'a', 'w', 'F', 'o', 'r', 'm', 0,
    'A', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'L', 'e', 'v', 'e', 'l', 'R', 'o', 'a', 'm', 'i', 'n', 'g', 0,
    'D', 'i', 'r', 'e', 'c', 't', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 'R', 'o', 'u', 't', 'i', 'n', 'g', 0,
    'Q', 'H', 's', 't', 's', 'P', 'o', 'l', 'i', 'c', 'y', ':', ':', 'P', 'o', 'l', 'i', 'c', 'y', 'F', 'l', 'a', 'g', 0,
    'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'C', 'a', 'n', 'c', 'e', 'l', 'l', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'M', 'u', 'l', 't', 'i', 'c', 'a', 's', 't', 'L', 'o', 'o', 'p', 'b', 'a', 'c', 'k', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'S', 's', 'l', 'I', 'n', 'v', 'a', 'l', 'i', 'd', 'U', 's', 'e', 'r', 'D', 'a', 't', 'a', 'E', 'r', 'r', 'o', 'r', 0,
    'S', 's', 'l', 'H', 'a', 'n', 'd', 's', 'h', 'a', 'k', 'e', 'F', 'a', 'i', 'l', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'S', 's', 'l', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', '>', 0,
    'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'B', 'l', 'a', 'c', 'k', 'l', 'i', 's', 't', 'e', 'd', 0,
    'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'N', 'o', 't', 'Y', 'e', 't', 'V', 'a', 'l', 'i', 'd', 0,
    'n', 'e', 'x', 't', 'N', 'e', 'g', 'o', 't', 'i', 'a', 't', 'e', 'd', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    'O', 'r', 'g', 'a', 'n', 'i', 'z', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'U', 'n', 'i', 't', 'N', 'a', 'm', 'e', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'S', 'e', 's', 's', 'i', 'o', 'n', ':', ':', 'S', 't', 'a', 't', 'e', 0,
    'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'C', 'a', 'n', 'c', 'e', 'l', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'U', 'd', 'p', 'T', 'u', 'n', 'n', 'e', 'l', 'i', 'n', 'g', 'C', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'y', 0,
    'i', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 'N', 'a', 'm', 'e', 'F', 'r', 'o', 'm', 'I', 'n', 'd', 'e', 'x', 0,
    'i', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 'I', 'n', 'd', 'e', 'x', 'F', 'r', 'o', 'm', 'N', 'a', 'm', 'e', 0,
    'S', 'e', 'r', 'v', 'i', 'c', 'e', 'S', 'p', 'e', 'c', 'i', 'f', 'i', 'c', 'P', 'u', 'r', 'p', 'o', 's', 'e', 0,
    'N', 'e', 't', 'w', 'o', 'r', 'k', 'S', 'e', 's', 's', 'i', 'o', 'n', 'R', 'e', 'q', 'u', 'i', 'r', 'e', 'd', 0,
    'c', 'o', 'n', 'n', 'e', 'c', 't', 'T', 'o', 'H', 'o', 's', 't', 'E', 'n', 'c', 'r', 'y', 'p', 't', 'e', 'd', 0,
    'a', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'R', 'e', 'q', 'u', 'i', 'r', 'e', 'd', 0,
    'Q', 'D', 'n', 's', 'M', 'a', 'i', 'l', 'E', 'x', 'c', 'h', 'a', 'n', 'g', 'e', 'R', 'e', 'c', 'o', 'r', 'd', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'o', 'k', 'i', 'e', '>', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'D', 'n', 's', 'T', 'e', 'x', 't', 'R', 'e', 'c', 'o', 'r', 'd', '>', 0,
    's', 'e', 't', 'M', 'u', 'l', 't', 'i', 'c', 'a', 's', 't', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 0,
    'e', 'n', 'c', 'r', 'y', 'p', 't', 'e', 'd', 'B', 'y', 't', 'e', 's', 'W', 'r', 'i', 't', 't', 'e', 'n', 0,
    'e', 'n', 'c', 'r', 'y', 'p', 't', 'e', 'd', 'B', 'y', 't', 'e', 's', 'T', 'o', 'W', 'r', 'i', 't', 'e', 0,
    's', 't', 'a', 'r', 't', 'S', 'e', 'r', 'v', 'e', 'r', 'E', 'n', 'c', 'r', 'y', 'p', 't', 'i', 'o', 'n', 0,
    's', 't', 'a', 'r', 't', 'C', 'l', 'i', 'e', 'n', 't', 'E', 'n', 'c', 'r', 'y', 'p', 't', 'i', 'o', 'n', 0,
    'd', 'e', 'f', 'a', 'u', 'l', 't', 'C', 'a', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 's', 0,
    'm', 'a', 'x', 'i', 'm', 'u', 'm', 'I', 'd', 'e', 'n', 't', 'i', 't', 'y', 'L', 'e', 'n', 'g', 't', 'h', 0,
    'S', 'u', 'b', 'j', 'e', 'c', 't', 'I', 's', 's', 'u', 'e', 'r', 'M', 'i', 's', 'm', 'a', 't', 'c', 'h', 0,
    'S', 'e', 'l', 'f', 'S', 'i', 'g', 'n', 'e', 'd', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    'I', 'n', 'v', 'a', 'l', 'i', 'd', 'N', 'o', 't', 'B', 'e', 'f', 'o', 'r', 'e', 'F', 'i', 'e', 'l', 'd', 0,
    'U', 'n', 's', 'a', 'f', 'e', 'P', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', 's', 'E', 'r', 'r', 'o', 'r', 0,
    'I', 'n', 'v', 'a', 'l', 'i', 'd', 'I', 'n', 'p', 'u', 't', 'D', 'a', 't', 'a', 'E', 'r', 'r', 'o', 'r', 0,
    'l', 'o', 'c', 'a', 'l', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'C', 'h', 'a', 'i', 'n', 0,
    's', 'u', 'b', 'j', 'e', 'c', 't', 'I', 'n', 'f', 'o', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 's', 0,
    'H', 'T', 'T', 'P', '2', 'W', 'a', 's', 'U', 's', 'e', 'd', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'H', 'T', 'T', 'P', '2', 'A', 'l', 'l', 'o', 'w', 'e', 'd', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'I', 'f', 'M', 'o', 'd', 'i', 'f', 'i', 'e', 'd', 'S', 'i', 'n', 'c', 'e', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'I', 'n', 's', 'e', 'c', 'u', 'r', 'e', 'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'T', 'o', 'o', 'M', 'a', 'n', 'y', 'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 's', 'E', 'r', 'r', 'o', 'r', 0,
    'D', 'n', 's', 'E', 'l', 'i', 'g', 'i', 'b', 'i', 'l', 'i', 't', 'y', 'U', 'n', 'k', 'n', 'o', 'w', 'n', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'A', 'c', 'c', 'e', 's', 's', 'M', 'a', 'n', 'a', 'g', 'e', 'r', 0,
    'n', 'e', 'x', 't', 'P', 'e', 'n', 'd', 'i', 'n', 'g', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 0,
    'm', 'a', 'x', 'P', 'e', 'n', 'd', 'i', 'n', 'g', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 's', 0,
    'h', 'a', 's', 'P', 'e', 'n', 'd', 'i', 'n', 'g', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 's', 0,
    's', 'e', 't', 'I', 'n', 'c', 'l', 'u', 'd', 'e', 's', 'S', 'u', 'b', 'D', 'o', 'm', 'a', 'i', 'n', 's', 0,
    'C', 'o', 'n', 'v', 'e', 'r', 't', 'V', '4', 'C', 'o', 'm', 'p', 'a', 't', 'T', 'o', 'I', 'P', 'v', '4', 0,
    'C', 'o', 'n', 'v', 'e', 'r', 't', 'V', '4', 'M', 'a', 'p', 'p', 'e', 'd', 'T', 'o', 'I', 'P', 'v', '4', 0,
    'Q', 'D', 'n', 's', 'H', 'o', 's', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', 'R', 'e', 'c', 'o', 'r', 'd', 0,
    'D', 'a', 't', 'a', 'g', 'r', 'a', 'm', 'T', 'o', 'o', 'L', 'a', 'r', 'g', 'e', 'E', 'r', 'r', 'o', 'r', 0,
    'R', 'e', 'm', 'o', 't', 'e', 'H', 'o', 's', 't', 'C', 'l', 'o', 's', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'A', 'b', 's', 't', 'r', 'a', 'c', 't', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'a', 'c', 'h', 'e', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'a', 'c', 'h', 'e', 'M', 'e', 't', 'a', 'D', 'a', 't', 'a', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'P', 'r', 'o', 'x', 'y', '>', 0,
    'Q', 'V', 'e', 'c', 't', 'o', 'r', '<', 'Q', 'H', 's', 't', 's', 'P', 'o', 'l', 'i', 'c', 'y', '>', 0,
    'a', 'd', 'd', 'P', 'e', 'n', 'd', 'i', 'n', 'g', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 0,
    'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'U', 'n', 't', 'r', 'u', 's', 't', 'e', 'd', 0,
    'I', 'n', 'v', 'a', 'l', 'i', 'd', 'C', 'a', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    'I', 'n', 'v', 'a', 'l', 'i', 'd', 'N', 'o', 't', 'A', 'f', 't', 'e', 'r', 'F', 'i', 'e', 'l', 'd', 0,
    'b', 'a', 'c', 'k', 'e', 'n', 'd', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    's', 'y', 's', 't', 'e', 'm', 'C', 'a', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 's', 0,
    'a', 'l', 'l', 'o', 'w', 'e', 'd', 'N', 'e', 'x', 't', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 's', 0,
    'p', 'e', 'e', 'r', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'C', 'h', 'a', 'i', 'n', 0,
    'a', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'M', 'e', 't', 'h', 'o', 'd', 0,
    'i', 's', 's', 'u', 'e', 'r', 'I', 'n', 'f', 'o', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 's', 0,
    'Q', 'S', 's', 'l', ':', ':', 'E', 'n', 'c', 'o', 'd', 'i', 'n', 'g', 'F', 'o', 'r', 'm', 'a', 't', 0,
    'u', 's', 'a', 'g', 'e', 'P', 'o', 'l', 'i', 'c', 'i', 'e', 's', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'M', 'a', 'n', 'u', 'a', 'l', 'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'P', 'o', 'l', 'i', 'c', 'y', 0,
    's', 'e', 't', 'O', 'r', 'i', 'g', 'i', 'n', 'a', 't', 'i', 'n', 'g', 'O', 'b', 'j', 'e', 'c', 't', 0,
    'H', 't', 't', 'p', '2', 'D', 'i', 'r', 'e', 'c', 't', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'S', 'p', 'd', 'y', 'W', 'a', 's', 'U', 's', 'e', 'd', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'S', 'p', 'd', 'y', 'A', 'l', 'l', 'o', 'w', 'e', 'd', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'C', 'o', 'n', 't', 'e', 'n', 't', 'C', 'o', 'n', 'f', 'l', 'i', 'c', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'U', 'n', 'k', 'n', 'o', 'w', 'n', 'E', 'r', 'r', 'o', 'r', 0,
    'C', 'o', 'n', 't', 'e', 'n', 't', 'N', 'o', 't', 'F', 'o', 'u', 'n', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'P', 'r', 'o', 'x', 'y', 'F', 'a', 'c', 't', 'o', 'r', 'y', 0,
    'n', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'c', 'l', 'e', 'a', 'r', 'A', 'd', 'd', 'r', 'e', 's', 's', 'L', 'i', 'f', 'e', 't', 'i', 'm', 'e', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'A', 'd', 'd', 'r', 'e', 's', 's', 'E', 'n', 't', 'r', 'y', 0,
    'c', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'c', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'R', 'e', 'm', 'o', 'v', 'e', 'd', 0,
    'u', 'p', 'd', 'a', 't', 'e', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 's', 0,
    'd', 'e', 'f', 'a', 'u', 'l', 't', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'S', 'y', 's', 't', 'e', 'm', 'S', 'e', 's', 's', 'i', 'o', 'n', 'S', 'u', 'p', 'p', 'o', 'r', 't', 0,
    'c', 'l', 'e', 'a', 'r', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 'C', 'a', 'c', 'h', 'e', 0,
    's', 'e', 't', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'A', 'c', 'c', 'e', 's', 's', 'i', 'b', 'l', 'e', 0,
    'U', 'n', 'k', 'n', 'o', 'w', 'n', 'A', 'c', 'c', 'e', 's', 's', 'i', 'b', 'i', 'l', 'i', 't', 'y', 0,
    'd', 'i', 's', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'F', 'r', 'o', 'm', 'S', 'e', 'r', 'v', 'e', 'r', 0,
    'w', 'a', 'i', 't', 'F', 'o', 'r', 'N', 'e', 'w', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 0,
    'i', 's', 'U', 'n', 'i', 'q', 'u', 'e', 'L', 'o', 'c', 'a', 'l', 'U', 'n', 'i', 'c', 'a', 's', 't', 0,
    'c', 'a', 'n', 'o', 'n', 'i', 'c', 'a', 'l', 'N', 'a', 'm', 'e', 'R', 'e', 'c', 'o', 'r', 'd', 's', 0,
    'Q', 'D', 'n', 's', 'D', 'o', 'm', 'a', 'i', 'n', 'N', 'a', 'm', 'e', 'R', 'e', 'c', 'o', 'r', 'd', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'H', 'o', 's', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', '>', 0,
    'l', 'e', 'a', 'v', 'e', 'M', 'u', 'l', 't', 'i', 'c', 'a', 's', 't', 'G', 'r', 'o', 'u', 'p', 0,
    'p', 'e', 'n', 'd', 'i', 'n', 'g', 'D', 'a', 't', 'a', 'g', 'r', 'a', 'm', 'S', 'i', 'z', 'e', 0,
    'h', 'a', 's', 'P', 'e', 'n', 'd', 'i', 'n', 'g', 'D', 'a', 't', 'a', 'g', 'r', 'a', 'm', 's', 0,
    'Q', 'S', 's', 'l', 'S', 'o', 'c', 'k', 'e', 't', ':', ':', 'S', 's', 'l', 'M', 'o', 'd', 'e', 0,
    'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'R', 'e', 'j', 'e', 'c', 't', 'e', 'd', 0,
    'Q', 'S', 's', 'l', 'E', 'r', 'r', 'o', 'r', ':', ':', 'S', 's', 'l', 'E', 'r', 'r', 'o', 'r', 0,
    'N', 'e', 'x', 't', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'H', 't', 't', 'p', '1', '_', '1', 0,
    'N', 'e', 'x', 't', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'S', 'p', 'd', 'y', '3', '_', '0', 0,
    's', 'e', 't', 'L', 'o', 'c', 'a', 'l', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    'S', 't', 'a', 't', 'e', 'O', 'r', 'P', 'r', 'o', 'v', 'i', 'n', 'c', 'e', 'N', 'a', 'm', 'e', 0,
    'S', 'e', 's', 's', 'i', 'o', 'n', 'A', 'b', 'o', 'r', 't', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'U', 'n', 'k', 'n', 'o', 'w', 'n', 'S', 'e', 's', 's', 'i', 'o', 'n', 'E', 'r', 'r', 'o', 'r', 0,
    'C', 'u', 's', 't', 'o', 'm', 'V', 'e', 'r', 'b', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'C', 'o', 'n', 't', 'e', 'n', 't', 'L', 'e', 'n', 'g', 't', 'h', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    's', 'e', 't', 'S', 's', 'l', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', 'S', 'e', 'r', 'v', 'e', 'r', 'E', 'r', 'r', 'o', 'r', 0,
    'U', 'n', 'k', 'n', 'o', 'w', 'n', 'C', 'o', 'n', 't', 'e', 'n', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'C', 'o', 'n', 't', 'e', 'n', 't', 'A', 'c', 'c', 'e', 's', 's', 'D', 'e', 'n', 'i', 'e', 'd', 0,
    'U', 'n', 'k', 'n', 'o', 'w', 'n', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'E', 'r', 'r', 'o', 'r', 0,
    's', 'y', 's', 't', 'e', 'm', 'P', 'r', 'o', 'x', 'y', 'F', 'o', 'r', 'Q', 'u', 'e', 'r', 'y', 0,
    's', 'e', 't', 'A', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'x', 'y', 0,
    's', 'e', 't', 'M', 'a', 'x', 'i', 'm', 'u', 'm', 'C', 'a', 'c', 'h', 'e', 'S', 'i', 'z', 'e', 0,
    'I', 'n', 't', 'e', 'r', 'n', 'e', 't', 'A', 'c', 'c', 'e', 's', 's', 'P', 'o', 'i', 'n', 't', 0,
    'a', 'c', 't', 'i', 'v', 'e', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'S', 'e', 'r', 'v', 'e', 'r', 'N', 'o', 't', 'F', 'o', 'u', 'n', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'm', 'a', 'i', 'l', 'E', 'x', 'c', 'h', 'a', 'n', 'g', 'e', 'R', 'e', 'c', 'o', 'r', 'd', 's', 0,
    'I', 'n', 'v', 'a', 'l', 'i', 'd', 'R', 'e', 'q', 'u', 'e', 's', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'P', 'a', 't', 'h', 'M', 't', 'u', 'S', 'o', 'c', 'k', 'e', 't', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'T', 'y', 'p', 'e', 'O', 'f', 'S', 'e', 'r', 'v', 'i', 'c', 'e', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'w', 'a', 'i', 't', 'F', 'o', 'r', 'D', 'i', 's', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd', 0,
    's', 'e', 't', 'S', 'o', 'c', 'k', 'e', 't', 'D', 'e', 's', 'c', 'r', 'i', 'p', 't', 'o', 'r', 0,
    'S', 'o', 'c', 'k', 'e', 't', 'R', 'e', 's', 'o', 'u', 'r', 'c', 'e', 'E', 'r', 'r', 'o', 'r', 0,
    'w', 'a', 'i', 't', 'F', 'o', 'r', 'B', 'y', 't', 'e', 's', 'W', 'r', 'i', 't', 't', 'e', 'n', 0,
    'm', 'u', 'l', 't', 'i', 'c', 'a', 's', 't', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 0,
    'j', 'o', 'i', 'n', 'M', 'u', 'l', 't', 'i', 'c', 'a', 's', 't', 'G', 'r', 'o', 'u', 'p', 0,
    'P', 'a', 't', 'h', 'L', 'e', 'n', 'g', 't', 'h', 'E', 'x', 'c', 'e', 'e', 'd', 'e', 'd', 0,
    'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'R', 'e', 'v', 'o', 'k', 'e', 'd', 0,
    'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 'E', 'x', 'p', 'i', 'r', 'e', 'd', 0,
    'e', 'p', 'h', 'e', 'm', 'e', 'r', 'a', 'l', 'S', 'e', 'r', 'v', 'e', 'r', 'K', 'e', 'y', 0,
    's', 'e', 't', 'P', 'e', 'e', 'r', 'V', 'e', 'r', 'i', 'f', 'y', 'D', 'e', 'p', 't', 'h', 0,
    's', 'u', 'b', 'j', 'e', 'c', 't', 'D', 'i', 's', 'p', 'l', 'a', 'y', 'N', 'a', 'm', 'e', 0,
    'Q', 'S', 's', 'l', ':', ':', 'K', 'e', 'y', 'A', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 0,
    's', 'e', 't', 'S', 'e', 's', 's', 'i', 'o', 'n', 'P', 'r', 'o', 'p', 'e', 'r', 't', 'y', 0,
    'L', 'a', 's', 't', 'M', 'o', 'd', 'i', 'f', 'i', 'e', 'd', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'U', 'n', 'k', 'n', 'o', 'w', 'n', 'S', 'e', 'r', 'v', 'e', 'r', 'E', 'r', 'r', 'o', 'r', 0,
    'C', 'o', 'n', 't', 'e', 'n', 't', 'R', 'e', 'S', 'e', 'n', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'P', 'r', 'o', 'x', 'y', 'Q', 'u', 'e', 'r', 'y', 0,
    'i', 's', 'T', 'r', 'a', 'n', 's', 'p', 'a', 'r', 'e', 'n', 't', 'P', 'r', 'o', 'x', 'y', 0,
    'i', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 'F', 'r', 'o', 'm', 'I', 'n', 'd', 'e', 'x', 0,
    's', 'e', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', 'L', 'i', 'f', 'e', 't', 'i', 'm', 'e', 0,
    'd', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'i', 's', 'R', 'o', 'a', 'm', 'i', 'n', 'g', 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0,
    'o', 'n', 'l', 'i', 'n', 'e', 'S', 't', 'a', 't', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'c', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 'A', 'd', 'd', 'e', 'd', 0,
    'i', 'n', 'c', 'o', 'm', 'i', 'n', 'g', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 0,
    'i', 'n', 'c', 'l', 'u', 'd', 'e', 's', 'S', 'u', 'b', 'D', 'o', 'm', 'a', 'i', 'n', 's', 0,
    'T', 'o', 'l', 'e', 'r', 'a', 'n', 't', 'C', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', 0,
    'h', 'o', 's', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', 'R', 'e', 'c', 'o', 'r', 'd', 's', 0,
    'S', 'e', 'r', 'v', 'e', 'r', 'R', 'e', 'f', 'u', 's', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'S', 'e', 'r', 'v', 'e', 'r', 'F', 'a', 'i', 'l', 'u', 'r', 'e', 'E', 'r', 'r', 'o', 'r', 0,
    'D', 'e', 'f', 'a', 'u', 'l', 't', 'F', 'o', 'r', 'P', 'l', 'a', 't', 'f', 'o', 'r', 'm', 0,
    'M', 'u', 'l', 't', 'i', 'c', 'a', 's', 't', 'T', 't', 'l', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'd', 'i', 's', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'F', 'r', 'o', 'm', 'H', 'o', 's', 't', 0,
    'U', 'n', 'k', 'n', 'o', 'w', 'n', 'S', 'o', 'c', 'k', 'e', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'P', 'r', 'o', 'x', 'y', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'E', 'r', 'r', 'o', 'r', 0,
    'P', 'r', 'o', 'x', 'y', 'N', 'o', 't', 'F', 'o', 'u', 'n', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'S', 'o', 'c', 'k', 'e', 't', 'T', 'i', 'm', 'e', 'o', 'u', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'S', 's', 'l', 'C', 'i', 'p', 'h', 'e', 'r', '>', 0,
    's', 'e', 't', 'P', 'e', 'e', 'r', 'V', 'e', 'r', 'i', 'f', 'y', 'N', 'a', 'm', 'e', 0,
    'a', 'd', 'd', 'C', 'a', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 's', 0,
    's', 'e', 't', 'D', 'e', 'f', 'a', 'u', 'l', 't', 'C', 'i', 'p', 'h', 'e', 'r', 's', 0,
    'N', 'o', 'P', 'e', 'e', 'r', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    'Q', 'S', 's', 'l', 'E', 'l', 'l', 'i', 'p', 't', 'i', 'c', 'C', 'u', 'r', 'v', 'e', 0,
    'd', 'e', 'f', 'a', 'u', 'l', 't', 'P', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', 's', 0,
    's', 'e', 't', 'E', 'l', 'l', 'i', 'p', 't', 'i', 'c', 'C', 'u', 'r', 'v', 'e', 's', 0,
    's', 'e', 't', 'C', 'a', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 's', 0,
    's', 'e', 't', 'P', 'e', 'e', 'r', 'V', 'e', 'r', 'i', 'f', 'y', 'M', 'o', 'd', 'e', 0,
    'Q', 'S', 's', 'l', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'k', 'e', 'y', 'E', 'x', 'c', 'h', 'a', 'n', 'g', 'e', 'M', 'e', 't', 'h', 'o', 'd', 0,
    'i', 's', 's', 'u', 'e', 'r', 'D', 'i', 's', 'p', 'l', 'a', 'y', 'N', 'a', 'm', 'e', 0,
    'Q', 'S', 's', 'l', ':', ':', 'S', 's', 'l', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    'Q', 'P', 'a', 's', 's', 'w', 'o', 'r', 'd', 'D', 'i', 'g', 'e', 's', 't', 'o', 'r', 0,
    'o', 'r', 'i', 'g', 'i', 'n', 'a', 't', 'i', 'n', 'g', 'O', 'b', 'j', 'e', 'c', 't', 0,
    'I', 'f', 'N', 'o', 'n', 'e', 'M', 'a', 't', 'c', 'h', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'C', 'o', 'n', 't', 'e', 'n', 't', 'T', 'y', 'p', 'e', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'U', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'x', 'y', 'E', 'r', 'r', 'o', 'r', 0,
    'P', 'r', 'o', 'x', 'y', 'T', 'i', 'm', 'e', 'o', 'u', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'C', 'a', 'c', 'h', 'i', 'n', 'g', 'C', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'y', 0,
    'h', 'u', 'm', 'a', 'n', 'R', 'e', 'a', 'd', 'a', 'b', 'l', 'e', 'N', 'a', 'm', 'e', 0,
    'i', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 'F', 'r', 'o', 'm', 'N', 'a', 'm', 'e', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 0,
    'p', 'r', 'e', 'f', 'e', 'r', 'r', 'e', 'd', 'L', 'i', 'f', 'e', 't', 'i', 'm', 'e', 0,
    's', 'e', 't', 'D', 'n', 's', 'E', 'l', 'i', 'g', 'i', 'b', 'i', 'l', 'i', 't', 'y', 0,
    's', 'e', 't', 'C', 'a', 'c', 'h', 'e', 'D', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'D', 'i', 's', 'k', 'C', 'a', 'c', 'h', 'e', 0,
    's', 'e', 't', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 'I', 'n', 'd', 'e', 'x', 0,
    's', 'e', 't', 'C', 'o', 'o', 'k', 'i', 'e', 's', 'F', 'r', 'o', 'm', 'U', 'r', 'l', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'o', 'k', 'i', 'e', 'J', 'a', 'r', 0,
    'h', 'a', 's', 'S', 'a', 'm', 'e', 'I', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', 0,
    's', 'e', 't', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'T', 'i', 'm', 'e', 'o', 'u', 't', 0,
    'a', 'l', 'l', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 's', 0,
    's', 'e', 't', 'R', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'P', 'o', 'l', 'i', 'c', 'y', 0,
    'n', 'e', 't', 'w', 'o', 'r', 'k', 'A', 'c', 'c', 'e', 's', 's', 'i', 'b', 'l', 'e', 0,
    's', 'e', 'n', 'd', 'C', 'u', 's', 't', 'o', 'm', 'R', 'e', 'q', 'u', 'e', 's', 't', 0,
    'W', 'o', 'r', 'l', 'd', 'A', 'c', 'c', 'e', 's', 's', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'O', 't', 'h', 'e', 'r', 'A', 'c', 'c', 'e', 's', 's', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'G', 'r', 'o', 'u', 'p', 'A', 'c', 'c', 'e', 's', 's', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'I', 'n', 'c', 'l', 'u', 'd', 'e', 'S', 'u', 'b', 'D', 'o', 'm', 'a', 'i', 'n', 's', 0,
    'n', 'a', 'm', 'e', 's', 'e', 'r', 'v', 'e', 'r', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'n', 'a', 'm', 'e', 'S', 'e', 'r', 'v', 'e', 'r', 'R', 'e', 'c', 'o', 'r', 'd', 's', 0,
    'I', 'n', 'v', 'a', 'l', 'i', 'd', 'R', 'e', 'p', 'l', 'y', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'D', 'n', 's', 'L', 'o', 'o', 'k', 'u', 'p', ':', ':', 'E', 'r', 'r', 'o', 'r', 0,
    'Q', 'D', 'n', 's', 'S', 'e', 'r', 'v', 'i', 'c', 'e', 'R', 'e', 'c', 'o', 'r', 'd', 0,
    's', 'e', 't', 'R', 'e', 'a', 'd', 'B', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 0,
    'A', 'd', 'd', 'r', 'e', 's', 's', 'I', 'n', 'U', 's', 'e', 'E', 'r', 'r', 'o', 'r', 0,
    'S', 'o', 'c', 'k', 'e', 't', 'A', 'c', 'c', 'e', 's', 's', 'E', 'r', 'r', 'o', 'r', 0,
    'H', 'o', 's', 't', 'N', 'o', 't', 'F', 'o', 'u', 'n', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'U', 'n', 'k', 'n', 'o', 'w', 'n', 'S', 'o', 'c', 'k', 'e', 't', 'T', 'y', 'p', 'e', 0,
    's', 'e', 't', 'E', 'x', 'p', 'i', 'r', 'a', 't', 'i', 'o', 'n', 'D', 'a', 't', 'e', 0,
    's', 'i', 'p', '.', 's', 'i', 'm', 'p', 'l', 'e', 'w', 'r', 'a', 'p', 'p', 'e', 'r', 0,
    'Q', 'L', 'i', 's', 't', '<', 'Q', 'S', 's', 'l', 'E', 'r', 'r', 'o', 'r', '>', 0,
    'w', 'a', 'i', 't', 'F', 'o', 'r', 'E', 'n', 'c', 'r', 'y', 'p', 't', 'e', 'd', 0,
    'a', 'd', 'd', 'C', 'a', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    'H', 'o', 's', 't', 'N', 'a', 'm', 'e', 'M', 'i', 's', 'm', 'a', 't', 'c', 'h', 0,
    's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 'C', 'i', 'p', 'h', 'e', 'r', 's', 0,
    's', 'e', 't', 'S', 'e', 's', 's', 'i', 'o', 'n', 'T', 'i', 'c', 'k', 'e', 't', 0,
    'l', 'o', 'c', 'a', 'l', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    'e', 'n', 'c', 'r', 'y', 'p', 't', 'i', 'o', 'n', 'M', 'e', 't', 'h', 'o', 'd', 0,
    'Q', 'S', 's', 'l', ':', ':', 'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 's', 0,
    'd', 'o', 'w', 'n', 'l', 'o', 'a', 'd', 'P', 'r', 'o', 'g', 'r', 'e', 's', 's', 0,
    'C', 'o', 'n', 't', 'e', 'n', 't', 'G', 'o', 'n', 'e', 'E', 'r', 'r', 'o', 'r', 0,
    'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'x', 'y', 0,
    'H', 't', 't', 'p', 'C', 'a', 'c', 'h', 'i', 'n', 'g', 'P', 'r', 'o', 'x', 'y', 0,
    'v', 'a', 'l', 'i', 'd', 'i', 't', 'y', 'L', 'i', 'f', 'e', 't', 'i', 'm', 'e', 0,
    'm', 'a', 'x', 'i', 'm', 'u', 'm', 'C', 'a', 'c', 'h', 'e', 'S', 'i', 'z', 'e', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'D', 'a', 't', 'a', 'g', 'r', 'a', 'm', 0,
    'N', 'a', 'm', 'e', 'A', 'n', 'd', 'V', 'a', 'l', 'u', 'e', 'O', 'n', 'l', 'y', 0,
    'b', 'e', 'a', 'r', 'e', 'r', 'T', 'y', 'p', 'e', 'F', 'a', 'm', 'i', 'l', 'y', 0,
    's', 's', 'l', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 'S', 'c', 'h', 'e', 'm', 'e', 's', 0,
    'c', 'l', 'e', 'a', 'r', 'A', 'c', 'c', 'e', 's', 's', 'C', 'a', 'c', 'h', 'e', 0,
    's', 'e', 't', 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    's', 'e', 't', 'S', 'o', 'c', 'k', 'e', 't', 'O', 'p', 't', 'i', 'o', 'n', 's', 0,
    'U', 's', 'e', 'r', 'A', 'c', 'c', 'e', 's', 's', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'S', 't', 'r', 'i', 'c', 't', 'C', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', 0,
    'C', 'o', 'n', 'v', 'e', 'r', 't', 'L', 'o', 'c', 'a', 'l', 'H', 'o', 's', 't', 0,
    'Q', 'D', 'n', 's', 'L', 'o', 'o', 'k', 'u', 'p', ':', ':', 'T', 'y', 'p', 'e', 0,
    'P', 'a', 'u', 's', 'e', 'O', 'n', 'S', 's', 'l', 'E', 'r', 'r', 'o', 'r', 's', 0,
    'R', 'e', 'u', 's', 'e', 'A', 'd', 'd', 'r', 'e', 's', 's', 'H', 'i', 'n', 't', 0,
    'D', 'o', 'n', 't', 'S', 'h', 'a', 'r', 'e', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'w', 'a', 'i', 't', 'F', 'o', 'r', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd', 0,
    's', 'o', 'c', 'k', 'e', 't', 'D', 'e', 's', 'c', 'r', 'i', 'p', 't', 'o', 'r', 0,
    'U', 'n', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd', 'S', 't', 'a', 't', 'e', 0,
    'S', 's', 'l', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', 'E', 'r', 'r', 'o', 'r', 0,
    'w', 'a', 'i', 't', 'F', 'o', 'r', 'R', 'e', 'a', 'd', 'y', 'R', 'e', 'a', 'd', 0,
    'U', 'n', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'd', 'i', 's', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'N', 'o', 't', 'i', 'f', 'y', 0,
    'r', 'e', 'c', 'e', 'i', 'v', 'e', 'D', 'a', 't', 'a', 'g', 'r', 'a', 'm', 0,
    'r', 'e', 's', 'u', 'm', 'e', 'A', 'c', 'c', 'e', 'p', 't', 'i', 'n', 'g', 0,
    'p', 'e', 'e', 'r', 'V', 'e', 'r', 'i', 'f', 'y', 'E', 'r', 'r', 'o', 'r', 0,
    'U', 'n', 'e', 'n', 'c', 'r', 'y', 'p', 't', 'e', 'd', 'M', 'o', 'd', 'e', 0,
    's', 'e', 't', 'P', 'r', 'e', 'S', 'h', 'a', 'r', 'e', 'd', 'K', 'e', 'y', 0,
    'i', 's', 'T', 'l', 's', 'N', 'a', 'm', 'e', 'd', 'C', 'u', 'r', 'v', 'e', 0,
    's', 'e', 's', 's', 'i', 'o', 'n', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    'p', 'e', 'e', 'r', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    'p', 'e', 'e', 'r', 'V', 'e', 'r', 'i', 'f', 'y', 'D', 'e', 'p', 't', 'h', 0,
    'Q', 'S', 's', 'l', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    'Q', 'S', 's', 'l', ':', ':', 'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'D', 't', 'l', 's', 'V', '1', '_', '2', 'O', 'r', 'L', 'a', 't', 'e', 'r', 0,
    'D', 't', 'l', 's', 'V', '1', '_', '0', 'O', 'r', 'L', 'a', 't', 'e', 'r', 0,
    'S', 'e', 'c', 'u', 'r', 'e', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 's', 0,
    'U', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    'd', 'e', 'r', 'i', 'v', 'e', 'K', 'e', 'y', 'P', 'b', 'k', 'd', 'f', '2', 0,
    'd', 'e', 'r', 'i', 'v', 'e', 'K', 'e', 'y', 'P', 'b', 'k', 'd', 'f', '1', 0,
    's', 'e', 's', 's', 'i', 'o', 'n', 'P', 'r', 'o', 'p', 'e', 'r', 't', 'y', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'S', 'e', 's', 's', 'i', 'o', 'n', 0,
    'U', 's', 'e', 'r', 'A', 'g', 'e', 'n', 't', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'S', 'e', 't', 'C', 'o', 'o', 'k', 'i', 'e', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'R', 'e', 'q', 'u', 'e', 's', 't', 0,
    'r', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'A', 'l', 'l', 'o', 'w', 'e', 'd', 0,
    'm', 'e', 't', 'a', 'D', 'a', 't', 'a', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'i', 'g', 'n', 'o', 'r', 'e', 'S', 's', 'l', 'E', 'r', 'r', 'o', 'r', 's', 0,
    'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'F', 'a', 'i', 'l', 'u', 'r', 'e', 0,
    's', 'e', 't', 'P', 'e', 'e', 'r', 'H', 'o', 's', 't', 'N', 'a', 'm', 'e', 0,
    's', 'e', 't', 'C', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'i', 'e', 's', 0,
    'F', 't', 'p', 'C', 'a', 'c', 'h', 'i', 'n', 'g', 'P', 'r', 'o', 'x', 'y', 0,
    'h', 'a', 'r', 'd', 'w', 'a', 'r', 'e', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'i', 's', 'L', 'i', 'f', 'e', 't', 'i', 'm', 'e', 'K', 'n', 'o', 'w', 'n', 0,
    's', 'e', 't', 'P', 'r', 'e', 'f', 'i', 'x', 'L', 'e', 'n', 'g', 't', 'h', 0,
    'd', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'o', 'r', 't', 0,
    'i', 's', 'S', 'e', 's', 's', 'i', 'o', 'n', 'C', 'o', 'o', 'k', 'i', 'e', 0,
    'B', 'e', 'a', 'r', 'e', 'r', 'B', 'l', 'u', 'e', 't', 'o', 'o', 't', 'h', 0,
    'u', 'p', 'd', 'a', 't', 'e', 'C', 'o', 'm', 'p', 'l', 'e', 't', 'e', 'd', 0,
    's', 'e', 't', 'P', 'r', 'o', 'x', 'y', 'F', 'a', 'c', 't', 'o', 'r', 'y', 0,
    'C', 'u', 's', 't', 'o', 'm', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'D', 'e', 'l', 'e', 't', 'e', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'c', 'o', 'n', 'n', 'e', 'c', 't', 'T', 'o', 'S', 'e', 'r', 'v', 'e', 'r', 0,
    'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 'E', 'r', 'r', 'o', 'r', 0,
    'P', 'e', 'e', 'r', 'C', 'l', 'o', 's', 'e', 'd', 'E', 'r', 'r', 'o', 'r', 0,
    'A', 'l', 't', 'e', 'r', 'n', 'a', 't', 'i', 'v', 'e', 'T', 'y', 'p', 'e', 0,
    'l', 'o', 'c', 'a', 'l', 'D', 'o', 'm', 'a', 'i', 'n', 'N', 'a', 'm', 'e', 0,
    'a', 'b', 'o', 'r', 't', 'H', 'o', 's', 't', 'L', 'o', 'o', 'k', 'u', 'p', 0,
    's', 'e', 't', 'S', 'o', 'c', 'k', 'e', 't', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'K', 'e', 'e', 'p', 'A', 'l', 'i', 'v', 'e', 'O', 'p', 't', 'i', 'o', 'n', 0,
    's', 'e', 't', 'L', 'o', 'c', 'a', 'l', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'n', 'g', 'S', 't', 'a', 't', 'e', 0,
    'H', 'o', 's', 't', 'L', 'o', 'o', 'k', 'u', 'p', 'S', 't', 'a', 't', 'e', 0,
    'Q', 'A', 'b', 's', 't', 'r', 'a', 'c', 't', 'S', 'o', 'c', 'k', 'e', 't', 0,
    's', 'e', 't', 'L', 'a', 's', 't', 'M', 'o', 'd', 'i', 'f', 'i', 'e', 'd', 0,
    'P', 'y', 'Q', 't', '5', '.', 'Q', 't', 'N', 'e', 't', 'w', 'o', 'r', 'k', 0,
    'p', 'a', 'u', 's', 'e', 'A', 'c', 'c', 'e', 'p', 't', 'i', 'n', 'g', 0,
    'p', 'e', 'e', 'r', 'V', 'e', 'r', 'i', 'f', 'y', 'N', 'a', 'm', 'e', 0,
    'A', 'u', 't', 'o', 'V', 'e', 'r', 'i', 'f', 'y', 'P', 'e', 'e', 'r', 0,
    'd', 'e', 'f', 'a', 'u', 'l', 't', 'C', 'i', 'p', 'h', 'e', 'r', 's', 0,
    'I', 'n', 'v', 'a', 'l', 'i', 'd', 'P', 'u', 'r', 'p', 'o', 's', 'e', 0,
    'e', 'l', 'l', 'i', 'p', 't', 'i', 'c', 'C', 'u', 'r', 'v', 'e', 's', 0,
    'p', 'e', 'e', 'r', 'V', 'e', 'r', 'i', 'f', 'y', 'M', 'o', 'd', 'e', 0,
    'p', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'S', 't', 'r', 'i', 'n', 'g', 0,
    'c', 'a', 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 's', 0,
    'T', 'l', 's', 'V', '1', '_', '3', 'O', 'r', 'L', 'a', 't', 'e', 'r', 0,
    'T', 'l', 's', 'V', '1', '_', '2', 'O', 'r', 'L', 'a', 't', 'e', 'r', 0,
    'T', 'l', 's', 'V', '1', '_', '1', 'O', 'r', 'L', 'a', 't', 'e', 'r', 0,
    'T', 'l', 's', 'V', '1', '_', '0', 'O', 'r', 'L', 'a', 't', 'e', 'r', 0,
    'L', 'o', 'c', 'a', 't', 'i', 'o', 'n', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'r', 'a', 'w', 'H', 'e', 'a', 'd', 'e', 'r', 'P', 'a', 'i', 'r', 's', 0,
    'u', 'p', 'l', 'o', 'a', 'd', 'P', 'r', 'o', 'g', 'r', 'e', 's', 's', 0,
    's', 'e', 't', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'T', 'a', 'g', 0,
    'i', 's', 'C', 'a', 'c', 'h', 'i', 'n', 'g', 'P', 'r', 'o', 'x', 'y', 0,
    'a', 'd', 'd', 'r', 'e', 's', 's', 'E', 'n', 't', 'r', 'i', 'e', 's', 0,
    'I', 's', 'P', 'o', 'i', 'n', 't', 'T', 'o', 'P', 'o', 'i', 'n', 't', 0,
    'd', 'n', 's', 'E', 'l', 'i', 'g', 'i', 'b', 'i', 'l', 'i', 't', 'y', 0,
    'c', 'a', 'c', 'h', 'e', 'D', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', 0,
    's', 'e', 't', 'D', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', 0,
    'i', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 'I', 'n', 'd', 'e', 'x', 0,
    'v', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'C', 'o', 'o', 'k', 'i', 'e', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'C', 'o', 'o', 'k', 'i', 'e', 0,
    'c', 'o', 'n', 'n', 'e', 'c', 't', 'T', 'i', 'm', 'e', 'o', 'u', 't', 0,
    'b', 'e', 'a', 'r', 'e', 'r', 'T', 'y', 'p', 'e', 'N', 'a', 'm', 'e', 0,
    'B', 'e', 'a', 'r', 'e', 'r', 'C', 'D', 'M', 'A', '2', '0', '0', '0', 0,
    'B', 'e', 'a', 'r', 'e', 'r', 'E', 't', 'h', 'e', 'r', 'n', 'e', 't', 0,
    'P', 'r', 'i', 'v', 'a', 't', 'e', 'P', 'u', 'r', 'p', 'o', 's', 'e', 0,
    'U', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'u', 'r', 'p', 'o', 's', 'e', 0,
    'S', 'e', 'r', 'v', 'i', 'c', 'e', 'N', 'e', 't', 'w', 'o', 'r', 'k', 0,
    'D', 'a', 't', 'a', 'S', 't', 'a', 't', 'i', 's', 't', 'i', 'c', 's', 0,
    'r', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'P', 'o', 'l', 'i', 'c', 'y', 0,
    'd', 'e', 'l', 'e', 't', 'e', 'R', 'e', 's', 'o', 'u', 'r', 'c', 'e', 0,
    'f', 'u', 'l', 'l', 'S', 'e', 'r', 'v', 'e', 'r', 'N', 'a', 'm', 'e', 0,
    's', 'e', 't', 'C', 'o', 'n', 't', 'e', 'n', 't', 'T', 'y', 'p', 'e', 0,
    'Q', 'H', 't', 't', 'p', 'M', 'u', 'l', 't', 'i', 'P', 'a', 'r', 't', 0,
    's', 'e', 'r', 'v', 'i', 'c', 'e', 'R', 'e', 'c', 'o', 'r', 'd', 's', 0,
    'p', 'o', 'i', 'n', 't', 'e', 'r', 'R', 'e', 'c', 'o', 'r', 'd', 's', 0,
    'Q', 'D', 'n', 's', 'T', 'e', 'x', 't', 'R', 'e', 'c', 'o', 'r', 'd', 0,
    'Q', 'A', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'o', 'r', 0,
    'L', 'o', 'w', 'D', 'e', 'l', 'a', 'y', 'O', 'p', 't', 'i', 'o', 'n', 0,
    's', 'e', 't', 'P', 'e', 'e', 'r', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    's', 'e', 't', 'S', 'o', 'c', 'k', 'e', 't', 'E', 'r', 'r', 'o', 'r', 0,
    's', 'e', 't', 'S', 'o', 'c', 'k', 'e', 't', 'S', 't', 'a', 't', 'e', 0,
    'r', 'e', 'a', 'd', 'B', 'u', 'f', 'f', 'e', 'r', 'S', 'i', 'z', 'e', 0,
    'L', 'i', 's', 't', 'e', 'n', 'i', 'n', 'g', 'S', 't', 'a', 't', 'e', 0,
    'C', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd', 'S', 't', 'a', 't', 'e', 0,
    'T', 'e', 'm', 'p', 'o', 'r', 'a', 'r', 'y', 'E', 'r', 'r', 'o', 'r', 0,
    'u', 'p', 'd', 'a', 't', 'e', 'M', 'e', 't', 'a', 'D', 'a', 't', 'a', 0,
    'e', 'x', 'p', 'i', 'r', 'a', 't', 'i', 'o', 'n', 'D', 'a', 't', 'e', 0,
    'N', 'o', 'r', 'm', 'a', 'l', 'P', 'r', 'i', 'o', 'r', 'i', 't', 'y', 0,
    's', 'e', 't', 'E', 'r', 'r', 'o', 'r', 'S', 't', 'r', 'i', 'n', 'g', 0,
    'b', 'y', 't', 'e', 's', 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0,
    'w', 'r', 'i', 't', 'e', 'D', 'a', 't', 'a', 'g', 'r', 'a', 'm', 0,
    's', 'e', 'r', 'v', 'e', 'r', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'S', 's', 'l', 'S', 'e', 'r', 'v', 'e', 'r', 'M', 'o', 'd', 'e', 0,
    'S', 's', 'l', 'C', 'l', 'i', 'e', 'n', 't', 'M', 'o', 'd', 'e', 0,
    'f', 'r', 'o', 'm', 'S', 'h', 'o', 'r', 't', 'N', 'a', 'm', 'e', 0,
    's', 'e', 's', 's', 'i', 'o', 'n', 'T', 'i', 'c', 'k', 'e', 't', 0,
    't', 'e', 's', 't', 'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 0,
    's', 'e', 't', 'P', 'r', 'i', 'v', 'a', 't', 'e', 'K', 'e', 'y', 0,
    's', 'e', 's', 's', 'i', 'o', 'n', 'C', 'i', 'p', 'h', 'e', 'r', 0,
    's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 'B', 'i', 't', 's', 0,
    'i', 's', 'B', 'l', 'a', 'c', 'k', 'l', 'i', 's', 't', 'e', 'd', 0,
    'e', 'f', 'f', 'e', 'c', 't', 'i', 'v', 'e', 'D', 'a', 't', 'e', 0,
    'Q', 'S', 's', 'l', ':', ':', 'K', 'e', 'y', 'T', 'y', 'p', 'e', 0,
    'u', 's', 'a', 'g', 'e', 'P', 'o', 'l', 'i', 'c', 'i', 'e', 's', 0,
    'w', 'a', 'i', 't', 'F', 'o', 'r', 'O', 'p', 'e', 'n', 'e', 'd', 0,
    'P', 'r', 'e', 'f', 'e', 'r', 'N', 'e', 't', 'w', 'o', 'r', 'k', 0,
    'A', 'l', 'w', 'a', 'y', 's', 'N', 'e', 't', 'w', 'o', 'r', 'k', 0,
    'I', 'f', 'M', 'a', 't', 'c', 'h', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'b', 'y', 't', 'e', 's', 'R', 'e', 'c', 'e', 'i', 'v', 'e', 'd', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'R', 'e', 'p', 'l', 'y', 0,
    'p', 'r', 'o', 'x', 'y', 'F', 'o', 'r', 'Q', 'u', 'e', 'r', 'y', 0,
    'r', 'a', 'w', 'H', 'e', 'a', 'd', 'e', 'r', 'L', 'i', 's', 't', 0,
    'Q', 'N', 'e', 't', 'w', 'o', 'r', 'k', 'P', 'r', 'o', 'x', 'y', 0,
    'a', 'l', 'l', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 's', 0,
    'D', 'n', 's', 'I', 'n', 'e', 'l', 'i', 'g', 'i', 'b', 'l', 'e', 0,
    's', 'e', 'n', 'd', 'e', 'r', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    's', 'e', 't', 'A', 'l', 'l', 'C', 'o', 'o', 'k', 'i', 'e', 's', 0,
    'c', 'o', 'o', 'k', 'i', 'e', 's', 'F', 'o', 'r', 'U', 'r', 'l', 0,
    'B', 'e', 'a', 'r', 'e', 'r', 'U', 'n', 'k', 'n', 'o', 'w', 'n', 0,
    'P', 'u', 'b', 'l', 'i', 'c', 'P', 'u', 'r', 'p', 'o', 's', 'e', 0,
    'F', 'o', 'r', 'c', 'e', 'd', 'R', 'o', 'a', 'm', 'i', 'n', 'g', 0,
    'N', 'o', 't', 'A', 'c', 'c', 'e', 's', 's', 'i', 'b', 'l', 'e', 0,
    'c', 'r', 'e', 'a', 't', 'e', 'R', 'e', 'q', 'u', 'e', 's', 't', 0,
    'P', 'o', 's', 't', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'H', 'e', 'a', 'd', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0,
    's', 'e', 't', 'S', 'e', 'r', 'v', 'e', 'r', 'N', 'a', 'm', 'e', 0,
    's', 'o', 'c', 'k', 'e', 't', 'O', 'p', 't', 'i', 'o', 'n', 's', 0,
    'n', 'e', 'w', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', 0,
    's', 'e', 't', 'B', 'o', 'd', 'y', 'D', 'e', 'v', 'i', 'c', 'e', 0,
    'l', 'o', 'c', 'a', 'l', 'H', 'o', 's', 't', 'N', 'a', 'm', 'e', 0,
    't', 'o', 'I', 'P', 'v', '6', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    't', 'o', 'I', 'P', 'v', '4', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'L', 'o', 'c', 'a', 'l', 'H', 'o', 's', 't', 'I', 'P', 'v', '6', 0,
    's', 'e', 't', 'N', 'a', 'm', 'e', 's', 'e', 'r', 'v', 'e', 'r', 0,
    'R', 'e', 's', 'o', 'l', 'v', 'e', 'r', 'E', 'r', 'r', 'o', 'r', 0,
    'c', 'o', 'n', 'n', 'e', 'c', 't', 'T', 'o', 'H', 'o', 's', 't', 0,
    'A', 'n', 'y', 'I', 'P', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    's', 'e', 't', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 's', 0,
    's', 'e', 't', 'S', 'a', 'v', 'e', 'T', 'o', 'D', 'i', 's', 'k', 0,
    's', 'e', 't', 'R', 'a', 'w', 'H', 'e', 'a', 'd', 'e', 'r', 's', 0,
    'c', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'r', 'e', 'a', 'd', 'D', 'a', 't', 'a', 'g', 'r', 'a', 'm', 0,
    'p', 'r', 'e', 'S', 'h', 'a', 'r', 'e', 'd', 'K', 'e', 'y', 0,
    'i', 'd', 'e', 'n', 't', 'i', 't', 'y', 'H', 'i', 'n', 't', 0,
    'N', 'o', 'S', 's', 'l', 'S', 'u', 'p', 'p', 'o', 'r', 't', 0,
    'f', 'r', 'o', 'm', 'L', 'o', 'n', 'g', 'N', 'a', 'm', 'e', 0,
    's', 'e', 't', 'S', 's', 'l', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'i', 'm', 'p', 'o', 'r', 't', 'P', 'k', 'c', 's', '1', '2', 0,
    'i', 's', 'S', 'e', 'l', 'f', 'S', 'i', 'g', 'n', 'e', 'd', 0,
    's', 'e', 'r', 'i', 'a', 'l', 'N', 'u', 'm', 'b', 'e', 'r', 0,
    'E', 'm', 'a', 'i', 'l', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'S', 'e', 'r', 'i', 'a', 'l', 'N', 'u', 'm', 'b', 'e', 'r', 0,
    'L', 'o', 'c', 'a', 'l', 'i', 't', 'y', 'N', 'a', 'm', 'e', 0,
    'O', 'r', 'g', 'a', 'n', 'i', 'z', 'a', 't', 'i', 'o', 'n', 0,
    'R', 'o', 'a', 'm', 'i', 'n', 'g', 'E', 'r', 'r', 'o', 'r', 0,
    'N', 'o', 't', 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0,
    'S', 'e', 'r', 'v', 'e', 'r', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    's', 'e', 't', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'p', 'e', 'e', 'r', 'H', 'o', 's', 't', 'N', 'a', 'm', 'e', 0,
    's', 'e', 't', 'Q', 'u', 'e', 'r', 'y', 'T', 'y', 'p', 'e', 0,
    'h', 'a', 's', 'R', 'a', 'w', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'D', 'e', 'f', 'a', 'u', 'l', 't', 'P', 'r', 'o', 'x', 'y', 0,
    'a', 'l', 'l', 'A', 'd', 'd', 'r', 'e', 's', 's', 'e', 's', 0,
    'C', 'a', 'n', 'M', 'u', 'l', 't', 'i', 'c', 'a', 's', 't', 0,
    'C', 'a', 'n', 'B', 'r', 'o', 'a', 'd', 'c', 'a', 's', 't', 0,
    'p', 'r', 'e', 'f', 'i', 'x', 'L', 'e', 'n', 'g', 't', 'h', 0,
    's', 'e', 't', 'B', 'r', 'o', 'a', 'd', 'c', 'a', 's', 't', 0,
    'f', 'i', 'l', 'e', 'M', 'e', 't', 'a', 'D', 'a', 't', 'a', 0,
    'd', 'e', 'l', 'e', 't', 'e', 'C', 'o', 'o', 'k', 'i', 'e', 0,
    'u', 'p', 'd', 'a', 't', 'e', 'C', 'o', 'o', 'k', 'i', 'e', 0,
    'i', 'n', 's', 'e', 'r', 't', 'C', 'o', 'o', 'k', 'i', 'e', 0,
    'p', 'a', 'r', 's', 'e', 'C', 'o', 'o', 'k', 'i', 'e', 's', 0,
    'c', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'i', 'e', 's', 0,
    'p', 'r', 'o', 'x', 'y', 'F', 'a', 'c', 't', 'o', 'r', 'y', 0,
    's', 'e', 't', 'C', 'o', 'o', 'k', 'i', 'e', 'J', 'a', 'r', 0,
    'P', 'u', 't', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'G', 'e', 't', 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'Q', 'L', 'o', 'c', 'a', 'l', 'S', 'o', 'c', 'k', 'e', 't', 0,
    'r', 'e', 'm', 'o', 'v', 'e', 'S', 'e', 'r', 'v', 'e', 'r', 0,
    'Q', 'L', 'o', 'c', 'a', 'l', 'S', 'e', 'r', 'v', 'e', 'r', 0,
    'F', 'o', 'r', 'm', 'D', 'a', 't', 'a', 'T', 'y', 'p', 'e', 0,
    's', 'e', 't', 'R', 'a', 'w', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    's', 'e', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', 'e', 's', 0,
    'H', 'o', 's', 't', 'N', 'o', 't', 'F', 'o', 'u', 'n', 'd', 0,
    'Q', 'H', 'o', 's', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    's', 'e', 't', 'P', 'a', 'u', 's', 'e', 'M', 'o', 'd', 'e', 0,
    's', 'o', 'c', 'k', 'e', 't', 'O', 'p', 't', 'i', 'o', 'n', 0,
    's', 'e', 't', 'L', 'o', 'c', 'a', 'l', 'P', 'o', 'r', 't', 0,
    'd', 'i', 's', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd', 0,
    'l', 'o', 'c', 'a', 'l', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'C', 'l', 'o', 's', 'i', 'n', 'g', 'S', 't', 'a', 't', 'e', 0,
    'I', 'P', 'v', '6', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    'I', 'P', 'v', '4', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    'H', 'i', 'g', 'h', 'P', 'r', 'i', 'o', 'r', 'i', 't', 'y', 0,
    'b', 'y', 't', 'e', 's', 'W', 'r', 'i', 't', 't', 'e', 'n', 0,
    'b', 'y', 't', 'e', 's', 'T', 'o', 'W', 'r', 'i', 't', 'e', 0,
    'l', 'a', 's', 't', 'M', 'o', 'd', 'i', 'f', 'i', 'e', 'd', 0,
    'r', 'e', 'a', 'd', 'L', 'i', 'n', 'e', 'D', 'a', 't', 'a', 0,
    'i', 's', 'S', 'e', 'q', 'u', 'e', 'n', 't', 'i', 'a', 'l', 0,
    's', 'e', 't', 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    's', 't', 'a', 't', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'd', 'e', 'f', 'a', 'u', 'l', 't', 'V', 'a', 'l', 'u', 'e', 0,
    'a', 'c', 'c', 'e', 'p', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'm', 'o', 'd', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    's', 'u', 'p', 'p', 'o', 'r', 't', 's', 'S', 's', 'l', 0,
    'i', 's', 'E', 'n', 'c', 'r', 'y', 'p', 't', 'e', 'd', 0,
    's', 'e', 't', 'I', 'd', 'e', 'n', 't', 'i', 't', 'y', 0,
    's', 'e', 't', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    'i', 's', 'S', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 0,
    'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0,
    's', 'u', 'b', 'j', 'e', 'c', 't', 'I', 'n', 'f', 'o', 0,
    'C', 'o', 'u', 'n', 't', 'r', 'y', 'N', 'a', 'm', 'e', 0,
    'A', 'n', 'y', 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    'A', 'l', 'w', 'a', 'y', 's', 'C', 'a', 'c', 'h', 'e', 0,
    'P', 'r', 'e', 'f', 'e', 'r', 'C', 'a', 'c', 'h', 'e', 0,
    's', 'e', 't', 'F', 'i', 'n', 'i', 's', 'h', 'e', 'd', 0,
    'p', 'r', 'o', 't', 'o', 'c', 'o', 'l', 'T', 'a', 'g', 0,
    'S', 'o', 'c', 'k', 's', '5', 'P', 'r', 'o', 'x', 'y', 0,
    'i', 's', 'T', 'e', 'm', 'p', 'o', 'r', 'a', 'r', 'y', 0,
    'i', 's', 'P', 'e', 'r', 'm', 'a', 'n', 'e', 'n', 't', 0,
    'D', 'n', 's', 'E', 'l', 'i', 'g', 'i', 'b', 'l', 'e', 0,
    's', 'e', 't', 'H', 'o', 'p', 'L', 'i', 'm', 'i', 't', 0,
    's', 'e', 't', 'H', 't', 't', 'p', 'O', 'n', 'l', 'y', 0,
    'B', 'e', 'a', 'r', 'e', 'r', 'W', 'i', 'M', 'A', 'X', 0,
    'B', 'e', 'a', 'r', 'e', 'r', 'W', 'C', 'D', 'M', 'A', 0,
    's', 'e', 'r', 'v', 'e', 'r', 'E', 'r', 'r', 'o', 'r', 0,
    'i', 's', 'L', 'i', 's', 't', 'e', 'n', 'i', 'n', 'g', 0,
    's', 'e', 't', 'B', 'o', 'u', 'n', 'd', 'a', 'r', 'y', 0,
    'R', 'e', 'l', 'a', 't', 'e', 'd', 'T', 'y', 'p', 'e', 0,
    'Q', 'H', 's', 't', 's', 'P', 'o', 'l', 'i', 'c', 'y', 0,
    's', 'e', 't', 'L', 'o', 'o', 'k', 'u', 'p', 'I', 'd', 0,
    's', 'e', 't', 'H', 'o', 's', 't', 'N', 'a', 'm', 'e', 0,
    'i', 's', 'B', 'r', 'o', 'a', 'd', 'c', 'a', 's', 't', 0,
    'i', 's', 'S', 'i', 't', 'e', 'L', 'o', 'c', 'a', 'l', 0,
    'i', 's', 'L', 'i', 'n', 'k', 'L', 'o', 'c', 'a', 'l', 0,
    'i', 's', 'M', 'u', 'l', 't', 'i', 'c', 'a', 's', 't', 0,
    'p', 'a', 'r', 's', 'e', 'S', 'u', 'b', 'n', 'e', 't', 0,
    't', 'y', 'p', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    'n', 'a', 'm', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'd', 0,
    't', 'e', 'x', 't', 'R', 'e', 'c', 'o', 'r', 'd', 's', 0,
    's', 'e', 't', 'P', 'e', 'e', 'r', 'N', 'a', 'm', 'e', 0,
    's', 'e', 't', 'P', 'e', 'e', 'r', 'P', 'o', 'r', 't', 0,
    'p', 'e', 'e', 'r', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'f', 'r', 'o', 'm', 'E', 'n', 'c', 'o', 'd', 'e', 'd', 0,
    's', 'e', 't', 'P', 'a', 's', 's', 'w', 'o', 'r', 'd', 0,
    's', 'e', 't', 'P', 'r', 'i', 'o', 'r', 'i', 't', 'y', 0,
    'L', 'o', 'w', 'P', 'r', 'i', 'o', 'r', 'i', 't', 'y', 0,
    'c', 'u', 's', 't', 'o', 'm', 'E', 'v', 'e', 'n', 't', 0,
    'e', 'v', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r', 0,
    'e', 'r', 'r', 'o', 'r', 'S', 't', 'r', 'i', 'n', 'g', 0,
    'c', 'a', 'n', 'R', 'e', 'a', 'd', 'L', 'i', 'n', 'e', 0,
    'Q', 'U', 'd', 'p', 'S', 'o', 'c', 'k', 'e', 't', 0,
    's', 'e', 'r', 'v', 'e', 'r', 'P', 'o', 'r', 't', 0,
    'Q', 'T', 'c', 'p', 'S', 'e', 'r', 'v', 'e', 'r', 0,
    'V', 'e', 'r', 'i', 'f', 'y', 'N', 'o', 'n', 'e', 0,
    'Q', 'S', 's', 'l', 'S', 'o', 'c', 'k', 'e', 't', 0,
    'Q', 'T', 'c', 'p', 'S', 'o', 'c', 'k', 'e', 't', 0,
    's', 'e', 't', 'C', 'i', 'p', 'h', 'e', 'r', 's', 0,
    'p', 'r', 'i', 'v', 'a', 't', 'e', 'K', 'e', 'y', 0,
    'Q', 'S', 's', 'l', 'C', 'i', 'p', 'h', 'e', 'r', 0,
    'i', 's', 'C', 'r', 'i', 't', 'i', 'c', 'a', 'l', 0,
    'p', 'a', 's', 's', 'P', 'h', 'r', 'a', 's', 'e', 0,
    'e', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', 's', 0,
    'f', 'r', 'o', 'm', 'D', 'e', 'v', 'i', 'c', 'e', 0,
    'e', 'x', 'p', 'i', 'r', 'y', 'D', 'a', 't', 'e', 0,
    'i', 's', 's', 'u', 'e', 'r', 'I', 'n', 'f', 'o', 0,
    'C', 'o', 'm', 'm', 'o', 'n', 'N', 'a', 'm', 'e', 0,
    'T', 'l', 's', 'V', '1', 'S', 's', 'l', 'V', '3', 0,
    'E', 'm', 'a', 'i', 'l', 'E', 'n', 't', 'r', 'y', 0,
    'a', 'c', 't', 'i', 'v', 'e', 'T', 'i', 'm', 'e', 0,
    'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'n', 'g', 0,
    'E', 'T', 'a', 'g', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    's', 'e', 't', 'R', 'e', 'q', 'u', 'e', 's', 't', 0,
    'r', 'e', 'd', 'i', 'r', 'e', 'c', 't', 'e', 'd', 0,
    'q', 'u', 'e', 'r', 'y', 'P', 'r', 'o', 'x', 'y', 0,
    'S', 'c', 't', 'p', 'S', 'e', 'r', 'v', 'e', 'r', 0,
    'U', 'r', 'l', 'R', 'e', 'q', 'u', 'e', 's', 't', 0,
    'I', 'e', 'e', 'e', '8', '0', '2', '1', '5', '4', 0,
    'I', 's', 'L', 'o', 'o', 'p', 'B', 'a', 'c', 'k', 0,
    's', 'e', 't', 'N', 'e', 't', 'm', 'a', 's', 'k', 0,
    's', 'e', 'n', 'd', 'e', 'r', 'P', 'o', 'r', 't', 0,
    'a', 'l', 'l', 'C', 'o', 'o', 'k', 'i', 'e', 's', 0,
    'i', 's', 'H', 't', 't', 'p', 'O', 'n', 'l', 'y', 0,
    'b', 'e', 'a', 'r', 'e', 'r', 'T', 'y', 'p', 'e', 0,
    'B', 'e', 'a', 'r', 'e', 'r', 'E', 'V', 'D', 'O', 0,
    'B', 'e', 'a', 'r', 'e', 'r', 'H', 'S', 'P', 'A', 0,
    'B', 'e', 'a', 'r', 'e', 'r', 'W', 'L', 'A', 'N', 0,
    'D', 'i', 's', 'c', 'o', 'v', 'e', 'r', 'e', 'd', 0,
    'U', 's', 'e', 'r', 'C', 'h', 'o', 'i', 'c', 'e', 0,
    'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', 0,
    's', 'e', 'r', 'v', 'e', 'r', 'N', 'a', 'm', 'e', 0,
    'l', 'o', 'o', 'k', 'u', 'p', 'H', 'o', 's', 't', 0,
    'Q', '_', 'I', 'P', 'V', '6', 'A', 'D', 'D', 'R', 0,
    'i', 's', 'L', 'o', 'o', 'p', 'b', 'a', 'c', 'k', 0,
    'i', 's', 'I', 'n', 'S', 'u', 'b', 'n', 'e', 't', 0,
    's', 'e', 't', 'S', 'c', 'o', 'p', 'e', 'I', 'd', 0,
    's', 'e', 't', 'A', 'd', 'd', 'r', 'e', 's', 's', 0,
    'n', 'a', 'm', 'e', 's', 'e', 'r', 'v', 'e', 'r', 0,
    'Q', 'D', 'n', 's', 'L', 'o', 'o', 'k', 'u', 'p', 0,
    'p', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', 0,
    't', 'i', 'm', 'e', 'T', 'o', 'L', 'i', 'v', 'e', 0,
    'P', 'a', 'u', 's', 'e', 'N', 'e', 'v', 'e', 'r', 0,
    's', 'o', 'c', 'k', 'e', 't', 'T', 'y', 'p', 'e', 0,
    'B', 'o', 'u', 'n', 'd', 'S', 't', 'a', 't', 'e', 0,
    'S', 'c', 't', 'p', 'S', 'o', 'c', 'k', 'e', 't', 0,
    's', 'a', 'v', 'e', 'T', 'o', 'D', 'i', 's', 'k', 0,
    'r', 'a', 'w', 'H', 'e', 'a', 'd', 'e', 'r', 's', 0,
    'a', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 's', 0,
    'i', 's', 'F', 'i', 'n', 'i', 's', 'h', 'e', 'd', 0,
    'c', 'h', 'i', 'l', 'd', 'E', 'v', 'e', 'n', 't', 0,
    't', 'i', 'm', 'e', 'r', 'E', 'v', 'e', 'n', 't', 0,
    '_', '_', 'r', 's', 'h', 'i', 'f', 't', '_', '_', 0,
    '_', '_', 'l', 's', 'h', 'i', 'f', 't', '_', '_', 0,
    '_', '_', 'i', 'n', 'v', 'e', 'r', 't', '_', '_', 0,
    'Q', 'u', 'e', 'r', 'y', 'P', 'e', 'e', 'r', 0,
    'Q', 'S', 's', 'l', 'E', 'r', 'r', 'o', 'r', 0,
    's', 'h', 'o', 'r', 't', 'N', 'a', 'm', 'e', 0,
    'p', 'u', 'b', 'l', 'i', 'c', 'K', 'e', 'y', 0,
    'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 0,
    'i', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 0,
    'A', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 0,
    'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0,
    'q', 'u', 'e', 'r', 'y', 'T', 'y', 'p', 'e', 0,
    'r', 'a', 'w', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'H', 't', 't', 'p', 'P', 'r', 'o', 'x', 'y', 0,
    'I', 'e', 'e', 'e', '8', '0', '2', '1', '6', 0,
    'S', 'i', 'x', 'L', 'o', 'W', 'P', 'A', 'N', 0,
    'I', 'e', 'e', 'e', '8', '0', '2', '1', '1', 0,
    'I', 's', 'R', 'u', 'n', 'n', 'i', 'n', 'g', 0,
    'b', 'r', 'o', 'a', 'd', 'c', 'a', 's', 't', 0,
    'm', 'a', 'k', 'e', 'R', 'e', 'p', 'l', 'y', 0,
    's', 'e', 't', 'S', 'e', 'n', 'd', 'e', 'r', 0,
    'n', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'e', 0,
    't', 'o', 'R', 'a', 'w', 'F', 'o', 'r', 'm', 0,
    's', 'e', 't', 'D', 'o', 'm', 'a', 'i', 'n', 0,
    's', 'e', 't', 'S', 'e', 'c', 'u', 'r', 'e', 0,
    'B', 'e', 'a', 'r', 'e', 'r', 'L', 'T', 'E', 0,
    's', 's', 'l', 'E', 'r', 'r', 'o', 'r', 's', 0,
    'e', 'n', 'c', 'r', 'y', 'p', 't', 'e', 'd', 0,
    'c', 'o', 'o', 'k', 'i', 'e', 'J', 'a', 'r', 0,
    'M', 'i', 'x', 'e', 'd', 'T', 'y', 'p', 'e', 0,
    's', 'e', 't', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    'Q', 'H', 't', 't', 'p', 'P', 'a', 'r', 't', 0,
    'i', 's', 'E', 'x', 'p', 'i', 'r', 'e', 'd', 0,
    's', 'e', 't', 'E', 'x', 'p', 'i', 'r', 'y', 0,
    'a', 'd', 'd', 'r', 'e', 's', 's', 'e', 's', 0,
    'Q', 'H', 'o', 's', 't', 'I', 'n', 'f', 'o', 0,
    's', 'e', 't', 'O', 'p', 't', 'i', 'o', 'n', 0,
    'p', 'a', 'u', 's', 'e', 'M', 'o', 'd', 'e', 0,
    'h', 'o', 's', 't', 'F', 'o', 'u', 'n', 'd', 0,
    'l', 'o', 'c', 'a', 'l', 'P', 'o', 'r', 't', 0,
    'c', 'a', 'c', 'h', 'e', 'S', 'i', 'z', 'e', 0,
    'i', 's', 'R', 'u', 'n', 'n', 'i', 'n', 'g', 0,
    'a', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0,
    'U', 'n', 'd', 'e', 'f', 'i', 'n', 'e', 'd', 0,
    'w', 'r', 'i', 't', 'e', 'D', 'a', 't', 'a', 0,
    'i', 'd', 'e', 'n', 't', 'i', 't', 'y', 0,
    'l', 'o', 'n', 'g', 'N', 'a', 'm', 'e', 0,
    'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g', 0,
    'u', 's', 'e', 'd', 'B', 'i', 't', 's', 0,
    'f', 'r', 'o', 'm', 'D', 'a', 't', 'a', 0,
    'f', 'r', 'o', 'm', 'P', 'a', 't', 'h', 0,
    'D', 't', 'l', 's', 'V', '1', '_', '2', 0,
    'D', 't', 'l', 's', 'V', '1', '_', '0', 0,
    'D', 'n', 's', 'E', 'n', 't', 'r', 'y', 0,
    'N', 'o', 'P', 'o', 'l', 'i', 'c', 'y', 0,
    'I', 'e', 'e', 'e', '1', '3', '9', '4', 0,
    'h', 'o', 'p', 'L', 'i', 'm', 'i', 't', 0,
    'i', 's', 'S', 'e', 'c', 'u', 'r', 'e', 0,
    'B', 'e', 'a', 'r', 'e', 'r', '4', 'G', 0,
    'B', 'e', 'a', 'r', 'e', 'r', '3', 'G', 0,
    'B', 'e', 'a', 'r', 'e', 'r', '2', 'G', 0,
    'i', 's', 'O', 'n', 'l', 'i', 'n', 'e', 0,
    's', 't', 'o', 'r', 'e', 'D', 'i', 'r', 0,
    's', 'e', 't', 'C', 'a', 'c', 'h', 'e', 0,
    't', 'i', 'm', 'e', 'd', 'O', 'u', 't', 0,
    'b', 'o', 'u', 'n', 'd', 'a', 'r', 'y', 0,
    'f', 'r', 'o', 'm', 'N', 'a', 'm', 'e', 0,
    'l', 'o', 'o', 'k', 'u', 'p', 'I', 'd', 0,
    's', 'e', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'i', 's', 'G', 'l', 'o', 'b', 'a', 'l', 0,
    'e', 'x', 'c', 'h', 'a', 'n', 'g', 'e', 0,
    's', 'e', 't', 'P', 'r', 'o', 'x', 'y', 0,
    'p', 'e', 'e', 'r', 'N', 'a', 'm', 'e', 0,
    'p', 'e', 'e', 'r', 'P', 'o', 'r', 't', 0,
    'p', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0,
    'h', 'o', 's', 't', 'N', 'a', 'm', 'e', 0,
    'm', 'e', 't', 'a', 'D', 'a', 't', 'a', 0,
    'p', 'a', 's', 's', 'w', 'o', 'r', 'd', 0,
    's', 'e', 't', 'V', 'a', 'l', 'u', 'e', 0,
    'c', 'h', 'i', 'l', 'd', 'r', 'e', 'n', 0,
    'p', 'r', 'i', 'o', 'r', 'i', 't', 'y', 0,
    't', 'o', 'S', 't', 'r', 'i', 'n', 'g', 0,
    'r', 'e', 'a', 'd', 'D', 'a', 't', 'a', 0,
    'f', 'i', 'n', 'i', 's', 'h', 'e', 'd', 0,
    '_', '_', 'h', 'a', 's', 'h', '_', '_', 0,
    '_', '_', 'b', 'o', 'o', 'l', '_', '_', 0,
    '_', '_', 'i', 'x', 'o', 'r', '_', '_', 0,
    '_', '_', 'i', 'a', 'n', 'd', '_', '_', 0,
    'Q', 'S', 's', 'l', 'K', 'e', 'y', 0,
    'c', 'i', 'p', 'h', 'e', 'r', 's', 0,
    'T', 'l', 's', 'V', '1', '_', '3', 0,
    'T', 'l', 's', 'V', '1', '_', '2', 0,
    'T', 'l', 's', 'V', '1', '_', '1', 0,
    'T', 'l', 's', 'V', '1', '_', '0', 0,
    'm', 'i', 'g', 'r', 'a', 't', 'e', 0,
    'C', 'l', 'o', 's', 'i', 'n', 'g', 0,
    'U', 's', 'e', 'r', 'M', 'a', 'x', 0,
    'm', 'a', 'n', 'a', 'g', 'e', 'r', 0,
    'N', 'o', 'P', 'r', 'o', 'x', 'y', 0,
    'V', 'i', 'r', 't', 'u', 'a', 'l', 0,
    'p', 'u', 'r', 'p', 'o', 's', 'e', 0,
    'D', 'e', 'f', 'i', 'n', 'e', 'd', 0,
    'r', 'e', 'q', 'u', 'e', 's', 't', 0,
    's', 'e', 't', 'B', 'o', 'd', 'y', 0,
    'i', 's', 'E', 'q', 'u', 'a', 'l', 0,
    'n', 'e', 't', 'm', 'a', 's', 'k', 0,
    's', 'c', 'o', 'p', 'e', 'I', 'd', 0,
    'A', 'n', 'y', 'I', 'P', 'v', '6', 0,
    'A', 'n', 'y', 'I', 'P', 'v', '4', 0,
    's', 'e', 't', 'N', 'a', 'm', 'e', 0,
    's', 'e', 't', 'U', 's', 'e', 'r', 0,
    'p', 'r', 'e', 'p', 'a', 'r', 'e', 0,
    's', 'e', 't', 'P', 'o', 'r', 't', 0,
    's', 'e', 't', 'H', 'o', 's', 't', 0,
    'm', 'a', 'x', 'S', 'i', 'z', 'e', 0,
    'a', 'd', 'd', 'r', 'e', 's', 's', 0,
    's', 'e', 't', 'T', 'y', 'p', 'e', 0,
    's', 'e', 't', 'P', 'a', 't', 'h', 0,
    'I', 'n', 'v', 'a', 'l', 'i', 'd', 0,
    'N', 'o', 'E', 'r', 'r', 'o', 'r', 0,
    'i', 's', 'E', 'm', 'p', 't', 'y', 0,
    'o', 'p', 't', 'i', 'o', 'n', 's', 0,
    's', 'e', 't', 'D', 'a', 't', 'a', 0,
    'i', 's', 'V', 'a', 'l', 'i', 'd', 0,
    '_', '_', 'x', 'o', 'r', '_', '_', 0,
    '_', '_', 'i', 'o', 'r', '_', '_', 0,
    '_', '_', 'a', 'n', 'd', '_', '_', 0,
    '_', '_', 'i', 'n', 't', '_', '_', 0,
    'v', 'e', 'r', 'i', 'f', 'y', 0,
    't', 'o', 'T', 'e', 'x', 't', 0,
    'd', 'i', 'g', 'e', 's', 't', 0,
    'O', 'p', 'a', 'q', 'u', 'e', 0,
    'c', 'l', 'o', 's', 'e', 'd', 0,
    'o', 'p', 'e', 'n', 'e', 'd', 0,
    'r', 'e', 'j', 'e', 'c', 't', 0,
    'M', 'a', 'n', 'u', 'a', 'l', 0,
    'P', 'h', 'o', 'n', 'e', 't', 0,
    'C', 'a', 'n', 'B', 'u', 's', 0,
    'e', 'x', 'p', 'i', 'r', 'e', 0,
    'd', 'o', 'm', 'a', 'i', 'n', 0,
    'A', 'c', 't', 'i', 'v', 'e', 0,
    'l', 'i', 's', 't', 'e', 'n', 0,
    'h', 'e', 'a', 'd', 'e', 'r', 0,
    'e', 'x', 'p', 'i', 'r', 'y', 0,
    'l', 'o', 'o', 'k', 'u', 'p', 0,
    'w', 'e', 'i', 'g', 'h', 't', 0,
    's', 'e', 't', 'U', 'r', 'l', 0,
    'i', 's', 'O', 'p', 'e', 'n', 0,
    'h', 'a', 'n', 'd', 'l', 'e', 0,
    'i', 'g', 'n', 'o', 'r', 'e', 0,
    'a', 'c', 'c', 'e', 'p', 't', 0,
    'o', 'p', 't', 'i', 'o', 'n', 0,
    'v', 'a', 'l', 'u', 'e', 's', 0,
    's', 'y', 'n', 't', 'a', 'x', 0,
    'd', 'e', 'v', 'i', 'c', 'e', 0,
    'f', 'o', 'r', 'm', 'a', 't', 0,
    'r', 'e', 'm', 'o', 'v', 'e', 0,
    'i', 'n', 's', 'e', 'r', 't', 0,
    'a', 'p', 'p', 'e', 'n', 'd', 0,
    'l', 'e', 'n', 'g', 't', 'h', 0,
    'i', 's', 'N', 'u', 'l', 'l', 0,
    't', 'a', 'r', 'g', 'e', 't', 0,
    'r', 'e', 's', 'u', 'm', 'e', 0,
    'p', 'a', 'r', 'e', 'n', 't', 0,
    '_', '_', 'n', 'e', '_', '_', 0,
    '_', '_', 'e', 'q', '_', '_', 0,
    '_', '_', 'o', 'r', '_', '_', 0,
    't', 'o', 'D', 'e', 'r', 0,
    't', 'o', 'P', 'e', 'm', 0,
    'S', 's', 'l', 'V', '2', 0,
    's', 'e', 't', 'I', 'p', 0,
    'c', 'a', 'c', 'h', 'e', 0,
    'C', 'N', 'A', 'M', 'E', 0,
    'r', 'e', 'a', 'l', 'm', 0,
    'p', 'r', 'o', 'x', 'y', 0,
    'a', 'b', 'o', 'r', 't', 0,
    'q', 'u', 'e', 'r', 'y', 0,
    'e', 'r', 'r', 'o', 'r', 0,
    'r', 'e', 's', 'e', 't', 0,
    'a', 't', 'E', 'n', 'd', 0,
    'c', 'l', 'o', 's', 'e', 0,
    'c', 'l', 'e', 'a', 'r', 0,
    'v', 'a', 'l', 'u', 'e', 0,
    'i', 'n', 'd', 'e', 'x', 0,
    'f', 'l', 'u', 's', 'h', 0,
    'f', 'l', 'a', 'g', 's', 0,
    'e', 'v', 'e', 'n', 't', 0,
    'm', 's', 'e', 'c', 's', 0,
    's', 't', 'a', 't', 'e', 0,
    'Q', 'S', 's', 'l', 0,
    'W', 'i', 'f', 'i', 0,
    'F', 'd', 'd', 'i', 0,
    'S', 'l', 'i', 'p', 0,
    'I', 's', 'U', 'p', 0,
    'F', 'u', 'l', 'l', 0,
    'p', 'o', 's', 't', 0,
    'h', 'e', 'a', 'd', 0,
    'A', 'A', 'A', 'A', 0,
    'u', 's', 'e', 'r', 0,
    'b', 'i', 'n', 'd', 0,
    'h', 'o', 's', 't', 0,
    'p', 'a', 't', 'h', 0,
    'm', 'o', 'd', 'e', 0,
    'n', 'a', 'm', 'e', 0,
    's', 'e', 'e', 'k', 0,
    'o', 'p', 'e', 'n', 0,
    's', 'i', 'z', 'e', 0,
    't', 'y', 'p', 'e', 0,
    's', 'w', 'a', 'p', 0,
    'd', 'a', 't', 'a', 0,
    's', 't', 'o', 'p', 0,
    'o', 'i', 'd', 0,
    'D', 's', 'a', 0,
    'R', 's', 'a', 0,
    'P', 'p', 'p', 0,
    'p', 'u', 't', 0,
    'A', 'n', 'y', 0,
    'T', 'X', 'T', 0,
    'S', 'R', 'V', 0,
    'P', 'T', 'R', 0,
    'A', 'N', 'Y', 0,
    'u', 'r', 'l', 0,
    'p', 'o', 's', 0,
    'E', 'c', 0,
    'N', 'S', 0,
    'M', 'X', 0,
};
#line 81 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhostinfo.sip"
// Imports from QtCore.
pyqt5_qtnetwork_get_connection_parts_t pyqt5_qtnetwork_get_connection_parts;
#line 1216 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

void sipVH_QtNetwork_40(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::qintptr a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "N", new  ::qintptr(a0), sipType_qintptr, SIP_NULLPTR);
}

 ::QTcpSocket* sipVH_QtNetwork_39(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod)
{
     ::QTcpSocket* sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "");

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "H0", sipType_QTcpSocket, &sipRes);

    return sipRes;
}

void sipVH_QtNetwork_38(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const QList< ::QSslError>& a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "N", new QList< ::QSslError>(a0), sipType_QList_0100QSslError, SIP_NULLPTR);
}

void sipVH_QtNetwork_37(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QSslConfiguration& a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "N", new  ::QSslConfiguration(a0), sipType_QSslConfiguration, SIP_NULLPTR);
}

void sipVH_QtNetwork_36(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QSslConfiguration& a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "D", &a0, sipType_QSslConfiguration, SIP_NULLPTR);
}

QList< ::QNetworkProxy> sipVH_QtNetwork_35(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QNetworkProxyQuery& a0)
{
    QList< ::QNetworkProxy> sipRes;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "N", new  ::QNetworkProxyQuery(a0), sipType_QNetworkProxyQuery, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "H5", sipType_QList_0100QNetworkProxy, &sipRes);

    return sipRes;
}

bool sipVH_QtNetwork_34(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QNetworkCookie& a0,const  ::QUrl& a1)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "NN", new  ::QNetworkCookie(a0), sipType_QNetworkCookie, SIP_NULLPTR, new  ::QUrl(a1), sipType_QUrl, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtNetwork_33(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QNetworkCookie& a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "N", new  ::QNetworkCookie(a0), sipType_QNetworkCookie, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtNetwork_32(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const QList< ::QNetworkCookie>& a0,const  ::QUrl& a1)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "NN", new QList< ::QNetworkCookie>(a0), sipType_QList_0100QNetworkCookie, SIP_NULLPTR, new  ::QUrl(a1), sipType_QUrl, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

QList< ::QNetworkCookie> sipVH_QtNetwork_31(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QUrl& a0)
{
    QList< ::QNetworkCookie> sipRes;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "N", new  ::QUrl(a0), sipType_QUrl, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "H5", sipType_QList_0100QNetworkCookie, &sipRes);

    return sipRes;
}

 ::QNetworkReply* sipVH_QtNetwork_30(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QNetworkAccessManager::Operation a0,const  ::QNetworkRequest& a1, ::QIODevice*a2)
{
     ::QNetworkReply* sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "FND", a0, sipType_QNetworkAccessManager_Operation, new  ::QNetworkRequest(a1), sipType_QNetworkRequest, SIP_NULLPTR, a2, sipType_QIODevice, SIP_NULLPTR);

    int sipRc = sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "H1", sipType_QNetworkReply, &sipRes);

    if (sipRc < 0)
        abort();

    return sipRes;
}

void sipVH_QtNetwork_29(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::quintptr a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "N", new  ::quintptr(a0), sipType_quintptr, SIP_NULLPTR);
}

 ::QLocalSocket* sipVH_QtNetwork_28(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod)
{
     ::QLocalSocket* sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "");

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "H0", sipType_QLocalSocket, &sipRes);

    return sipRes;
}

 ::QVariant sipVH_QtNetwork_27(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QAbstractSocket::SocketOption a0)
{
     ::QVariant sipRes;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "F", a0, sipType_QAbstractSocket_SocketOption);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "H5", sipType_QVariant, &sipRes);

    return sipRes;
}

void sipVH_QtNetwork_26(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QAbstractSocket::SocketOption a0,const  ::QVariant& a1)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "FN", a0, sipType_QAbstractSocket_SocketOption, new  ::QVariant(a1), sipType_QVariant, SIP_NULLPTR);
}

 ::qintptr sipVH_QtNetwork_25(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod)
{
     ::qintptr sipRes;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "");

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "H5", sipType_qintptr, &sipRes);

    return sipRes;
}

bool sipVH_QtNetwork_24(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::qintptr a0, ::QAbstractSocket::SocketState a1, ::QIODevice::OpenMode a2)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "NFN", new  ::qintptr(a0), sipType_qintptr, SIP_NULLPTR, a1, sipType_QAbstractSocket_SocketState, new  ::QIODevice::OpenMode(a2), sipType_QIODevice_OpenMode, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

void sipVH_QtNetwork_23(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::qint64 a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "n", a0);
}

void sipVH_QtNetwork_22(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QHostAddress& a0, ::quint16 a1, ::QIODevice::OpenMode a2)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "NtN", new  ::QHostAddress(a0), sipType_QHostAddress, SIP_NULLPTR, a1, new  ::QIODevice::OpenMode(a2), sipType_QIODevice_OpenMode, SIP_NULLPTR);
}

void sipVH_QtNetwork_21(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QString& a0, ::quint16 a1, ::QIODevice::OpenMode a2, ::QAbstractSocket::NetworkLayerProtocol a3)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "NtNF", new  ::QString(a0), sipType_QString, SIP_NULLPTR, a1, new  ::QIODevice::OpenMode(a2), sipType_QIODevice_OpenMode, SIP_NULLPTR, a3, sipType_QAbstractSocket_NetworkLayerProtocol);
}

bool sipVH_QtNetwork_20(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QIODevice::OpenMode a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "N", new  ::QIODevice::OpenMode(a0), sipType_QIODevice_OpenMode, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtNetwork_19(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::qint64 a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "n", a0);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtNetwork_18(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "");

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtNetwork_17(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, int a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "i", a0);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

 ::qint64 sipVH_QtNetwork_16(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, char*a0, ::qint64 a1)
{
     ::qint64 sipRes = 0;
    int sipIsErr = 0;

#line 206 "sip/QtCore/qiodevice.sip"
        PyObject *result = sipCallMethod(&sipIsErr, sipMethod, "n", a1);
        
        if (result != NULL)
        {
            PyObject *buf;
        
            sipParseResult(&sipIsErr, sipMethod, result, "O", &buf);
        
            if (buf == Py_None)
                sipRes = -1L;
            else if (!SIPBytes_Check(buf))
            {
                sipBadCatcherResult(sipMethod);
                sipIsErr = 1;
            }
            else
            {
                memcpy(a0, SIPBytes_AsString(buf), SIPBytes_Size(buf));
                sipRes = SIPBytes_Size(buf);
            }
        
            Py_DECREF(buf);
            Py_DECREF(result);
        }
#line 1446 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

    Py_DECREF(sipMethod);

    if (sipIsErr)
        sipCallErrorHandler(sipErrorHandler, sipPySelf, sipGILState);

    SIP_RELEASE_GIL(sipGILState)

    return sipRes;
}

 ::qint64 sipVH_QtNetwork_15(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, char*a0, ::qint64 a1)
{
     ::qint64 sipRes = 0;
    int sipIsErr = 0;

#line 271 "sip/QtCore/qiodevice.sip"
        PyObject *result = sipCallMethod(&sipIsErr, sipMethod, "n", a1);
        
        if (result != NULL)
        {
            PyObject *buf;
        
            sipParseResult(&sipIsErr, sipMethod, result, "O", &buf);
        
            if (buf == Py_None)
                sipRes = -1L;
            else if (!SIPBytes_Check(buf))
            {
                sipBadCatcherResult(sipMethod);
                sipIsErr = 1;
            }
            else
            {
                memcpy(a0, SIPBytes_AsString(buf), SIPBytes_Size(buf));
                sipRes = SIPBytes_Size(buf);
            }
        
            Py_DECREF(buf);
            Py_DECREF(result);
        }
#line 1488 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

    Py_DECREF(sipMethod);

    if (sipIsErr)
        sipCallErrorHandler(sipErrorHandler, sipPySelf, sipGILState);

    SIP_RELEASE_GIL(sipGILState)

    return sipRes;
}

 ::qint64 sipVH_QtNetwork_14(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const char*a0,PY_LONG_LONG a1)
{
     ::qint64 sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "g", a0, (SIP_SSIZE_T)a1);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "n", &sipRes);

    return sipRes;
}

void sipVH_QtNetwork_13(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "");
}

void sipVH_QtNetwork_12(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QIODevice*a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "D", a0, sipType_QIODevice, SIP_NULLPTR);
}

 ::QIODevice* sipVH_QtNetwork_11(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QNetworkCacheMetaData& a0)
{
     ::QIODevice* sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "N", new  ::QNetworkCacheMetaData(a0), sipType_QNetworkCacheMetaData, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "H0", sipType_QIODevice, &sipRes);

    return sipRes;
}

 ::qint64 sipVH_QtNetwork_10(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod)
{
     ::qint64 sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "");

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "n", &sipRes);

    return sipRes;
}

bool sipVH_QtNetwork_9(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QUrl& a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "N", new  ::QUrl(a0), sipType_QUrl, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

 ::QIODevice* sipVH_QtNetwork_8(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QUrl& a0)
{
     ::QIODevice* sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "N", new  ::QUrl(a0), sipType_QUrl, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "H2", sipType_QIODevice, &sipRes);

    return sipRes;
}

void sipVH_QtNetwork_7(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QNetworkCacheMetaData& a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "N", new  ::QNetworkCacheMetaData(a0), sipType_QNetworkCacheMetaData, SIP_NULLPTR);
}

 ::QNetworkCacheMetaData sipVH_QtNetwork_6(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QUrl& a0)
{
     ::QNetworkCacheMetaData sipRes;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "N", new  ::QUrl(a0), sipType_QUrl, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "H5", sipType_QNetworkCacheMetaData, &sipRes);

    return sipRes;
}

bool sipVH_QtNetwork_5(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QEvent*a0)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "D", a0, sipType_QEvent, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

bool sipVH_QtNetwork_4(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QObject*a0, ::QEvent*a1)
{
    bool sipRes = 0;
    PyObject *sipResObj = sipCallMethod(SIP_NULLPTR, sipMethod, "DD", a0, sipType_QObject, SIP_NULLPTR, a1, sipType_QEvent, SIP_NULLPTR);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "b", &sipRes);

    return sipRes;
}

void sipVH_QtNetwork_3(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QTimerEvent*a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "D", a0, sipType_QTimerEvent, SIP_NULLPTR);
}

void sipVH_QtNetwork_2(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QChildEvent*a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "D", a0, sipType_QChildEvent, SIP_NULLPTR);
}

void sipVH_QtNetwork_1(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod,  ::QEvent*a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "D", a0, sipType_QEvent, SIP_NULLPTR);
}

void sipVH_QtNetwork_0(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::QMetaMethod& a0)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "N", new  ::QMetaMethod(a0), sipType_QMetaMethod, SIP_NULLPTR);
}


extern "C" {static PyObject *slot___rshift__(PyObject *,PyObject *);}
static PyObject *slot___rshift__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QDataStream* a0;
         ::QNetworkCacheMetaData* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_QDataStream, &a0, sipType_QNetworkCacheMetaData, &a1))
        {
             ::QDataStream*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = &(*a0 >> *a1);
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QDataStream,SIP_NULLPTR);
        }
    }

    {
         ::QDataStream* a0;
         ::QHostAddress* a1;
        int a1State = 0;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J1", sipType_QDataStream, &a0, sipType_QHostAddress, &a1, &a1State))
        {
             ::QDataStream*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = &(*a0 >> *a1);
            Py_END_ALLOW_THREADS
            sipReleaseType(a1,sipType_QHostAddress,a1State);

            return sipConvertFromType(sipRes,sipType_QDataStream,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot___lshift__(PyObject *,PyObject *);}
static PyObject *slot___lshift__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QDataStream* a0;
        const  ::QNetworkCacheMetaData* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_QDataStream, &a0, sipType_QNetworkCacheMetaData, &a1))
        {
             ::QDataStream*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = &(*a0 << *a1);
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QDataStream,SIP_NULLPTR);
        }
    }

    {
         ::QDataStream* a0;
        const  ::QHostAddress* a1;
        int a1State = 0;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J1", sipType_QDataStream, &a0, sipType_QHostAddress, &a1, &a1State))
        {
             ::QDataStream*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = &(*a0 << *a1);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QHostAddress *>(a1),sipType_QHostAddress,a1State);

            return sipConvertFromType(sipRes,sipType_QDataStream,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

static sipPySlotExtenderDef slotExtenders[] = {
    {(void *)slot___rshift__, rshift_slot, {0, 0, 0}},
    {(void *)slot___lshift__, lshift_slot, {0, 0, 0}},
    {SIP_NULLPTR, (sipPySlotType)0, {0, 0, 0}}
};


/* Convert to a sub-class if possible. */
extern "C" {static const sipTypeDef *sipSubClass_QAbstractSocket(void **);}
static const sipTypeDef *sipSubClass_QAbstractSocket(void **sipCppRet)
{
     ::QObject *sipCpp = reinterpret_cast< ::QObject *>(*sipCppRet);
    const sipTypeDef *sipType;

#line 30 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
    static struct class_graph {
        const char *name;
        sipTypeDef **type;
        int yes, no;
    } graph[] = {
        {sipName_QNetworkReply, &sipType_QNetworkReply, -1, 1},
        {sipName_QHttpMultiPart, &sipType_QHttpMultiPart, -1, 2},
        {sipName_QAbstractNetworkCache, &sipType_QAbstractNetworkCache, 12, 3},
        {sipName_QNetworkConfigurationManager, &sipType_QNetworkConfigurationManager, -1, 4},
        {sipName_QNetworkCookieJar, &sipType_QNetworkCookieJar, -1, 5},
        {sipName_QAbstractSocket, &sipType_QAbstractSocket, 13, 6},
        {sipName_QLocalSocket, &sipType_QLocalSocket, -1, 7},
        {sipName_QDnsLookup, &sipType_QDnsLookup, -1, 8},
        {sipName_QNetworkSession, &sipType_QNetworkSession, -1, 9},
        {sipName_QTcpServer, &sipType_QTcpServer, -1, 10},
        {sipName_QNetworkAccessManager, &sipType_QNetworkAccessManager, -1, 11},
        {sipName_QLocalServer, &sipType_QLocalServer, -1, -1},
        {sipName_QNetworkDiskCache, &sipType_QNetworkDiskCache, -1, -1},
        {sipName_QUdpSocket, &sipType_QUdpSocket, -1, 14},
        {sipName_QTcpSocket, &sipType_QTcpSocket, 15, -1},
    #if defined(SIP_FEATURE_PyQt_SSL)
        {sipName_QSslSocket, &sipType_QSslSocket, -1, -1},
    #else
        {0, 0, -1, -1},
    #endif
    };
    
    int i = 0;
    
    sipType = NULL;
    
    do
    {
        struct class_graph *cg = &graph[i];
    
        if (cg->name != NULL && sipCpp->inherits(cg->name))
        {
            sipType = *cg->type;
            i = cg->yes;
        }
        else
            i = cg->no;
    }
    while (i >= 0);
#line 1772 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

    return sipType;
}


extern "C" {static PyObject *slot_QSsl_SslOption___or__(PyObject *,PyObject *);}
static PyObject *slot_QSsl_SslOption___or__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSsl::SslOption a0;
         ::QSsl::SslOptions* a1;
        int a1State = 0;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "EJ1", sipType_QSsl_SslOption, &a0, sipType_QSsl_SslOptions, &a1, &a1State))
        {
             ::QSsl::SslOptions*sipRes;

            sipRes = new  ::QSsl::SslOptions((a0 | *a1));
            sipReleaseType(a1,sipType_QSsl_SslOptions,a1State);

            return sipConvertFromNewType(sipRes,sipType_QSsl_SslOptions,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

static sipPySlotDef slots_QSsl_SslOption[] = {
    {(void *)slot_QSsl_SslOption___or__, or_slot},
    {0, (sipPySlotType)0}
};



extern "C" {static PyObject *slot_QNetworkInterface_InterfaceFlag___or__(PyObject *,PyObject *);}
static PyObject *slot_QNetworkInterface_InterfaceFlag___or__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkInterface::InterfaceFlag a0;
         ::QNetworkInterface::InterfaceFlags* a1;
        int a1State = 0;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "EJ1", sipType_QNetworkInterface_InterfaceFlag, &a0, sipType_QNetworkInterface_InterfaceFlags, &a1, &a1State))
        {
             ::QNetworkInterface::InterfaceFlags*sipRes;

            sipRes = new  ::QNetworkInterface::InterfaceFlags((a0 | *a1));
            sipReleaseType(a1,sipType_QNetworkInterface_InterfaceFlags,a1State);

            return sipConvertFromNewType(sipRes,sipType_QNetworkInterface_InterfaceFlags,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

static sipPySlotDef slots_QNetworkInterface_InterfaceFlag[] = {
    {(void *)slot_QNetworkInterface_InterfaceFlag___or__, or_slot},
    {0, (sipPySlotType)0}
};



extern "C" {static PyObject *slot_QNetworkConfigurationManager_Capability___or__(PyObject *,PyObject *);}
static PyObject *slot_QNetworkConfigurationManager_Capability___or__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkConfigurationManager::Capability a0;
         ::QNetworkConfigurationManager::Capabilities* a1;
        int a1State = 0;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "EJ1", sipType_QNetworkConfigurationManager_Capability, &a0, sipType_QNetworkConfigurationManager_Capabilities, &a1, &a1State))
        {
             ::QNetworkConfigurationManager::Capabilities*sipRes;

            sipRes = new  ::QNetworkConfigurationManager::Capabilities((a0 | *a1));
            sipReleaseType(a1,sipType_QNetworkConfigurationManager_Capabilities,a1State);

            return sipConvertFromNewType(sipRes,sipType_QNetworkConfigurationManager_Capabilities,SIP_NULLPTR);
        }
    }

    {
         ::QNetworkConfigurationManager::Capability a0;
         ::QNetworkConfigurationManager::Capability a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "EE", sipType_QNetworkConfigurationManager_Capability, &a0, sipType_QNetworkConfigurationManager_Capability, &a1))
        {
             ::QNetworkConfigurationManager::Capabilities*sipRes;

            sipRes = new  ::QNetworkConfigurationManager::Capabilities((a0 | a1));

            return sipConvertFromNewType(sipRes,sipType_QNetworkConfigurationManager_Capabilities,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

static sipPySlotDef slots_QNetworkConfigurationManager_Capability[] = {
    {(void *)slot_QNetworkConfigurationManager_Capability___or__, or_slot},
    {0, (sipPySlotType)0}
};



extern "C" {static PyObject *slot_QLocalServer_SocketOption___or__(PyObject *,PyObject *);}
static PyObject *slot_QLocalServer_SocketOption___or__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QLocalServer::SocketOption a0;
         ::QLocalServer::SocketOptions* a1;
        int a1State = 0;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "EJ1", sipType_QLocalServer_SocketOption, &a0, sipType_QLocalServer_SocketOptions, &a1, &a1State))
        {
             ::QLocalServer::SocketOptions*sipRes;

            sipRes = new  ::QLocalServer::SocketOptions((a0 | *a1));
            sipReleaseType(a1,sipType_QLocalServer_SocketOptions,a1State);

            return sipConvertFromNewType(sipRes,sipType_QLocalServer_SocketOptions,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

static sipPySlotDef slots_QLocalServer_SocketOption[] = {
    {(void *)slot_QLocalServer_SocketOption___or__, or_slot},
    {0, (sipPySlotType)0}
};



extern "C" {static PyObject *slot_QHstsPolicy_PolicyFlag___or__(PyObject *,PyObject *);}
static PyObject *slot_QHstsPolicy_PolicyFlag___or__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QHstsPolicy::PolicyFlag a0;
         ::QHstsPolicy::PolicyFlags* a1;
        int a1State = 0;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "EJ1", sipType_QHstsPolicy_PolicyFlag, &a0, sipType_QHstsPolicy_PolicyFlags, &a1, &a1State))
        {
             ::QHstsPolicy::PolicyFlags*sipRes;

            sipRes = new  ::QHstsPolicy::PolicyFlags((a0 | *a1));
            sipReleaseType(a1,sipType_QHstsPolicy_PolicyFlags,a1State);

            return sipConvertFromNewType(sipRes,sipType_QHstsPolicy_PolicyFlags,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

static sipPySlotDef slots_QHstsPolicy_PolicyFlag[] = {
    {(void *)slot_QHstsPolicy_PolicyFlag___or__, or_slot},
    {0, (sipPySlotType)0}
};



extern "C" {static PyObject *slot_QHostAddress_ConversionModeFlag___or__(PyObject *,PyObject *);}
static PyObject *slot_QHostAddress_ConversionModeFlag___or__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QHostAddress::ConversionModeFlag a0;
         ::QHostAddress::ConversionMode* a1;
        int a1State = 0;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "EJ1", sipType_QHostAddress_ConversionModeFlag, &a0, sipType_QHostAddress_ConversionMode, &a1, &a1State))
        {
             ::QHostAddress::ConversionMode*sipRes;

            sipRes = new  ::QHostAddress::ConversionMode((a0 | *a1));
            sipReleaseType(a1,sipType_QHostAddress_ConversionMode,a1State);

            return sipConvertFromNewType(sipRes,sipType_QHostAddress_ConversionMode,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

static sipPySlotDef slots_QHostAddress_ConversionModeFlag[] = {
    {(void *)slot_QHostAddress_ConversionModeFlag___or__, or_slot},
    {0, (sipPySlotType)0}
};



extern "C" {static PyObject *slot_QHostAddress_SpecialAddress___eq__(PyObject *,PyObject *);}
static PyObject *slot_QHostAddress_SpecialAddress___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QHostAddress::SpecialAddress sipCpp = static_cast< ::QHostAddress::SpecialAddress>(sipConvertToEnum(sipSelf, sipType_QHostAddress_SpecialAddress));

    if (PyErr_Occurred())
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QHostAddress* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J1", sipType_QHostAddress, &a0, &a0State))
        {
            bool sipRes;

            sipRes = operator==(sipCpp, *a0);
            sipReleaseType(const_cast< ::QHostAddress *>(a0),sipType_QHostAddress,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_QHostAddress_SpecialAddress___ne__(PyObject *,PyObject *);}
static PyObject *slot_QHostAddress_SpecialAddress___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QHostAddress::SpecialAddress sipCpp = static_cast< ::QHostAddress::SpecialAddress>(sipConvertToEnum(sipSelf, sipType_QHostAddress_SpecialAddress));

    if (PyErr_Occurred())
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QHostAddress* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J1", sipType_QHostAddress, &a0, &a0State))
        {
            bool sipRes;

            sipRes = operator!=(sipCpp, *a0);
            sipReleaseType(const_cast< ::QHostAddress *>(a0),sipType_QHostAddress,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

static sipPySlotDef slots_QHostAddress_SpecialAddress[] = {
    {(void *)slot_QHostAddress_SpecialAddress___eq__, eq_slot},
    {(void *)slot_QHostAddress_SpecialAddress___ne__, ne_slot},
    {0, (sipPySlotType)0}
};



extern "C" {static PyObject *slot_QAbstractSocket_PauseMode___or__(PyObject *,PyObject *);}
static PyObject *slot_QAbstractSocket_PauseMode___or__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QAbstractSocket::PauseMode a0;
         ::QAbstractSocket::PauseModes* a1;
        int a1State = 0;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "EJ1", sipType_QAbstractSocket_PauseMode, &a0, sipType_QAbstractSocket_PauseModes, &a1, &a1State))
        {
             ::QAbstractSocket::PauseModes*sipRes;

            sipRes = new  ::QAbstractSocket::PauseModes((a0 | *a1));
            sipReleaseType(a1,sipType_QAbstractSocket_PauseModes,a1State);

            return sipConvertFromNewType(sipRes,sipType_QAbstractSocket_PauseModes,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

static sipPySlotDef slots_QAbstractSocket_PauseMode[] = {
    {(void *)slot_QAbstractSocket_PauseMode___or__, or_slot},
    {0, (sipPySlotType)0}
};



extern "C" {static PyObject *slot_QAbstractSocket_BindFlag___or__(PyObject *,PyObject *);}
static PyObject *slot_QAbstractSocket_BindFlag___or__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QAbstractSocket::BindFlag a0;
         ::QAbstractSocket::BindMode* a1;
        int a1State = 0;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "EJ1", sipType_QAbstractSocket_BindFlag, &a0, sipType_QAbstractSocket_BindMode, &a1, &a1State))
        {
             ::QAbstractSocket::BindMode*sipRes;

            sipRes = new  ::QAbstractSocket::BindMode((a0 | *a1));
            sipReleaseType(a1,sipType_QAbstractSocket_BindMode,a1State);

            return sipConvertFromNewType(sipRes,sipType_QAbstractSocket_BindMode,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

static sipPySlotDef slots_QAbstractSocket_BindFlag[] = {
    {(void *)slot_QAbstractSocket_BindFlag___or__, or_slot},
    {0, (sipPySlotType)0}
};

static sipEnumTypeDef enumTypes[] = {
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSslSocket__PeerVerifyMode, {0}, 0}, sipNameNr_PeerVerifyMode, 125, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSslSocket__SslMode, {0}, 0}, sipNameNr_SslMode, 125, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSslError__SslError, {0}, 0}, sipNameNr_SslError, 121, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSslDiffieHellmanParameters__Error, {0}, 0}, sipNameNr_Error, 118, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSslConfiguration__NextProtocolNegotiationStatus, {0}, 0}, sipNameNr_NextProtocolNegotiationStatus, 116, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSslCertificate__SubjectInfo, {0}, 0}, sipNameNr_SubjectInfo, 112, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSsl__SslOption, {0}, 0}, sipNameNr_SslOption, 104, slots_QSsl_SslOption},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSsl__SslProtocol, {0}, 0}, sipNameNr_SslProtocol, 104, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSsl__AlternativeNameEntryType, {0}, 0}, sipNameNr_AlternativeNameEntryType, 104, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSsl__KeyAlgorithm, {0}, 0}, sipNameNr_KeyAlgorithm, 104, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSsl__EncodingFormat, {0}, 0}, sipNameNr_EncodingFormat, 104, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QSsl__KeyType, {0}, 0}, sipNameNr_KeyType, 104, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkSession__UsagePolicy, {0}, 0}, sipNameNr_UsagePolicy, 97, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkSession__SessionError, {0}, 0}, sipNameNr_SessionError, 97, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkSession__State, {0}, 0}, sipNameNr_State, 97, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkRequest__RedirectPolicy, {0}, 0}, sipNameNr_RedirectPolicy, 90, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkRequest__Priority, {0}, 0}, sipNameNr_Priority, 90, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkRequest__LoadControl, {0}, 0}, sipNameNr_LoadControl, 90, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkRequest__CacheLoadControl, {0}, 0}, sipNameNr_CacheLoadControl, 90, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkRequest__Attribute, {0}, 0}, sipNameNr_Attribute, 90, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkRequest__KnownHeaders, {0}, 0}, sipNameNr_KnownHeaders, 90, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkReply__NetworkError, {0}, 0}, sipNameNr_NetworkError, 88, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkProxyQuery__QueryType, {0}, 0}, sipNameNr_QueryType, 86, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkProxy__Capability, {0}, 0}, sipNameNr_Capability, 81, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkProxy__ProxyType, {0}, 0}, sipNameNr_ProxyType, 81, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkInterface__InterfaceType, {0}, 0}, sipNameNr_InterfaceType, 77, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkInterface__InterfaceFlag, {0}, 0}, sipNameNr_InterfaceFlag, 77, slots_QNetworkInterface_InterfaceFlag},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkAddressEntry__DnsEligibilityStatus, {0}, 0}, sipNameNr_DnsEligibilityStatus, 60, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkCookie__RawForm, {0}, 0}, sipNameNr_RawForm, 72, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkConfiguration__BearerType, {0}, 0}, sipNameNr_BearerType, 63, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkConfiguration__StateFlag, {0}, 0}, sipNameNr_StateFlag, 63, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkConfiguration__Purpose, {0}, 0}, sipNameNr_Purpose, 63, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkConfiguration__Type, {0}, 0}, sipNameNr_Type, 63, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkConfigurationManager__Capability, {0}, 0}, sipNameNr_Capability, 69, slots_QNetworkConfigurationManager_Capability},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkAccessManager__NetworkAccessibility, {0}, 0}, sipNameNr_NetworkAccessibility, 57, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QNetworkAccessManager__Operation, {0}, 0}, sipNameNr_Operation, 57, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QLocalSocket__LocalSocketState, {0}, 0}, sipNameNr_LocalSocketState, 52, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QLocalSocket__LocalSocketError, {0}, 0}, sipNameNr_LocalSocketError, 52, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QLocalServer__SocketOption, {0}, 0}, sipNameNr_SocketOption, 49, slots_QLocalServer_SocketOption},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QHttpMultiPart__ContentType, {0}, 0}, sipNameNr_ContentType, 30, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QHstsPolicy__PolicyFlag, {0}, 0}, sipNameNr_PolicyFlag, 27, slots_QHstsPolicy_PolicyFlag},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QHostInfo__HostInfoError, {0}, 0}, sipNameNr_HostInfoError, 25, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QHostAddress__ConversionModeFlag, {0}, 0}, sipNameNr_ConversionModeFlag, 21, slots_QHostAddress_ConversionModeFlag},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QHostAddress__SpecialAddress, {0}, 0}, sipNameNr_SpecialAddress, 21, slots_QHostAddress_SpecialAddress},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QDnsLookup__Type, {0}, 0}, sipNameNr_Type, 14, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QDnsLookup__Error, {0}, 0}, sipNameNr_Error, 14, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QAbstractSocket__PauseMode, {0}, 0}, sipNameNr_PauseMode, 1, slots_QAbstractSocket_PauseMode},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QAbstractSocket__BindFlag, {0}, 0}, sipNameNr_BindFlag, 1, slots_QAbstractSocket_BindFlag},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QAbstractSocket__SocketOption, {0}, 0}, sipNameNr_SocketOption, 1, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QAbstractSocket__SocketState, {0}, 0}, sipNameNr_SocketState, 1, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QAbstractSocket__SocketError, {0}, 0}, sipNameNr_SocketError, 1, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QAbstractSocket__NetworkLayerProtocol, {0}, 0}, sipNameNr_NetworkLayerProtocol, 1, SIP_NULLPTR},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_QAbstractSocket__SocketType, {0}, 0}, sipNameNr_SocketType, 1, SIP_NULLPTR},
};


/*
 * This defines each type in this module.
 */
sipTypeDef *sipExportedTypes_QtNetwork[] = {
    &sipTypeDef_QtNetwork_QAbstractNetworkCache.ctd_base,
    &sipTypeDef_QtNetwork_QAbstractSocket.ctd_base,
    &enumTypes[47].etd_base,
    &sipTypeDef_QtNetwork_QAbstractSocket_BindMode.ctd_base,
    &enumTypes[51].etd_base,
    &enumTypes[46].etd_base,
    &sipTypeDef_QtNetwork_QAbstractSocket_PauseModes.ctd_base,
    &enumTypes[50].etd_base,
    &enumTypes[48].etd_base,
    &enumTypes[49].etd_base,
    &enumTypes[52].etd_base,
    &sipTypeDef_QtNetwork_QAuthenticator.ctd_base,
    &sipTypeDef_QtNetwork_QDnsDomainNameRecord.ctd_base,
    &sipTypeDef_QtNetwork_QDnsHostAddressRecord.ctd_base,
    &sipTypeDef_QtNetwork_QDnsLookup.ctd_base,
    &enumTypes[45].etd_base,
    &enumTypes[44].etd_base,
    &sipTypeDef_QtNetwork_QDnsMailExchangeRecord.ctd_base,
    &sipTypeDef_QtNetwork_QDnsServiceRecord.ctd_base,
    &sipTypeDef_QtNetwork_QDnsTextRecord.ctd_base,
    &sipTypeDef_QtNetwork_QHash_0100QNetworkRequest_Attribute_0100QVariant.mtd_base,
    &sipTypeDef_QtNetwork_QHostAddress.ctd_base,
    &sipTypeDef_QtNetwork_QHostAddress_ConversionMode.ctd_base,
    &enumTypes[42].etd_base,
    &enumTypes[43].etd_base,
    &sipTypeDef_QtNetwork_QHostInfo.ctd_base,
    &enumTypes[41].etd_base,
    &sipTypeDef_QtNetwork_QHstsPolicy.ctd_base,
    &enumTypes[40].etd_base,
    &sipTypeDef_QtNetwork_QHstsPolicy_PolicyFlags.ctd_base,
    &sipTypeDef_QtNetwork_QHttpMultiPart.ctd_base,
    &enumTypes[39].etd_base,
    &sipTypeDef_QtNetwork_QHttpPart.ctd_base,
    &sipTypeDef_QtNetwork_QList_0100QDnsDomainNameRecord.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QDnsHostAddressRecord.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QDnsMailExchangeRecord.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QDnsServiceRecord.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QDnsTextRecord.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QHostAddress.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QNetworkAddressEntry.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QNetworkConfiguration.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QNetworkCookie.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QNetworkInterface.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QNetworkProxy.mtd_base,
    &sipTypeDef_QtNetwork_QList_0600QPair_0100QByteArray_0100QByteArray.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QSslCertificate.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QSslCertificateExtension.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QSslCipher.mtd_base,
    &sipTypeDef_QtNetwork_QList_0100QSslError.mtd_base,
    &sipTypeDef_QtNetwork_QLocalServer.ctd_base,
    &enumTypes[38].etd_base,
    &sipTypeDef_QtNetwork_QLocalServer_SocketOptions.ctd_base,
    &sipTypeDef_QtNetwork_QLocalSocket.ctd_base,
    &enumTypes[37].etd_base,
    &enumTypes[36].etd_base,
    &sipTypeDef_QtNetwork_QMap_0100QByteArray_0100QVariant.mtd_base,
    &sipTypeDef_QtNetwork_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString.mtd_base,
    &sipTypeDef_QtNetwork_QNetworkAccessManager.ctd_base,
    &enumTypes[34].etd_base,
    &enumTypes[35].etd_base,
    &sipTypeDef_QtNetwork_QNetworkAddressEntry.ctd_base,
    &enumTypes[27].etd_base,
    &sipTypeDef_QtNetwork_QNetworkCacheMetaData.ctd_base,
    &sipTypeDef_QtNetwork_QNetworkConfiguration.ctd_base,
    &enumTypes[29].etd_base,
    &enumTypes[31].etd_base,
    &enumTypes[30].etd_base,
    &sipTypeDef_QtNetwork_QNetworkConfiguration_StateFlags.ctd_base,
    &enumTypes[32].etd_base,
    &sipTypeDef_QtNetwork_QNetworkConfigurationManager.ctd_base,
    &sipTypeDef_QtNetwork_QNetworkConfigurationManager_Capabilities.ctd_base,
    &enumTypes[33].etd_base,
    &sipTypeDef_QtNetwork_QNetworkCookie.ctd_base,
    &enumTypes[28].etd_base,
    &sipTypeDef_QtNetwork_QNetworkCookieJar.ctd_base,
    &sipTypeDef_QtNetwork_QNetworkDatagram.ctd_base,
    &sipTypeDef_QtNetwork_QNetworkDiskCache.ctd_base,
    &sipTypeDef_QtNetwork_QNetworkInterface.ctd_base,
    &enumTypes[26].etd_base,
    &sipTypeDef_QtNetwork_QNetworkInterface_InterfaceFlags.ctd_base,
    &enumTypes[25].etd_base,
    &sipTypeDef_QtNetwork_QNetworkProxy.ctd_base,
    &sipTypeDef_QtNetwork_QNetworkProxy_Capabilities.ctd_base,
    &enumTypes[23].etd_base,
    &enumTypes[24].etd_base,
    &sipTypeDef_QtNetwork_QNetworkProxyFactory.ctd_base,
    &sipTypeDef_QtNetwork_QNetworkProxyQuery.ctd_base,
    &enumTypes[22].etd_base,
    &sipTypeDef_QtNetwork_QNetworkReply.ctd_base,
    &enumTypes[21].etd_base,
    &sipTypeDef_QtNetwork_QNetworkRequest.ctd_base,
    &enumTypes[19].etd_base,
    &enumTypes[18].etd_base,
    &enumTypes[20].etd_base,
    &enumTypes[17].etd_base,
    &enumTypes[16].etd_base,
    &enumTypes[15].etd_base,
    &sipTypeDef_QtNetwork_QNetworkSession.ctd_base,
    &enumTypes[13].etd_base,
    &enumTypes[14].etd_base,
    &sipTypeDef_QtNetwork_QNetworkSession_UsagePolicies.ctd_base,
    &enumTypes[12].etd_base,
    &sipTypeDef_QtNetwork_QPair_0100QHostAddress_1800.mtd_base,
    &sipTypeDef_QtNetwork_QPasswordDigestor.ctd_base,
    &sipTypeDef_QtNetwork_QSsl.ctd_base,
    &enumTypes[8].etd_base,
    &enumTypes[10].etd_base,
    &enumTypes[9].etd_base,
    &enumTypes[11].etd_base,
    &enumTypes[6].etd_base,
    &sipTypeDef_QtNetwork_QSsl_SslOptions.ctd_base,
    &enumTypes[7].etd_base,
    &sipTypeDef_QtNetwork_QSslCertificate.ctd_base,
    &enumTypes[5].etd_base,
    &sipTypeDef_QtNetwork_QSslCertificateExtension.ctd_base,
    &sipTypeDef_QtNetwork_QSslCipher.ctd_base,
    &sipTypeDef_QtNetwork_QSslConfiguration.ctd_base,
    &enumTypes[4].etd_base,
    &sipTypeDef_QtNetwork_QSslDiffieHellmanParameters.ctd_base,
    &enumTypes[3].etd_base,
    &sipTypeDef_QtNetwork_QSslEllipticCurve.ctd_base,
    &sipTypeDef_QtNetwork_QSslError.ctd_base,
    &enumTypes[2].etd_base,
    &sipTypeDef_QtNetwork_QSslKey.ctd_base,
    &sipTypeDef_QtNetwork_QSslPreSharedKeyAuthenticator.ctd_base,
    &sipTypeDef_QtNetwork_QSslSocket.ctd_base,
    &enumTypes[0].etd_base,
    &enumTypes[1].etd_base,
    &sipTypeDef_QtNetwork_QTcpServer.ctd_base,
    &sipTypeDef_QtNetwork_QTcpSocket.ctd_base,
    &sipTypeDef_QtNetwork_QUdpSocket.ctd_base,
    &sipTypeDef_QtNetwork_QVector_0100QHstsPolicy.mtd_base,
    &sipTypeDef_QtNetwork_QVector_0100QSslEllipticCurve.mtd_base,
    &sipTypeDef_QtNetwork_Q_IPV6ADDR.mtd_base,
};


/*
 * These define each typedef in this module.
 */
static sipTypedefDef typedefsTable[] = {
    {"QNetworkCacheMetaData::AttributesMap", "QHash<QNetworkRequest::Attribute,QVariant>"},
    {"QNetworkCacheMetaData::RawHeaderList", "QList<QPair<QByteArray,QByteArray> >"},
};


/* This defines the types that this module needs to import from QtCore. */
sipImportedTypeDef sipImportedTypes_QtNetwork_QtCore[] = {
    {"QByteArray"},
    {"QChildEvent"},
    {"QCryptographicHash::Algorithm"},
    {"QDataStream"},
    {"QDateTime"},
    {"QDeadlineTimer"},
    {"QEvent"},
    {"QHash<QString,QVariant>"},
    {"QIODevice"},
    {"QIODevice::OpenMode"},
    {"QList<QByteArray>"},
    {"QMetaMethod"},
    {"QObject"},
    {"QRegExp::PatternSyntax"},
    {"QString"},
    {"QStringList"},
    {"QTimerEvent"},
    {"QUrl"},
    {"QUrl::ComponentFormattingOptions"},
    {"QUrl::ParsingMode"},
    {"QVariant"},
    {"qintptr"},
    {"quintptr"},
    {SIP_NULLPTR}
};


/*
 * This defines the virtual error handlers that this module needs to import
 * from QtCore.
 */
sipImportedVirtErrorHandlerDef sipImportedVirtErrorHandlers_QtNetwork_QtCore[] = {
    {"PyQt5"},
    {SIP_NULLPTR}
};


/* This defines the modules that this module needs to import. */
static sipImportedModuleDef importsTable[] = {
    {"PyQt5.QtCore", sipImportedTypes_QtNetwork_QtCore, sipImportedVirtErrorHandlers_QtNetwork_QtCore, SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


/* This defines the class sub-convertors that this module defines. */
static sipSubClassConvertorDef convertorsTable[] = {
    {sipSubClass_QAbstractSocket, {12, 0, 0}, SIP_NULLPTR},
    {SIP_NULLPTR, {0, 0, 0}, SIP_NULLPTR}
};


/* This defines this module. */
sipExportedModuleDef sipModuleAPI_QtNetwork = {
    0,
    SIP_API_MINOR_NR,
    sipNameNr_PyQt5_QtNetwork,
    0,
    sipStrings_QtNetwork,
    importsTable,
    SIP_NULLPTR,
    134,
    sipExportedTypes_QtNetwork,
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    2,
    typedefsTable,
    SIP_NULLPTR,
    convertorsTable,
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    SIP_NULLPTR,
    SIP_NULLPTR,
    slotExtenders,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};


/* The SIP API and the APIs of any imported modules. */
const sipAPIDef *sipAPI_QtNetwork;

sip_qt_metaobject_func sip_QtNetwork_qt_metaobject;
sip_qt_metacall_func sip_QtNetwork_qt_metacall;
sip_qt_metacast_func sip_QtNetwork_qt_metacast;


/* The Python module initialisation function. */
#if PY_MAJOR_VERSION >= 3
#define SIP_MODULE_ENTRY        PyInit_QtNetwork
#define SIP_MODULE_TYPE         PyObject *
#define SIP_MODULE_DISCARD(r)   Py_DECREF(r)
#define SIP_MODULE_RETURN(r)    return (r)
#else
#define SIP_MODULE_ENTRY        initQtNetwork
#define SIP_MODULE_TYPE         void
#define SIP_MODULE_DISCARD(r)
#define SIP_MODULE_RETURN(r)    return
#endif

#if defined(SIP_STATIC_MODULE)
extern "C" SIP_MODULE_TYPE SIP_MODULE_ENTRY()
#else
PyMODINIT_FUNC SIP_MODULE_ENTRY()
#endif
{
    static PyMethodDef sip_methods[] = {
        {SIP_NULLPTR, SIP_NULLPTR, 0, SIP_NULLPTR}
    };

#if PY_MAJOR_VERSION >= 3
    static PyModuleDef sip_module_def = {
        PyModuleDef_HEAD_INIT,
        "PyQt5.QtNetwork",
        SIP_NULLPTR,
        -1,
        sip_methods,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_NULLPTR
    };
#endif

    PyObject *sipModule, *sipModuleDict;
    PyObject *sip_sipmod, *sip_capiobj;

    /* Initialise the module and get it's dictionary. */
#if PY_MAJOR_VERSION >= 3
    sipModule = PyModule_Create(&sip_module_def);
#elif PY_VERSION_HEX >= 0x02050000
    sipModule = Py_InitModule(sipName_PyQt5_QtNetwork, sip_methods);
#else
    sipModule = Py_InitModule(const_cast<char *>(sipName_PyQt5_QtNetwork), sip_methods);
#endif

    if (sipModule == SIP_NULLPTR)
        SIP_MODULE_RETURN(SIP_NULLPTR);

    sipModuleDict = PyModule_GetDict(sipModule);

    /* Get the SIP module's API. */
#if PY_VERSION_HEX >= 0x02050000
    sip_sipmod = PyImport_ImportModule("PyQt5.sip");
#else
    sip_sipmod = PyImport_ImportModule(const_cast<char *>("PyQt5.sip"));
#endif

    if (sip_sipmod == SIP_NULLPTR)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(SIP_NULLPTR);
    }

    sip_capiobj = PyDict_GetItemString(PyModule_GetDict(sip_sipmod), "_C_API");
    Py_DECREF(sip_sipmod);

#if defined(SIP_USE_PYCAPSULE)
    if (sip_capiobj == SIP_NULLPTR || !PyCapsule_CheckExact(sip_capiobj))
#else
    if (sip_capiobj == SIP_NULLPTR || !PyCObject_Check(sip_capiobj))
#endif
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(SIP_NULLPTR);
    }

#if defined(SIP_USE_PYCAPSULE)
    sipAPI_QtNetwork = reinterpret_cast<const sipAPIDef *>(PyCapsule_GetPointer(sip_capiobj, "PyQt5.sip._C_API"));
#else
    sipAPI_QtNetwork = reinterpret_cast<const sipAPIDef *>(PyCObject_AsVoidPtr(sip_capiobj));
#endif

#if defined(SIP_USE_PYCAPSULE)
    if (sipAPI_QtNetwork == SIP_NULLPTR)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(SIP_NULLPTR);
    }
#endif

    /* Export the module and publish it's API. */
    if (sipExportModule(&sipModuleAPI_QtNetwork,SIP_API_MAJOR_NR,SIP_API_MINOR_NR,0) < 0)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(SIP_NULLPTR);
    }

    sip_QtNetwork_qt_metaobject = (sip_qt_metaobject_func)sipImportSymbol("qtcore_qt_metaobject");
    sip_QtNetwork_qt_metacall = (sip_qt_metacall_func)sipImportSymbol("qtcore_qt_metacall");
    sip_QtNetwork_qt_metacast = (sip_qt_metacast_func)sipImportSymbol("qtcore_qt_metacast");

    if (!sip_QtNetwork_qt_metacast)
        Py_FatalError("Unable to import qtcore_qt_metacast");

    /* Initialise the module now all its dependencies have been set up. */
    if (sipInitModule(&sipModuleAPI_QtNetwork,sipModuleDict) < 0)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(SIP_NULLPTR);
    }
#line 86 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhostinfo.sip"
// Imports from QtCore.
pyqt5_qtnetwork_get_connection_parts = (pyqt5_qtnetwork_get_connection_parts_t)sipImportSymbol("pyqt5_get_connection_parts");
Q_ASSERT(pyqt5_qtnetwork_get_connection_parts);
#line 2579 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

    SIP_MODULE_RETURN(sipModule);
}

#line 27 "sip/QtCore/qpycore_qmap.sip"
#include <qmap.h>
#line 2586 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 2590 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 2593 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QMap_0100QByteArray_0100QVariant(void *, SIP_SSIZE_T, void *);}
static void assign_QMap_0100QByteArray_0100QVariant(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QMap< ::QByteArray, ::QVariant> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QMap< ::QByteArray, ::QVariant> *>(sipSrc);
}


extern "C" {static void *array_QMap_0100QByteArray_0100QVariant(SIP_SSIZE_T);}
static void *array_QMap_0100QByteArray_0100QVariant(SIP_SSIZE_T sipNrElem)
{
    return new QMap< ::QByteArray, ::QVariant>[sipNrElem];
}


extern "C" {static void *copy_QMap_0100QByteArray_0100QVariant(const void *, SIP_SSIZE_T);}
static void *copy_QMap_0100QByteArray_0100QVariant(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QMap< ::QByteArray, ::QVariant>(reinterpret_cast<const QMap< ::QByteArray, ::QVariant> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QMap_0100QByteArray_0100QVariant(void *, int);}
static void release_QMap_0100QByteArray_0100QVariant(void *ptr, int)
{
    delete reinterpret_cast<QMap< ::QByteArray, ::QVariant> *>(ptr);
}



extern "C" {static int convertTo_QMap_0100QByteArray_0100QVariant(PyObject *, void **, int *, PyObject *);}
static int convertTo_QMap_0100QByteArray_0100QVariant(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QMap< ::QByteArray, ::QVariant> **sipCppPtr = reinterpret_cast<QMap< ::QByteArray, ::QVariant> **>(sipCppPtrV);

#line 85 "sip/QtCore/qpycore_qmap.sip"
    if (!sipIsErr)
        return PyDict_Check(sipPy);

    QMap<QByteArray, QVariant> *qm = new QMap<QByteArray, QVariant>;

    Py_ssize_t pos = 0;
    PyObject *kobj, *vobj;
 
    while (PyDict_Next(sipPy, &pos, &kobj, &vobj))
    {
        int kstate;
        QByteArray *k = reinterpret_cast<QByteArray *>(
                sipForceConvertToType(kobj, sipType_QByteArray, sipTransferObj,
                        SIP_NOT_NONE, &kstate, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "a dict key has type '%s' but 'QByteArray' is expected",
                    sipPyTypeName(Py_TYPE(kobj)));

            delete qm;

            return 0;
        }

        int vstate;
        QVariant *v = reinterpret_cast<QVariant *>(
                sipForceConvertToType(vobj, sipType_QVariant, sipTransferObj,
                        SIP_NOT_NONE, &vstate, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "a dict value has type '%s' but 'QVariant' is expected",
                    sipPyTypeName(Py_TYPE(vobj)));

            sipReleaseType(k, sipType_QByteArray, kstate);
            delete qm;

            return 0;
        }

        qm->insert(*k, *v);

        sipReleaseType(v, sipType_QVariant, vstate);
        sipReleaseType(k, sipType_QByteArray, kstate);
    }
 
    *sipCppPtr = qm;
 
    return sipGetState(sipTransferObj);
#line 2684 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QMap_0100QByteArray_0100QVariant(void *, PyObject *);}
static PyObject *convertFrom_QMap_0100QByteArray_0100QVariant(void *sipCppV, PyObject *sipTransferObj)
{
   QMap< ::QByteArray, ::QVariant> *sipCpp = reinterpret_cast<QMap< ::QByteArray, ::QVariant> *>(sipCppV);

#line 31 "sip/QtCore/qpycore_qmap.sip"
    PyObject *d = PyDict_New();

    if (!d)
        return 0;

    QMap<QByteArray, QVariant>::const_iterator it = sipCpp->constBegin();
    QMap<QByteArray, QVariant>::const_iterator end = sipCpp->constEnd();

    while (it != end)
    {
        QByteArray *k = new QByteArray(it.key());
        PyObject *kobj = sipConvertFromNewType(k, sipType_QByteArray,
                sipTransferObj);

        if (!kobj)
        {
            delete k;
            Py_DECREF(d);

            return 0;
        }

        QVariant *v = new QVariant(it.value());
        PyObject *vobj = sipConvertFromNewType(v, sipType_QVariant,
                sipTransferObj);

        if (!vobj)
        {
            delete v;
            Py_DECREF(kobj);
            Py_DECREF(d);

            return 0;
        }

        int rc = PyDict_SetItem(d, kobj, vobj);

        Py_DECREF(vobj);
        Py_DECREF(kobj);

        if (rc < 0)
        {
            Py_DECREF(d);

            return 0;
        }

        ++it;
    }

    return d;
#line 2745 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QMap_0100QByteArray_0100QVariant = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_4006,     /* QMap<QByteArray,QVariant> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QMap_0100QByteArray_0100QVariant,
    array_QMap_0100QByteArray_0100QVariant,
    copy_QMap_0100QByteArray_0100QVariant,
    release_QMap_0100QByteArray_0100QVariant,
    convertTo_QMap_0100QByteArray_0100QVariant,
    convertFrom_QMap_0100QByteArray_0100QVariant
};

#line 28 "sip/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 2777 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslellipticcurve.sip"
#include <qsslellipticcurve.h>
#line 2781 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QVector_0100QSslEllipticCurve(void *, SIP_SSIZE_T, void *);}
static void assign_QVector_0100QSslEllipticCurve(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QVector< ::QSslEllipticCurve> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QVector< ::QSslEllipticCurve> *>(sipSrc);
}


extern "C" {static void *array_QVector_0100QSslEllipticCurve(SIP_SSIZE_T);}
static void *array_QVector_0100QSslEllipticCurve(SIP_SSIZE_T sipNrElem)
{
    return new QVector< ::QSslEllipticCurve>[sipNrElem];
}


extern "C" {static void *copy_QVector_0100QSslEllipticCurve(const void *, SIP_SSIZE_T);}
static void *copy_QVector_0100QSslEllipticCurve(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QVector< ::QSslEllipticCurve>(reinterpret_cast<const QVector< ::QSslEllipticCurve> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QVector_0100QSslEllipticCurve(void *, int);}
static void release_QVector_0100QSslEllipticCurve(void *ptr, int)
{
    delete reinterpret_cast<QVector< ::QSslEllipticCurve> *>(ptr);
}



extern "C" {static int convertTo_QVector_0100QSslEllipticCurve(PyObject *, void **, int *, PyObject *);}
static int convertTo_QVector_0100QSslEllipticCurve(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QVector< ::QSslEllipticCurve> **sipCppPtr = reinterpret_cast<QVector< ::QSslEllipticCurve> **>(sipCppPtrV);

#line 58 "sip/QtCore/qpycore_qvector.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QVector<QSslEllipticCurve> *qv = new QVector<QSslEllipticCurve>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete qv;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QSslEllipticCurve *t = reinterpret_cast<QSslEllipticCurve *>(
                sipForceConvertToType(itm, sipType_QSslEllipticCurve, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QSslEllipticCurve' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete qv;
            Py_DECREF(iter);

            return 0;
        }

        qv->append(*t);

        sipReleaseType(t, sipType_QSslEllipticCurve, state);
        Py_DECREF(itm);
    }

    Py_DECREF(iter);
 
    *sipCppPtr = qv;
 
    return sipGetState(sipTransferObj);
#line 2891 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QVector_0100QSslEllipticCurve(void *, PyObject *);}
static PyObject *convertFrom_QVector_0100QSslEllipticCurve(void *sipCppV, PyObject *sipTransferObj)
{
   QVector< ::QSslEllipticCurve> *sipCpp = reinterpret_cast<QVector< ::QSslEllipticCurve> *>(sipCppV);

#line 32 "sip/QtCore/qpycore_qvector.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QSslEllipticCurve *t = new QSslEllipticCurve(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QSslEllipticCurve,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 2924 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QVector_0100QSslEllipticCurve = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_3493,     /* QVector<QSslEllipticCurve> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QVector_0100QSslEllipticCurve,
    array_QVector_0100QSslEllipticCurve,
    copy_QVector_0100QSslEllipticCurve,
    release_QVector_0100QSslEllipticCurve,
    convertTo_QVector_0100QSslEllipticCurve,
    convertFrom_QVector_0100QSslEllipticCurve
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 2956 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcipher.sip"
#include <qsslcipher.h>
#line 2960 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QSslCipher(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QSslCipher(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QSslCipher> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QSslCipher> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QSslCipher(SIP_SSIZE_T);}
static void *array_QList_0100QSslCipher(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QSslCipher>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QSslCipher(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QSslCipher(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QSslCipher>(reinterpret_cast<const QList< ::QSslCipher> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QSslCipher(void *, int);}
static void release_QList_0100QSslCipher(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QSslCipher> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QSslCipher(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QSslCipher(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QSslCipher> **sipCppPtr = reinterpret_cast<QList< ::QSslCipher> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QSslCipher> *ql = new QList<QSslCipher>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QSslCipher *t = reinterpret_cast<QSslCipher *>(
                sipForceConvertToType(itm, sipType_QSslCipher, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QSslCipher' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QSslCipher, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 3070 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QSslCipher(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QSslCipher(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QSslCipher> *sipCpp = reinterpret_cast<QList< ::QSslCipher> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QSslCipher *t = new QSslCipher(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QSslCipher,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 3103 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QSslCipher = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_8805,     /* QList<QSslCipher> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QSslCipher,
    array_QList_0100QSslCipher,
    copy_QList_0100QSslCipher,
    release_QList_0100QSslCipher,
    convertTo_QList_0100QSslCipher,
    convertFrom_QList_0100QSslCipher
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3135 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcertificateextension.sip"
#include <qsslcertificateextension.h>
#line 3139 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QSslCertificateExtension(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QSslCertificateExtension(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QSslCertificateExtension> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QSslCertificateExtension> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QSslCertificateExtension(SIP_SSIZE_T);}
static void *array_QList_0100QSslCertificateExtension(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QSslCertificateExtension>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QSslCertificateExtension(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QSslCertificateExtension(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QSslCertificateExtension>(reinterpret_cast<const QList< ::QSslCertificateExtension> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QSslCertificateExtension(void *, int);}
static void release_QList_0100QSslCertificateExtension(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QSslCertificateExtension> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QSslCertificateExtension(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QSslCertificateExtension(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QSslCertificateExtension> **sipCppPtr = reinterpret_cast<QList< ::QSslCertificateExtension> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QSslCertificateExtension> *ql = new QList<QSslCertificateExtension>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QSslCertificateExtension *t = reinterpret_cast<QSslCertificateExtension *>(
                sipForceConvertToType(itm, sipType_QSslCertificateExtension, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QSslCertificateExtension' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QSslCertificateExtension, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 3249 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QSslCertificateExtension(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QSslCertificateExtension(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QSslCertificateExtension> *sipCpp = reinterpret_cast<QList< ::QSslCertificateExtension> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QSslCertificateExtension *t = new QSslCertificateExtension(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QSslCertificateExtension,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 3282 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QSslCertificateExtension = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_1393,     /* QList<QSslCertificateExtension> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QSslCertificateExtension,
    array_QList_0100QSslCertificateExtension,
    copy_QList_0100QSslCertificateExtension,
    release_QList_0100QSslCertificateExtension,
    convertTo_QList_0100QSslCertificateExtension,
    convertFrom_QList_0100QSslCertificateExtension
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3314 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcertificate.sip"
#include <qsslcertificate.h>
#line 3318 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QSslCertificate(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QSslCertificate(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QSslCertificate> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QSslCertificate> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QSslCertificate(SIP_SSIZE_T);}
static void *array_QList_0100QSslCertificate(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QSslCertificate>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QSslCertificate(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QSslCertificate(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QSslCertificate>(reinterpret_cast<const QList< ::QSslCertificate> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QSslCertificate(void *, int);}
static void release_QList_0100QSslCertificate(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QSslCertificate> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QSslCertificate(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QSslCertificate(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QSslCertificate> **sipCppPtr = reinterpret_cast<QList< ::QSslCertificate> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QSslCertificate> *ql = new QList<QSslCertificate>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QSslCertificate *t = reinterpret_cast<QSslCertificate *>(
                sipForceConvertToType(itm, sipType_QSslCertificate, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QSslCertificate' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QSslCertificate, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 3428 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QSslCertificate(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QSslCertificate(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QSslCertificate> *sipCpp = reinterpret_cast<QList< ::QSslCertificate> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QSslCertificate *t = new QSslCertificate(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QSslCertificate,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 3461 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QSslCertificate = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_5545,     /* QList<QSslCertificate> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QSslCertificate,
    array_QList_0100QSslCertificate,
    copy_QList_0100QSslCertificate,
    release_QList_0100QSslCertificate,
    convertTo_QList_0100QSslCertificate,
    convertFrom_QList_0100QSslCertificate
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3493 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkproxy.sip"
#include <qnetworkproxy.h>
#line 3497 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QNetworkProxy(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QNetworkProxy(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QNetworkProxy> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QNetworkProxy> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QNetworkProxy(SIP_SSIZE_T);}
static void *array_QList_0100QNetworkProxy(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QNetworkProxy>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QNetworkProxy(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QNetworkProxy(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QNetworkProxy>(reinterpret_cast<const QList< ::QNetworkProxy> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QNetworkProxy(void *, int);}
static void release_QList_0100QNetworkProxy(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QNetworkProxy> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QNetworkProxy(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QNetworkProxy(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QNetworkProxy> **sipCppPtr = reinterpret_cast<QList< ::QNetworkProxy> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QNetworkProxy> *ql = new QList<QNetworkProxy>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QNetworkProxy *t = reinterpret_cast<QNetworkProxy *>(
                sipForceConvertToType(itm, sipType_QNetworkProxy, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QNetworkProxy' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QNetworkProxy, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 3607 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QNetworkProxy(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QNetworkProxy(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QNetworkProxy> *sipCpp = reinterpret_cast<QList< ::QNetworkProxy> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QNetworkProxy *t = new QNetworkProxy(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QNetworkProxy,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 3640 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QNetworkProxy = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_6660,     /* QList<QNetworkProxy> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QNetworkProxy,
    array_QList_0100QNetworkProxy,
    copy_QList_0100QNetworkProxy,
    release_QList_0100QNetworkProxy,
    convertTo_QList_0100QNetworkProxy,
    convertFrom_QList_0100QNetworkProxy
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3672 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 86 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkinterface.sip"
#include <qnetworkinterface.h>
#line 3676 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QNetworkInterface(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QNetworkInterface(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QNetworkInterface> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QNetworkInterface> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QNetworkInterface(SIP_SSIZE_T);}
static void *array_QList_0100QNetworkInterface(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QNetworkInterface>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QNetworkInterface(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QNetworkInterface(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QNetworkInterface>(reinterpret_cast<const QList< ::QNetworkInterface> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QNetworkInterface(void *, int);}
static void release_QList_0100QNetworkInterface(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QNetworkInterface> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QNetworkInterface(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QNetworkInterface(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QNetworkInterface> **sipCppPtr = reinterpret_cast<QList< ::QNetworkInterface> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QNetworkInterface> *ql = new QList<QNetworkInterface>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QNetworkInterface *t = reinterpret_cast<QNetworkInterface *>(
                sipForceConvertToType(itm, sipType_QNetworkInterface, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QNetworkInterface' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QNetworkInterface, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 3786 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QNetworkInterface(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QNetworkInterface(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QNetworkInterface> *sipCpp = reinterpret_cast<QList< ::QNetworkInterface> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QNetworkInterface *t = new QNetworkInterface(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QNetworkInterface,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 3819 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QNetworkInterface = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_4448,     /* QList<QNetworkInterface> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QNetworkInterface,
    array_QList_0100QNetworkInterface,
    copy_QList_0100QNetworkInterface,
    release_QList_0100QNetworkInterface,
    convertTo_QList_0100QNetworkInterface,
    convertFrom_QList_0100QNetworkInterface
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3851 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkinterface.sip"
#include <qnetworkinterface.h>
#line 3855 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QNetworkAddressEntry(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QNetworkAddressEntry(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QNetworkAddressEntry> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QNetworkAddressEntry> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QNetworkAddressEntry(SIP_SSIZE_T);}
static void *array_QList_0100QNetworkAddressEntry(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QNetworkAddressEntry>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QNetworkAddressEntry(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QNetworkAddressEntry(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QNetworkAddressEntry>(reinterpret_cast<const QList< ::QNetworkAddressEntry> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QNetworkAddressEntry(void *, int);}
static void release_QList_0100QNetworkAddressEntry(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QNetworkAddressEntry> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QNetworkAddressEntry(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QNetworkAddressEntry(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QNetworkAddressEntry> **sipCppPtr = reinterpret_cast<QList< ::QNetworkAddressEntry> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QNetworkAddressEntry> *ql = new QList<QNetworkAddressEntry>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QNetworkAddressEntry *t = reinterpret_cast<QNetworkAddressEntry *>(
                sipForceConvertToType(itm, sipType_QNetworkAddressEntry, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QNetworkAddressEntry' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QNetworkAddressEntry, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 3965 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QNetworkAddressEntry(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QNetworkAddressEntry(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QNetworkAddressEntry> *sipCpp = reinterpret_cast<QList< ::QNetworkAddressEntry> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QNetworkAddressEntry *t = new QNetworkAddressEntry(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QNetworkAddressEntry,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 3998 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QNetworkAddressEntry = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_2989,     /* QList<QNetworkAddressEntry> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QNetworkAddressEntry,
    array_QList_0100QNetworkAddressEntry,
    copy_QList_0100QNetworkAddressEntry,
    release_QList_0100QNetworkAddressEntry,
    convertTo_QList_0100QNetworkAddressEntry,
    convertFrom_QList_0100QNetworkAddressEntry
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4030 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkcookie.sip"
#include <qnetworkcookie.h>
#line 4034 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QNetworkCookie(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QNetworkCookie(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QNetworkCookie> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QNetworkCookie> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QNetworkCookie(SIP_SSIZE_T);}
static void *array_QList_0100QNetworkCookie(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QNetworkCookie>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QNetworkCookie(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QNetworkCookie(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QNetworkCookie>(reinterpret_cast<const QList< ::QNetworkCookie> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QNetworkCookie(void *, int);}
static void release_QList_0100QNetworkCookie(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QNetworkCookie> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QNetworkCookie(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QNetworkCookie(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QNetworkCookie> **sipCppPtr = reinterpret_cast<QList< ::QNetworkCookie> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QNetworkCookie> *ql = new QList<QNetworkCookie>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QNetworkCookie *t = reinterpret_cast<QNetworkCookie *>(
                sipForceConvertToType(itm, sipType_QNetworkCookie, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QNetworkCookie' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QNetworkCookie, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 4144 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QNetworkCookie(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QNetworkCookie(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QNetworkCookie> *sipCpp = reinterpret_cast<QList< ::QNetworkCookie> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QNetworkCookie *t = new QNetworkCookie(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QNetworkCookie,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 4177 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QNetworkCookie = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_5890,     /* QList<QNetworkCookie> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QNetworkCookie,
    array_QList_0100QNetworkCookie,
    copy_QList_0100QNetworkCookie,
    release_QList_0100QNetworkCookie,
    convertTo_QList_0100QNetworkCookie,
    convertFrom_QList_0100QNetworkCookie
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4209 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkconfiguration.sip"
#include <qnetworkconfiguration.h>
#line 4213 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QNetworkConfiguration(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QNetworkConfiguration(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QNetworkConfiguration> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QNetworkConfiguration> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QNetworkConfiguration(SIP_SSIZE_T);}
static void *array_QList_0100QNetworkConfiguration(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QNetworkConfiguration>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QNetworkConfiguration(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QNetworkConfiguration(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QNetworkConfiguration>(reinterpret_cast<const QList< ::QNetworkConfiguration> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QNetworkConfiguration(void *, int);}
static void release_QList_0100QNetworkConfiguration(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QNetworkConfiguration> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QNetworkConfiguration(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QNetworkConfiguration(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QNetworkConfiguration> **sipCppPtr = reinterpret_cast<QList< ::QNetworkConfiguration> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QNetworkConfiguration> *ql = new QList<QNetworkConfiguration>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QNetworkConfiguration *t = reinterpret_cast<QNetworkConfiguration *>(
                sipForceConvertToType(itm, sipType_QNetworkConfiguration, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QNetworkConfiguration' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QNetworkConfiguration, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 4323 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QNetworkConfiguration(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QNetworkConfiguration(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QNetworkConfiguration> *sipCpp = reinterpret_cast<QList< ::QNetworkConfiguration> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QNetworkConfiguration *t = new QNetworkConfiguration(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QNetworkConfiguration,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 4356 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QNetworkConfiguration = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_2438,     /* QList<QNetworkConfiguration> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QNetworkConfiguration,
    array_QList_0100QNetworkConfiguration,
    copy_QList_0100QNetworkConfiguration,
    release_QList_0100QNetworkConfiguration,
    convertTo_QList_0100QNetworkConfiguration,
    convertFrom_QList_0100QNetworkConfiguration
};

#line 28 "sip/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 4388 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhstspolicy.sip"
#include <qhstspolicy.h>
#line 4392 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QVector_0100QHstsPolicy(void *, SIP_SSIZE_T, void *);}
static void assign_QVector_0100QHstsPolicy(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QVector< ::QHstsPolicy> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QVector< ::QHstsPolicy> *>(sipSrc);
}


extern "C" {static void *array_QVector_0100QHstsPolicy(SIP_SSIZE_T);}
static void *array_QVector_0100QHstsPolicy(SIP_SSIZE_T sipNrElem)
{
    return new QVector< ::QHstsPolicy>[sipNrElem];
}


extern "C" {static void *copy_QVector_0100QHstsPolicy(const void *, SIP_SSIZE_T);}
static void *copy_QVector_0100QHstsPolicy(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QVector< ::QHstsPolicy>(reinterpret_cast<const QVector< ::QHstsPolicy> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QVector_0100QHstsPolicy(void *, int);}
static void release_QVector_0100QHstsPolicy(void *ptr, int)
{
    delete reinterpret_cast<QVector< ::QHstsPolicy> *>(ptr);
}



extern "C" {static int convertTo_QVector_0100QHstsPolicy(PyObject *, void **, int *, PyObject *);}
static int convertTo_QVector_0100QHstsPolicy(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QVector< ::QHstsPolicy> **sipCppPtr = reinterpret_cast<QVector< ::QHstsPolicy> **>(sipCppPtrV);

#line 58 "sip/QtCore/qpycore_qvector.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QVector<QHstsPolicy> *qv = new QVector<QHstsPolicy>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete qv;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QHstsPolicy *t = reinterpret_cast<QHstsPolicy *>(
                sipForceConvertToType(itm, sipType_QHstsPolicy, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QHstsPolicy' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete qv;
            Py_DECREF(iter);

            return 0;
        }

        qv->append(*t);

        sipReleaseType(t, sipType_QHstsPolicy, state);
        Py_DECREF(itm);
    }

    Py_DECREF(iter);
 
    *sipCppPtr = qv;
 
    return sipGetState(sipTransferObj);
#line 4502 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QVector_0100QHstsPolicy(void *, PyObject *);}
static PyObject *convertFrom_QVector_0100QHstsPolicy(void *sipCppV, PyObject *sipTransferObj)
{
   QVector< ::QHstsPolicy> *sipCpp = reinterpret_cast<QVector< ::QHstsPolicy> *>(sipCppV);

#line 32 "sip/QtCore/qpycore_qvector.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QHstsPolicy *t = new QHstsPolicy(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QHstsPolicy,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 4535 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QVector_0100QHstsPolicy = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_6681,     /* QVector<QHstsPolicy> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QVector_0100QHstsPolicy,
    array_QVector_0100QHstsPolicy,
    copy_QVector_0100QHstsPolicy,
    release_QVector_0100QHstsPolicy,
    convertTo_QVector_0100QHstsPolicy,
    convertFrom_QVector_0100QHstsPolicy
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4567 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslerror.sip"
#include <qsslerror.h>
#line 4571 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QSslError(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QSslError(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QSslError> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QSslError> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QSslError(SIP_SSIZE_T);}
static void *array_QList_0100QSslError(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QSslError>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QSslError(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QSslError(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QSslError>(reinterpret_cast<const QList< ::QSslError> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QSslError(void *, int);}
static void release_QList_0100QSslError(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QSslError> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QSslError(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QSslError(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QSslError> **sipCppPtr = reinterpret_cast<QList< ::QSslError> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QSslError> *ql = new QList<QSslError>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QSslError *t = reinterpret_cast<QSslError *>(
                sipForceConvertToType(itm, sipType_QSslError, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QSslError' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QSslError, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 4681 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QSslError(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QSslError(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QSslError> *sipCpp = reinterpret_cast<QList< ::QSslError> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QSslError *t = new QSslError(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QSslError,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 4714 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QSslError = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_9759,     /* QList<QSslError> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QSslError,
    array_QList_0100QSslError,
    copy_QList_0100QSslError,
    release_QList_0100QSslError,
    convertTo_QList_0100QSslError,
    convertFrom_QList_0100QSslError
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4746 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhostaddress.sip"
#include <qhostaddress.h>
#line 4750 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QHostAddress(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QHostAddress(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QHostAddress> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QHostAddress> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QHostAddress(SIP_SSIZE_T);}
static void *array_QList_0100QHostAddress(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QHostAddress>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QHostAddress(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QHostAddress(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QHostAddress>(reinterpret_cast<const QList< ::QHostAddress> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QHostAddress(void *, int);}
static void release_QList_0100QHostAddress(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QHostAddress> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QHostAddress(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QHostAddress(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QHostAddress> **sipCppPtr = reinterpret_cast<QList< ::QHostAddress> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QHostAddress> *ql = new QList<QHostAddress>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QHostAddress *t = reinterpret_cast<QHostAddress *>(
                sipForceConvertToType(itm, sipType_QHostAddress, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QHostAddress' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QHostAddress, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 4860 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QHostAddress(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QHostAddress(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QHostAddress> *sipCpp = reinterpret_cast<QList< ::QHostAddress> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QHostAddress *t = new QHostAddress(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QHostAddress,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 4893 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QHostAddress = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_7479,     /* QList<QHostAddress> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QHostAddress,
    array_QList_0100QHostAddress,
    copy_QList_0100QHostAddress,
    release_QList_0100QHostAddress,
    convertTo_QList_0100QHostAddress,
    convertFrom_QList_0100QHostAddress
};

#line 143 "sip/QtCore/qpycore_qpair.sip"
#include <qpair.h>
#line 4925 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhostaddress.sip"
#include <qhostaddress.h>
#line 4929 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QPair_0100QHostAddress_1800(void *, SIP_SSIZE_T, void *);}
static void assign_QPair_0100QHostAddress_1800(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QPair< ::QHostAddress,int> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QPair< ::QHostAddress,int> *>(sipSrc);
}


extern "C" {static void *array_QPair_0100QHostAddress_1800(SIP_SSIZE_T);}
static void *array_QPair_0100QHostAddress_1800(SIP_SSIZE_T sipNrElem)
{
    return new QPair< ::QHostAddress,int>[sipNrElem];
}


extern "C" {static void *copy_QPair_0100QHostAddress_1800(const void *, SIP_SSIZE_T);}
static void *copy_QPair_0100QHostAddress_1800(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QPair< ::QHostAddress,int>(reinterpret_cast<const QPair< ::QHostAddress,int> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QPair_0100QHostAddress_1800(void *, int);}
static void release_QPair_0100QHostAddress_1800(void *ptr, int)
{
    delete reinterpret_cast<QPair< ::QHostAddress,int> *>(ptr);
}



extern "C" {static int convertTo_QPair_0100QHostAddress_1800(PyObject *, void **, int *, PyObject *);}
static int convertTo_QPair_0100QHostAddress_1800(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QPair< ::QHostAddress,int> **sipCppPtr = reinterpret_cast<QPair< ::QHostAddress,int> **>(sipCppPtrV);

#line 162 "sip/QtCore/qpycore_qpair.sip"
    if (!sipIsErr)
        return (PySequence_Check(sipPy)
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));

    Py_ssize_t len = PySequence_Size(sipPy);

    if (len != 2)
    {
        // A negative length should only be an internal error so let the
        // original exception stand.
        if (len >= 0)
            PyErr_Format(PyExc_TypeError,
                    "sequence has %zd elements but 2 elements are expected",
                    len);

        *sipIsErr = 1;

        return 0;
    }

    PyObject *firstobj = PySequence_GetItem(sipPy, 0);

    if (!firstobj)
    {
        *sipIsErr = 1;

        return 0;
    }

    int firststate;
    QHostAddress *first = reinterpret_cast<QHostAddress *>(
            sipForceConvertToType(firstobj, sipType_QHostAddress, sipTransferObj,
                    SIP_NOT_NONE, &firststate, sipIsErr));
 
    if (*sipIsErr)
    {
        PyErr_Format(PyExc_TypeError,
                "the first element has type '%s' but 'QHostAddress' is expected",
                sipPyTypeName(Py_TYPE(firstobj)));

        return 0;
    }

    PyObject *secondobj = PySequence_GetItem(sipPy, 1);

    if (!secondobj)
    {
        sipReleaseType(first, sipType_QHostAddress, firststate);
        Py_DECREF(firstobj);
        *sipIsErr = 1;

        return 0;
    }

    int second = sipLong_AsInt(secondobj);

    if (PyErr_Occurred())
    {
        if (PyErr_ExceptionMatches(PyExc_TypeError))
            PyErr_Format(PyExc_TypeError,
                    "the second element has type '%s' but 'int' is expected",
                    sipPyTypeName(Py_TYPE(secondobj)));

        Py_DECREF(secondobj);
        sipReleaseType(first, sipType_QHostAddress, firststate);
        Py_DECREF(firstobj);
        *sipIsErr = 1;

        return 0;
    }

    *sipCppPtr = new QPair<QHostAddress, int>(*first, second);

    Py_DECREF(secondobj);
    sipReleaseType(first, sipType_QHostAddress, firststate);
    Py_DECREF(firstobj);
 
    return sipGetState(sipTransferObj);
#line 5049 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QPair_0100QHostAddress_1800(void *, PyObject *);}
static PyObject *convertFrom_QPair_0100QHostAddress_1800(void *sipCppV, PyObject *sipTransferObj)
{
   QPair< ::QHostAddress,int> *sipCpp = reinterpret_cast<QPair< ::QHostAddress,int> *>(sipCppV);

#line 147 "sip/QtCore/qpycore_qpair.sip"
    QHostAddress *first = new QHostAddress(sipCpp->first);
    PyObject *t = sipBuildResult(NULL, "(Ni)", first, sipType_QHostAddress,
            sipTransferObj, sipCpp->second);

    if (!t)
    {
        delete first;

        return 0;
    }

    return t;
#line 5071 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QPair_0100QHostAddress_1800 = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_4873,     /* QPair<QHostAddress,int> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QPair_0100QHostAddress_1800,
    array_QPair_0100QHostAddress_1800,
    copy_QPair_0100QHostAddress_1800,
    release_QPair_0100QHostAddress_1800,
    convertTo_QPair_0100QHostAddress_1800,
    convertFrom_QPair_0100QHostAddress_1800
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5103 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 94 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qdnslookup.sip"
#include <qdnslookup.h>
#line 5107 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QDnsTextRecord(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QDnsTextRecord(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QDnsTextRecord> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QDnsTextRecord> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QDnsTextRecord(SIP_SSIZE_T);}
static void *array_QList_0100QDnsTextRecord(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QDnsTextRecord>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QDnsTextRecord(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QDnsTextRecord(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QDnsTextRecord>(reinterpret_cast<const QList< ::QDnsTextRecord> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QDnsTextRecord(void *, int);}
static void release_QList_0100QDnsTextRecord(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QDnsTextRecord> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QDnsTextRecord(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QDnsTextRecord(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QDnsTextRecord> **sipCppPtr = reinterpret_cast<QList< ::QDnsTextRecord> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QDnsTextRecord> *ql = new QList<QDnsTextRecord>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QDnsTextRecord *t = reinterpret_cast<QDnsTextRecord *>(
                sipForceConvertToType(itm, sipType_QDnsTextRecord, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QDnsTextRecord' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QDnsTextRecord, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 5217 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QDnsTextRecord(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QDnsTextRecord(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QDnsTextRecord> *sipCpp = reinterpret_cast<QList< ::QDnsTextRecord> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QDnsTextRecord *t = new QDnsTextRecord(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QDnsTextRecord,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 5250 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QDnsTextRecord = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_5912,     /* QList<QDnsTextRecord> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QDnsTextRecord,
    array_QList_0100QDnsTextRecord,
    copy_QList_0100QDnsTextRecord,
    release_QList_0100QDnsTextRecord,
    convertTo_QList_0100QDnsTextRecord,
    convertFrom_QList_0100QDnsTextRecord
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5282 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 75 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qdnslookup.sip"
#include <qdnslookup.h>
#line 5286 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QDnsServiceRecord(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QDnsServiceRecord(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QDnsServiceRecord> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QDnsServiceRecord> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QDnsServiceRecord(SIP_SSIZE_T);}
static void *array_QList_0100QDnsServiceRecord(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QDnsServiceRecord>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QDnsServiceRecord(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QDnsServiceRecord(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QDnsServiceRecord>(reinterpret_cast<const QList< ::QDnsServiceRecord> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QDnsServiceRecord(void *, int);}
static void release_QList_0100QDnsServiceRecord(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QDnsServiceRecord> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QDnsServiceRecord(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QDnsServiceRecord(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QDnsServiceRecord> **sipCppPtr = reinterpret_cast<QList< ::QDnsServiceRecord> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QDnsServiceRecord> *ql = new QList<QDnsServiceRecord>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QDnsServiceRecord *t = reinterpret_cast<QDnsServiceRecord *>(
                sipForceConvertToType(itm, sipType_QDnsServiceRecord, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QDnsServiceRecord' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QDnsServiceRecord, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 5396 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QDnsServiceRecord(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QDnsServiceRecord(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QDnsServiceRecord> *sipCpp = reinterpret_cast<QList< ::QDnsServiceRecord> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QDnsServiceRecord *t = new QDnsServiceRecord(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QDnsServiceRecord,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 5429 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QDnsServiceRecord = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_4473,     /* QList<QDnsServiceRecord> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QDnsServiceRecord,
    array_QList_0100QDnsServiceRecord,
    copy_QList_0100QDnsServiceRecord,
    release_QList_0100QDnsServiceRecord,
    convertTo_QList_0100QDnsServiceRecord,
    convertFrom_QList_0100QDnsServiceRecord
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5461 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 58 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qdnslookup.sip"
#include <qdnslookup.h>
#line 5465 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QDnsMailExchangeRecord(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QDnsMailExchangeRecord(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QDnsMailExchangeRecord> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QDnsMailExchangeRecord> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QDnsMailExchangeRecord(SIP_SSIZE_T);}
static void *array_QList_0100QDnsMailExchangeRecord(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QDnsMailExchangeRecord>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QDnsMailExchangeRecord(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QDnsMailExchangeRecord(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QDnsMailExchangeRecord>(reinterpret_cast<const QList< ::QDnsMailExchangeRecord> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QDnsMailExchangeRecord(void *, int);}
static void release_QList_0100QDnsMailExchangeRecord(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QDnsMailExchangeRecord> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QDnsMailExchangeRecord(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QDnsMailExchangeRecord(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QDnsMailExchangeRecord> **sipCppPtr = reinterpret_cast<QList< ::QDnsMailExchangeRecord> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QDnsMailExchangeRecord> *ql = new QList<QDnsMailExchangeRecord>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QDnsMailExchangeRecord *t = reinterpret_cast<QDnsMailExchangeRecord *>(
                sipForceConvertToType(itm, sipType_QDnsMailExchangeRecord, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QDnsMailExchangeRecord' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QDnsMailExchangeRecord, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 5575 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QDnsMailExchangeRecord(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QDnsMailExchangeRecord(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QDnsMailExchangeRecord> *sipCpp = reinterpret_cast<QList< ::QDnsMailExchangeRecord> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QDnsMailExchangeRecord *t = new QDnsMailExchangeRecord(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QDnsMailExchangeRecord,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 5608 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QDnsMailExchangeRecord = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_2048,     /* QList<QDnsMailExchangeRecord> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QDnsMailExchangeRecord,
    array_QList_0100QDnsMailExchangeRecord,
    copy_QList_0100QDnsMailExchangeRecord,
    release_QList_0100QDnsMailExchangeRecord,
    convertTo_QList_0100QDnsMailExchangeRecord,
    convertFrom_QList_0100QDnsMailExchangeRecord
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5640 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 42 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qdnslookup.sip"
#include <qdnslookup.h>
#line 5644 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QDnsHostAddressRecord(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QDnsHostAddressRecord(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QDnsHostAddressRecord> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QDnsHostAddressRecord> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QDnsHostAddressRecord(SIP_SSIZE_T);}
static void *array_QList_0100QDnsHostAddressRecord(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QDnsHostAddressRecord>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QDnsHostAddressRecord(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QDnsHostAddressRecord(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QDnsHostAddressRecord>(reinterpret_cast<const QList< ::QDnsHostAddressRecord> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QDnsHostAddressRecord(void *, int);}
static void release_QList_0100QDnsHostAddressRecord(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QDnsHostAddressRecord> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QDnsHostAddressRecord(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QDnsHostAddressRecord(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QDnsHostAddressRecord> **sipCppPtr = reinterpret_cast<QList< ::QDnsHostAddressRecord> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QDnsHostAddressRecord> *ql = new QList<QDnsHostAddressRecord>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QDnsHostAddressRecord *t = reinterpret_cast<QDnsHostAddressRecord *>(
                sipForceConvertToType(itm, sipType_QDnsHostAddressRecord, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QDnsHostAddressRecord' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QDnsHostAddressRecord, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 5754 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QDnsHostAddressRecord(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QDnsHostAddressRecord(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QDnsHostAddressRecord> *sipCpp = reinterpret_cast<QList< ::QDnsHostAddressRecord> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QDnsHostAddressRecord *t = new QDnsHostAddressRecord(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QDnsHostAddressRecord,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 5787 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QDnsHostAddressRecord = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_2467,     /* QList<QDnsHostAddressRecord> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QDnsHostAddressRecord,
    array_QList_0100QDnsHostAddressRecord,
    copy_QList_0100QDnsHostAddressRecord,
    release_QList_0100QDnsHostAddressRecord,
    convertTo_QList_0100QDnsHostAddressRecord,
    convertFrom_QList_0100QDnsHostAddressRecord
};

#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5819 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qdnslookup.sip"
#include <qdnslookup.h>
#line 5823 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0100QDnsDomainNameRecord(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0100QDnsDomainNameRecord(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList< ::QDnsDomainNameRecord> *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList< ::QDnsDomainNameRecord> *>(sipSrc);
}


extern "C" {static void *array_QList_0100QDnsDomainNameRecord(SIP_SSIZE_T);}
static void *array_QList_0100QDnsDomainNameRecord(SIP_SSIZE_T sipNrElem)
{
    return new QList< ::QDnsDomainNameRecord>[sipNrElem];
}


extern "C" {static void *copy_QList_0100QDnsDomainNameRecord(const void *, SIP_SSIZE_T);}
static void *copy_QList_0100QDnsDomainNameRecord(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList< ::QDnsDomainNameRecord>(reinterpret_cast<const QList< ::QDnsDomainNameRecord> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0100QDnsDomainNameRecord(void *, int);}
static void release_QList_0100QDnsDomainNameRecord(void *ptr, int)
{
    delete reinterpret_cast<QList< ::QDnsDomainNameRecord> *>(ptr);
}



extern "C" {static int convertTo_QList_0100QDnsDomainNameRecord(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0100QDnsDomainNameRecord(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList< ::QDnsDomainNameRecord> **sipCppPtr = reinterpret_cast<QList< ::QDnsDomainNameRecord> **>(sipCppPtrV);

#line 68 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QDnsDomainNameRecord> *ql = new QList<QDnsDomainNameRecord>;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        int state;
        QDnsDomainNameRecord *t = reinterpret_cast<QDnsDomainNameRecord *>(
                sipForceConvertToType(itm, sipType_QDnsDomainNameRecord, sipTransferObj,
                        SIP_NOT_NONE, &state, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index %zd has type '%s' but 'QDnsDomainNameRecord' is expected", i,
                    sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(*t);

        sipReleaseType(t, sipType_QDnsDomainNameRecord, state);
        Py_DECREF(itm);
    }
 
    Py_DECREF(iter);

    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 5933 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0100QDnsDomainNameRecord(void *, PyObject *);}
static PyObject *convertFrom_QList_0100QDnsDomainNameRecord(void *sipCppV, PyObject *sipTransferObj)
{
   QList< ::QDnsDomainNameRecord> *sipCpp = reinterpret_cast<QList< ::QDnsDomainNameRecord> *>(sipCppV);

#line 42 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QDnsDomainNameRecord *t = new QDnsDomainNameRecord(sipCpp->at(i));
        PyObject *tobj = sipConvertFromNewType(t, sipType_QDnsDomainNameRecord,
                sipTransferObj);

        if (!tobj)
        {
            delete t;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
#line 5966 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0100QDnsDomainNameRecord = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_3017,     /* QList<QDnsDomainNameRecord> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0100QDnsDomainNameRecord,
    array_QList_0100QDnsDomainNameRecord,
    copy_QList_0100QDnsDomainNameRecord,
    release_QList_0100QDnsDomainNameRecord,
    convertTo_QList_0100QDnsDomainNameRecord,
    convertFrom_QList_0100QDnsDomainNameRecord
};

#line 263 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#include <qpair.h>
#line 5999 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 6003 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QList_0600QPair_0100QByteArray_0100QByteArray(void *, SIP_SSIZE_T, void *);}
static void assign_QList_0600QPair_0100QByteArray_0100QByteArray(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<QList<QPair<QByteArray,QByteArray> > *>(sipDst)[sipDstIdx] = *reinterpret_cast<QList<QPair<QByteArray,QByteArray> > *>(sipSrc);
}


extern "C" {static void *array_QList_0600QPair_0100QByteArray_0100QByteArray(SIP_SSIZE_T);}
static void *array_QList_0600QPair_0100QByteArray_0100QByteArray(SIP_SSIZE_T sipNrElem)
{
    return new QList<QPair<QByteArray,QByteArray> >[sipNrElem];
}


extern "C" {static void *copy_QList_0600QPair_0100QByteArray_0100QByteArray(const void *, SIP_SSIZE_T);}
static void *copy_QList_0600QPair_0100QByteArray_0100QByteArray(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new QList<QPair<QByteArray,QByteArray> >(reinterpret_cast<const QList<QPair<QByteArray,QByteArray> > *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QList_0600QPair_0100QByteArray_0100QByteArray(void *, int);}
static void release_QList_0600QPair_0100QByteArray_0100QByteArray(void *ptr, int)
{
    delete reinterpret_cast<QList<QPair<QByteArray,QByteArray> > *>(ptr);
}



extern "C" {static int convertTo_QList_0600QPair_0100QByteArray_0100QByteArray(PyObject *, void **, int *, PyObject *);}
static int convertTo_QList_0600QPair_0100QByteArray_0100QByteArray(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    QList<QPair<QByteArray,QByteArray> > **sipCppPtr = reinterpret_cast<QList<QPair<QByteArray,QByteArray> > **>(sipCppPtrV);

#line 297 "sip/QtCore/qpycore_qlist.sip"
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        PyErr_Clear();
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QList<QPair<QByteArray, QByteArray> > *ql = new QList<QPair<QByteArray, QByteArray> >;
 
    for (Py_ssize_t i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *seq = PyIter_Next(iter);

        if (!seq)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        Py_ssize_t sub_len;

        if (PySequence_Check(seq)
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(seq)
#endif
                && !PyUnicode_Check(seq))
            sub_len = PySequence_Size(seq);
        else
            sub_len = -1;

        if (sub_len != 2)
        {
            if (sub_len < 0)
                PyErr_Format(PyExc_TypeError,
                        "index %zd has type '%s' but a 2 element non-string sequence is expected",
                        i, sipPyTypeName(Py_TYPE(seq)));
            else
                PyErr_Format(PyExc_TypeError,
                        "index %zd is a sequence of %zd sub-elements but 2 sub-elements are expected",
                        i, sub_len);

            Py_DECREF(seq);
            delete ql;
            Py_DECREF(iter);
            *sipIsErr = 1;

            return 0;
        }

        PyObject *itm1 = PySequence_GetItem(seq, 0);

        if (!itm1)
        {
            Py_DECREF(seq);
            delete ql;
            Py_DECREF(iter);
            *sipIsErr = 1;

            return 0;
        }

        int state1;
        QByteArray *s1 = reinterpret_cast<QByteArray *>(
                sipForceConvertToType(itm1, sipType_QByteArray, sipTransferObj,
                        SIP_NOT_NONE, &state1, sipIsErr));

        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "the first sub-element of index %zd has type '%s' but 'QByteArray' is expected",
                    i, sipPyTypeName(Py_TYPE(itm1)));

            Py_DECREF(itm1);
            Py_DECREF(seq);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        PyObject *itm2 = PySequence_GetItem(seq, 1);

        if (!itm2)
        {
            sipReleaseType(s1, sipType_QByteArray, state1);
            Py_DECREF(itm1);
            Py_DECREF(seq);
            delete ql;
            Py_DECREF(iter);
            *sipIsErr = 1;

            return 0;
        }

        int state2;
        QByteArray *s2 = reinterpret_cast<QByteArray *>(
                sipForceConvertToType(itm2, sipType_QByteArray, sipTransferObj,
                        SIP_NOT_NONE, &state2, sipIsErr));
 
        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "the second sub-element of index %zd has type '%s' but 'QByteArray' is expected",
                    i, sipPyTypeName(Py_TYPE(itm2)));

            Py_DECREF(itm2);
            sipReleaseType(s1, sipType_QByteArray, state1);
            Py_DECREF(itm1);
            Py_DECREF(seq);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(QPair<QByteArray, QByteArray>(*s1, *s2));

        sipReleaseType(s2, sipType_QByteArray, state2);
        Py_DECREF(itm2);
        sipReleaseType(s1, sipType_QByteArray, state1);
        Py_DECREF(itm1);
        Py_DECREF(seq);
    }

    Py_DECREF(iter);
 
    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
#line 6194 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QList_0600QPair_0100QByteArray_0100QByteArray(void *, PyObject *);}
static PyObject *convertFrom_QList_0600QPair_0100QByteArray_0100QByteArray(void *sipCppV, PyObject *sipTransferObj)
{
   QList<QPair<QByteArray,QByteArray> > *sipCpp = reinterpret_cast<QList<QPair<QByteArray,QByteArray> > *>(sipCppV);

#line 268 "sip/QtCore/qpycore_qlist.sip"
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        const QPair<QByteArray, QByteArray> &p = sipCpp->at(i);
        QByteArray *s1 = new QByteArray(p.first);
        QByteArray *s2 = new QByteArray(p.second);
        PyObject *pobj = sipBuildResult(NULL, "(NN)", s1, sipType_QByteArray,
                sipTransferObj, s2, sipType_QByteArray, sipTransferObj);

        if (!pobj)
        {
            delete s1;
            delete s2;
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, pobj);
    }

    return l;
#line 6230 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QList_0600QPair_0100QByteArray_0100QByteArray = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_466,     /* QList<QPair<QByteArray,QByteArray> > */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QList_0600QPair_0100QByteArray_0100QByteArray,
    array_QList_0600QPair_0100QByteArray_0100QByteArray,
    copy_QList_0600QPair_0100QByteArray_0100QByteArray,
    release_QList_0600QPair_0100QByteArray_0100QByteArray,
    convertTo_QList_0600QPair_0100QByteArray_0100QByteArray,
    convertFrom_QList_0600QPair_0100QByteArray_0100QByteArray
};

#line 27 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qpynetwork_qhash.sip"
#include <qhash.h>
#include <qnetworkrequest.h>
#include <qvariant.h>
#line 6264 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkrequest.sip"
#include <qnetworkrequest.h>
#line 6268 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 6271 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QHash_0100QNetworkRequest_Attribute_0100QVariant(void *, SIP_SSIZE_T, void *);}
static void assign_QHash_0100QNetworkRequest_Attribute_0100QVariant(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QHash< ::QNetworkRequest::Attribute, ::QVariant> *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QHash< ::QNetworkRequest::Attribute, ::QVariant> *>(sipSrc);
}


extern "C" {static void *array_QHash_0100QNetworkRequest_Attribute_0100QVariant(SIP_SSIZE_T);}
static void *array_QHash_0100QNetworkRequest_Attribute_0100QVariant(SIP_SSIZE_T sipNrElem)
{
    return new  ::QHash< ::QNetworkRequest::Attribute, ::QVariant>[sipNrElem];
}


extern "C" {static void *copy_QHash_0100QNetworkRequest_Attribute_0100QVariant(const void *, SIP_SSIZE_T);}
static void *copy_QHash_0100QNetworkRequest_Attribute_0100QVariant(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QHash< ::QNetworkRequest::Attribute, ::QVariant>(reinterpret_cast<const  ::QHash< ::QNetworkRequest::Attribute, ::QVariant> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QHash_0100QNetworkRequest_Attribute_0100QVariant(void *, int);}
static void release_QHash_0100QNetworkRequest_Attribute_0100QVariant(void *ptr, int)
{
    delete reinterpret_cast< ::QHash< ::QNetworkRequest::Attribute, ::QVariant> *>(ptr);
}



extern "C" {static int convertTo_QHash_0100QNetworkRequest_Attribute_0100QVariant(PyObject *, void **, int *, PyObject *);}
static int convertTo_QHash_0100QNetworkRequest_Attribute_0100QVariant(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
     ::QHash< ::QNetworkRequest::Attribute, ::QVariant> **sipCppPtr = reinterpret_cast< ::QHash< ::QNetworkRequest::Attribute, ::QVariant> **>(sipCppPtrV);

#line 83 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qpynetwork_qhash.sip"
    if (!sipIsErr)
        return PyDict_Check(sipPy);

    QHash<QNetworkRequest::Attribute, QVariant> *qh = new QHash<QNetworkRequest::Attribute, QVariant>;

    Py_ssize_t pos = 0;
    PyObject *kobj, *vobj;
 
    while (PyDict_Next(sipPy, &pos, &kobj, &vobj))
    {
        int k = sipConvertToEnum(kobj, sipType_QNetworkRequest_Attribute);

        if (PyErr_Occurred())
        {
            PyErr_Format(PyExc_TypeError,
                    "a key has type '%s' but 'QNetworkRequest.Attribute' is expected",
                    sipPyTypeName(Py_TYPE(kobj)));

            delete qh;
            *sipIsErr = 1;

            return 0;
        }

        int vstate;
        QVariant *v = reinterpret_cast<QVariant *>(
                sipForceConvertToType(vobj, sipType_QVariant, sipTransferObj,
                        SIP_NOT_NONE, &vstate, sipIsErr));

        if (*sipIsErr)
        {
            // Any error must be internal, so leave the exception as it is.

            delete qh;

            return 0;
        }

        qh->insert(static_cast<QNetworkRequest::Attribute>(k), *v);

        sipReleaseType(v, sipType_QVariant, vstate);
    }
 
    *sipCppPtr = qh;
 
    return sipGetState(sipTransferObj);
#line 6356 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QHash_0100QNetworkRequest_Attribute_0100QVariant(void *, PyObject *);}
static PyObject *convertFrom_QHash_0100QNetworkRequest_Attribute_0100QVariant(void *sipCppV, PyObject *sipTransferObj)
{
    ::QHash< ::QNetworkRequest::Attribute, ::QVariant> *sipCpp = reinterpret_cast< ::QHash< ::QNetworkRequest::Attribute, ::QVariant> *>(sipCppV);

#line 33 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qpynetwork_qhash.sip"
    PyObject *d = PyDict_New();

    if (!d)
        return 0;

    QHash<QNetworkRequest::Attribute, QVariant>::const_iterator it = sipCpp->constBegin();
    QHash<QNetworkRequest::Attribute, QVariant>::const_iterator end = sipCpp->constEnd();

    while (it != end)
    {
        PyObject *kobj = sipConvertFromEnum(it.key(),
                sipType_QNetworkRequest_Attribute);

        if (!kobj)
        {
            Py_DECREF(d);

            return 0;
        }

        QVariant *v = new QVariant(it.value());
        PyObject *vobj = sipConvertFromNewType(v, sipType_QVariant,
                sipTransferObj);

        if (!vobj)
        {
            delete v;
            Py_DECREF(kobj);
            Py_DECREF(d);

            return 0;
        }

        int rc = PyDict_SetItem(d, kobj, vobj);

        Py_DECREF(vobj);
        Py_DECREF(kobj);

        if (rc < 0)
        {
            Py_DECREF(d);

            return 0;
        }
    }

    return d;
#line 6413 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QHash_0100QNetworkRequest_Attribute_0100QVariant = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_143,     /* QHash<QNetworkRequest::Attribute,QVariant> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QHash_0100QNetworkRequest_Attribute_0100QVariant,
    array_QHash_0100QNetworkRequest_Attribute_0100QVariant,
    copy_QHash_0100QNetworkRequest_Attribute_0100QVariant,
    release_QHash_0100QNetworkRequest_Attribute_0100QVariant,
    convertTo_QHash_0100QNetworkRequest_Attribute_0100QVariant,
    convertFrom_QHash_0100QNetworkRequest_Attribute_0100QVariant
};

#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qpynetwork_qmap.sip"
#include <qmap.h>
#include <qssl.h>
#line 6446 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 6450 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 6453 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static void assign_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(void *, SIP_SSIZE_T, void *);}
static void assign_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QMultiMap< ::QSsl::AlternativeNameEntryType, ::QString> *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QMultiMap< ::QSsl::AlternativeNameEntryType, ::QString> *>(sipSrc);
}


extern "C" {static void *array_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(SIP_SSIZE_T);}
static void *array_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(SIP_SSIZE_T sipNrElem)
{
    return new  ::QMultiMap< ::QSsl::AlternativeNameEntryType, ::QString>[sipNrElem];
}


extern "C" {static void *copy_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(const void *, SIP_SSIZE_T);}
static void *copy_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QMultiMap< ::QSsl::AlternativeNameEntryType, ::QString>(reinterpret_cast<const  ::QMultiMap< ::QSsl::AlternativeNameEntryType, ::QString> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(void *, int);}
static void release_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(void *ptr, int)
{
    delete reinterpret_cast< ::QMultiMap< ::QSsl::AlternativeNameEntryType, ::QString> *>(ptr);
}



extern "C" {static int convertTo_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(PyObject *, void **, int *, PyObject *);}
static int convertTo_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(PyObject *sipPy,void **,int *sipIsErr,PyObject *)
{
#line 150 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qpynetwork_qmap.sip"
    if (!sipIsErr)
        return PyDict_Check(sipPy);

    PyErr_SetString(PyExc_NotImplementedError,
            "converting to QMultiMap<QSsl::AlternativeNameEntryType, QString> is unsupported");

    return 0;
#line 6497 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


extern "C" {static PyObject *convertFrom_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(void *, PyObject *);}
static PyObject *convertFrom_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString(void *sipCppV, PyObject *sipTransferObj)
{
    ::QMultiMap< ::QSsl::AlternativeNameEntryType, ::QString> *sipCpp = reinterpret_cast< ::QMultiMap< ::QSsl::AlternativeNameEntryType, ::QString> *>(sipCppV);

#line 34 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qpynetwork_qmap.sip"
    // Get the enum objects that are the dictionary keys.
    static PyObject *email_entry = 0;
    static PyObject *dns_entry = 0;

    if (!email_entry)
    {
        email_entry = PyObject_GetAttrString(
                (PyObject *)sipTypeAsPyTypeObject(sipType_QSsl), "EmailEntry");

        if (!email_entry)
            return 0;
    }

    if (!dns_entry)
    {
        dns_entry = PyObject_GetAttrString(
                (PyObject *)sipTypeAsPyTypeObject(sipType_QSsl), "DnsEntry");

        if (!dns_entry)
            return 0;
    }

    // Create the dictionary.
    PyObject *d = PyDict_New();

    if (!d)
        return 0;

    QList<QString> vl;

    // Handle the Qssl::EmailEntry key.
    vl = sipCpp->values(QSsl::EmailEntry);

    if (!vl.isEmpty())
    {
        PyObject *vlobj = PyList_New(vl.count());

        if (!vlobj)
        {
            Py_DECREF(d);
            return 0;
        }

        int rc = PyDict_SetItem(d, email_entry, vlobj);

        Py_DECREF(email_entry);
        Py_DECREF(vlobj);

        if (rc < 0)
        {
            Py_DECREF(d);
            return 0;
        }

        for (int i = 0; i < vl.count(); ++i)
        {
            QString *s = new QString(vl.at(i));
            PyObject *vobj = sipConvertFromNewType(s, sipType_QString,
                    sipTransferObj);

            if (!vobj)
            {
                delete s;
                Py_DECREF(d);
                return 0;
            }

            PyList_SetItem(vlobj, i, vobj);
        }
    }

    // Handle the Qssl::DnsEntry key.
    vl = sipCpp->values(QSsl::DnsEntry);

    if (!vl.isEmpty())
    {
        PyObject *vlobj = PyList_New(vl.count());

        if (!vlobj)
        {
            Py_DECREF(d);
            return 0;
        }

        int rc = PyDict_SetItem(d, dns_entry, vlobj);

        Py_DECREF(dns_entry);
        Py_DECREF(vlobj);

        if (rc < 0)
        {
            Py_DECREF(d);
            return 0;
        }

        for (int i = 0; i < vl.count(); ++i)
        {
            QString *s = new QString(vl.at(i));
            PyObject *vobj = sipConvertFromNewType(s, sipType_QString,
                    sipTransferObj);

            if (!vobj)
            {
                delete s;
                Py_DECREF(d);
                return 0;
            }

            PyList_SetItem(vlobj, i, vobj);
        }
    }

    return d;
#line 6620 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


sipMappedTypeDef sipTypeDef_QtNetwork_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_0,     /* QMultiMap<QSsl::AlternativeNameEntryType,QString> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString,
    array_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString,
    copy_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString,
    release_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString,
    convertTo_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString,
    convertFrom_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString
};

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qudpsocket.sip"
#include <qudpsocket.h>
#line 6652 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 6656 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkdatagram.sip"
#include <qnetworkdatagram.h>
#line 6659 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 86 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkinterface.sip"
#include <qnetworkinterface.h>
#line 6662 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhostaddress.sip"
#include <qhostaddress.h>
#line 6665 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 6668 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 6671 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 6674 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 6677 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 6680 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 6683 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkproxy.sip"
#include <qnetworkproxy.h>
#line 6686 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qauthenticator.sip"
#include <qauthenticator.h>
#line 6689 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 160 "sip/QtCore/qglobal.sip"
#include <QtGlobal>
#line 6692 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qiodevice.sip"
#include <qiodevice.h>
#line 6695 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 6698 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6701 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6704 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 6707 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6710 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6713 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6716 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 6719 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 6722 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 6725 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 6728 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 6731 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


class sipQUdpSocket : public  ::QUdpSocket
{
public:
    sipQUdpSocket( ::QObject*);
    virtual ~sipQUdpSocket();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::qint64 writeData(const char*,PY_LONG_LONG) SIP_OVERRIDE;
     ::qint64 readLineData(char*, ::qint64) SIP_OVERRIDE;
     ::qint64 readData(char*, ::qint64) SIP_OVERRIDE;
    bool waitForBytesWritten(int) SIP_OVERRIDE;
    bool waitForReadyRead(int) SIP_OVERRIDE;
    bool canReadLine() const SIP_OVERRIDE;
     ::qint64 bytesToWrite() const SIP_OVERRIDE;
     ::qint64 bytesAvailable() const SIP_OVERRIDE;
    bool reset() SIP_OVERRIDE;
    bool atEnd() const SIP_OVERRIDE;
    bool seek( ::qint64) SIP_OVERRIDE;
     ::qint64 size() const SIP_OVERRIDE;
     ::qint64 pos() const SIP_OVERRIDE;
    void close() SIP_OVERRIDE;
    bool open( ::QIODevice::OpenMode) SIP_OVERRIDE;
    bool isSequential() const SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectToHost(const  ::QString&, ::quint16, ::QIODevice::OpenMode, ::QAbstractSocket::NetworkLayerProtocol) SIP_OVERRIDE;
    void connectToHost(const  ::QHostAddress&, ::quint16, ::QIODevice::OpenMode) SIP_OVERRIDE;
    void disconnectFromHost() SIP_OVERRIDE;
    void setReadBufferSize( ::qint64) SIP_OVERRIDE;
    bool setSocketDescriptor( ::qintptr, ::QAbstractSocket::SocketState, ::QIODevice::OpenMode) SIP_OVERRIDE;
     ::qintptr socketDescriptor() const SIP_OVERRIDE;
    bool waitForConnected(int) SIP_OVERRIDE;
    bool waitForDisconnected(int) SIP_OVERRIDE;
    void setSocketOption( ::QAbstractSocket::SocketOption,const  ::QVariant&) SIP_OVERRIDE;
     ::QVariant socketOption( ::QAbstractSocket::SocketOption) SIP_OVERRIDE;
    void resume() SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQUdpSocket(const sipQUdpSocket &);
    sipQUdpSocket &operator = (const sipQUdpSocket &);

    char sipPyMethods[34];
};

sipQUdpSocket::sipQUdpSocket( ::QObject*a0):  ::QUdpSocket(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQUdpSocket::~sipQUdpSocket()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQUdpSocket::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtNetwork_qt_metaobject(sipPySelf,sipType_QUdpSocket);

    return  ::QUdpSocket::metaObject();
}

int sipQUdpSocket::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QUdpSocket::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtNetwork_qt_metacall(sipPySelf,sipType_QUdpSocket,_c,_id,_a);

    return _id;
}

void *sipQUdpSocket::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtNetwork_qt_metacast(sipPySelf, sipType_QUdpSocket, _clname, &sipCpp) ? sipCpp :  ::QUdpSocket::qt_metacast(_clname));
}

 ::qint64 sipQUdpSocket::writeData(const char*a0,PY_LONG_LONG a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_writeData);

    if (!sipMeth)
        return  ::QUdpSocket::writeData(a0,a1);

    extern  ::qint64 sipVH_QtNetwork_14(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const char*,PY_LONG_LONG);

    return sipVH_QtNetwork_14(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

 ::qint64 sipQUdpSocket::readLineData(char*a0, ::qint64 a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_readLineData);

    if (!sipMeth)
        return  ::QUdpSocket::readLineData(a0,a1);

    extern  ::qint64 sipVH_QtNetwork_15(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, char*, ::qint64);

    return sipVH_QtNetwork_15(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

 ::qint64 sipQUdpSocket::readData(char*a0, ::qint64 a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_readData);

    if (!sipMeth)
        return  ::QUdpSocket::readData(a0,a1);

    extern  ::qint64 sipVH_QtNetwork_16(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, char*, ::qint64);

    return sipVH_QtNetwork_16(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQUdpSocket::waitForBytesWritten(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_waitForBytesWritten);

    if (!sipMeth)
        return  ::QUdpSocket::waitForBytesWritten(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQUdpSocket::waitForReadyRead(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_waitForReadyRead);

    if (!sipMeth)
        return  ::QUdpSocket::waitForReadyRead(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQUdpSocket::canReadLine() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[5]),sipPySelf,SIP_NULLPTR,sipName_canReadLine);

    if (!sipMeth)
        return  ::QUdpSocket::canReadLine();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::qint64 sipQUdpSocket::bytesToWrite() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[6]),sipPySelf,SIP_NULLPTR,sipName_bytesToWrite);

    if (!sipMeth)
        return  ::QUdpSocket::bytesToWrite();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::qint64 sipQUdpSocket::bytesAvailable() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[7]),sipPySelf,SIP_NULLPTR,sipName_bytesAvailable);

    if (!sipMeth)
        return  ::QUdpSocket::bytesAvailable();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQUdpSocket::reset()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[8],sipPySelf,SIP_NULLPTR,sipName_reset);

    if (!sipMeth)
        return  ::QUdpSocket::reset();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQUdpSocket::atEnd() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[9]),sipPySelf,SIP_NULLPTR,sipName_atEnd);

    if (!sipMeth)
        return  ::QUdpSocket::atEnd();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQUdpSocket::seek( ::qint64 a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[10],sipPySelf,SIP_NULLPTR,sipName_seek);

    if (!sipMeth)
        return  ::QUdpSocket::seek(a0);

    extern bool sipVH_QtNetwork_19(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::qint64);

    return sipVH_QtNetwork_19(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

 ::qint64 sipQUdpSocket::size() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[11]),sipPySelf,SIP_NULLPTR,sipName_size);

    if (!sipMeth)
        return  ::QUdpSocket::size();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::qint64 sipQUdpSocket::pos() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[12]),sipPySelf,SIP_NULLPTR,sipName_pos);

    if (!sipMeth)
        return  ::QUdpSocket::pos();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

void sipQUdpSocket::close()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[13],sipPySelf,SIP_NULLPTR,sipName_close);

    if (!sipMeth)
    {
         ::QUdpSocket::close();
        return;
    }

    extern void sipVH_QtNetwork_13(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_QtNetwork_13(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQUdpSocket::open( ::QIODevice::OpenMode a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[14],sipPySelf,SIP_NULLPTR,sipName_open);

    if (!sipMeth)
        return  ::QUdpSocket::open(a0);

    extern bool sipVH_QtNetwork_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QIODevice::OpenMode);

    return sipVH_QtNetwork_20(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQUdpSocket::isSequential() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[15]),sipPySelf,SIP_NULLPTR,sipName_isSequential);

    if (!sipMeth)
        return  ::QUdpSocket::isSequential();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQUdpSocket::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[16],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QUdpSocket::event(a0);

    extern bool sipVH_QtNetwork_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtNetwork_5(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQUdpSocket::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[17],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QUdpSocket::eventFilter(a0,a1);

    extern bool sipVH_QtNetwork_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtNetwork_4(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

void sipQUdpSocket::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[18],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QUdpSocket::timerEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtNetwork_3(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQUdpSocket::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[19],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QUdpSocket::childEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtNetwork_2(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQUdpSocket::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[20],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QUdpSocket::customEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtNetwork_1(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQUdpSocket::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[21],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QUdpSocket::connectNotify(a0);
        return;
    }

    extern void sipVH_QtNetwork_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtNetwork_0(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQUdpSocket::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[22],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QUdpSocket::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtNetwork_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtNetwork_0(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQUdpSocket::connectToHost(const  ::QString& a0, ::quint16 a1, ::QIODevice::OpenMode a2, ::QAbstractSocket::NetworkLayerProtocol a3)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[23],sipPySelf,SIP_NULLPTR,sipName_connectToHost);

    if (!sipMeth)
    {
         ::QUdpSocket::connectToHost(a0,a1,a2,a3);
        return;
    }

    extern void sipVH_QtNetwork_21(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QString&, ::quint16, ::QIODevice::OpenMode, ::QAbstractSocket::NetworkLayerProtocol);

    sipVH_QtNetwork_21(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3);
}

void sipQUdpSocket::connectToHost(const  ::QHostAddress& a0, ::quint16 a1, ::QIODevice::OpenMode a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[24],sipPySelf,SIP_NULLPTR,sipName_connectToHost);

    if (!sipMeth)
    {
         ::QUdpSocket::connectToHost(a0,a1,a2);
        return;
    }

    extern void sipVH_QtNetwork_22(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QHostAddress&, ::quint16, ::QIODevice::OpenMode);

    sipVH_QtNetwork_22(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2);
}

void sipQUdpSocket::disconnectFromHost()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[25],sipPySelf,SIP_NULLPTR,sipName_disconnectFromHost);

    if (!sipMeth)
    {
         ::QUdpSocket::disconnectFromHost();
        return;
    }

    extern void sipVH_QtNetwork_13(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_QtNetwork_13(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

void sipQUdpSocket::setReadBufferSize( ::qint64 a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[26],sipPySelf,SIP_NULLPTR,sipName_setReadBufferSize);

    if (!sipMeth)
    {
         ::QUdpSocket::setReadBufferSize(a0);
        return;
    }

    extern void sipVH_QtNetwork_23(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::qint64);

    sipVH_QtNetwork_23(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQUdpSocket::setSocketDescriptor( ::qintptr a0, ::QAbstractSocket::SocketState a1, ::QIODevice::OpenMode a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[27],sipPySelf,SIP_NULLPTR,sipName_setSocketDescriptor);

    if (!sipMeth)
        return  ::QUdpSocket::setSocketDescriptor(a0,a1,a2);

    extern bool sipVH_QtNetwork_24(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::qintptr, ::QAbstractSocket::SocketState, ::QIODevice::OpenMode);

    return sipVH_QtNetwork_24(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2);
}

 ::qintptr sipQUdpSocket::socketDescriptor() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[28]),sipPySelf,SIP_NULLPTR,sipName_socketDescriptor);

    if (!sipMeth)
        return  ::QUdpSocket::socketDescriptor();

    extern  ::qintptr sipVH_QtNetwork_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_25(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQUdpSocket::waitForConnected(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[29],sipPySelf,SIP_NULLPTR,sipName_waitForConnected);

    if (!sipMeth)
        return  ::QUdpSocket::waitForConnected(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQUdpSocket::waitForDisconnected(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[30],sipPySelf,SIP_NULLPTR,sipName_waitForDisconnected);

    if (!sipMeth)
        return  ::QUdpSocket::waitForDisconnected(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQUdpSocket::setSocketOption( ::QAbstractSocket::SocketOption a0,const  ::QVariant& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[31],sipPySelf,SIP_NULLPTR,sipName_setSocketOption);

    if (!sipMeth)
    {
         ::QUdpSocket::setSocketOption(a0,a1);
        return;
    }

    extern void sipVH_QtNetwork_26(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QAbstractSocket::SocketOption,const  ::QVariant&);

    sipVH_QtNetwork_26(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

 ::QVariant sipQUdpSocket::socketOption( ::QAbstractSocket::SocketOption a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[32],sipPySelf,SIP_NULLPTR,sipName_socketOption);

    if (!sipMeth)
        return  ::QUdpSocket::socketOption(a0);

    extern  ::QVariant sipVH_QtNetwork_27(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QAbstractSocket::SocketOption);

    return sipVH_QtNetwork_27(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQUdpSocket::resume()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[33],sipPySelf,SIP_NULLPTR,sipName_resume);

    if (!sipMeth)
    {
         ::QUdpSocket::resume();
        return;
    }

    extern void sipVH_QtNetwork_13(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_QtNetwork_13(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_QUdpSocket_hasPendingDatagrams, "hasPendingDatagrams(self) -> bool");

extern "C" {static PyObject *meth_QUdpSocket_hasPendingDatagrams(PyObject *, PyObject *);}
static PyObject *meth_QUdpSocket_hasPendingDatagrams(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QUdpSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QUdpSocket, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->hasPendingDatagrams();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QUdpSocket, sipName_hasPendingDatagrams, doc_QUdpSocket_hasPendingDatagrams);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QUdpSocket_pendingDatagramSize, "pendingDatagramSize(self) -> int");

extern "C" {static PyObject *meth_QUdpSocket_pendingDatagramSize(PyObject *, PyObject *);}
static PyObject *meth_QUdpSocket_pendingDatagramSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QUdpSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QUdpSocket, &sipCpp))
        {
             ::qint64 sipRes;

            sipRes = sipCpp->pendingDatagramSize();

            return PyLong_FromLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QUdpSocket, sipName_pendingDatagramSize, doc_QUdpSocket_pendingDatagramSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QUdpSocket_readDatagram, "readDatagram(self, int) -> Tuple[bytes, QHostAddress, int]");

extern "C" {static PyObject *meth_QUdpSocket_readDatagram(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QUdpSocket_readDatagram(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qint64 a0;
         ::QHostAddress* a1;
         ::quint16 a2;
         ::QUdpSocket *sipCpp;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bn", &sipSelf, sipType_QUdpSocket, &sipCpp, &a0))
        {
            PyObject * sipRes = SIP_NULLPTR;
            a1 = new  ::QHostAddress();
            int sipIsErr = 0;

#line 36 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qudpsocket.sip"
        // Return the data read or None if there was an error.
        if (a0 < 0)
        {
            PyErr_SetString(PyExc_ValueError, "maximum length of data to be read cannot be negative");
            sipIsErr = 1;
        }
        else
        {
            char *s = new char[a0];
            qint64 len;
        
            Py_BEGIN_ALLOW_THREADS
            len = sipCpp->readDatagram(s, a0, a1, &a2);
            Py_END_ALLOW_THREADS
        
            if (len < 0)
            {
                Py_INCREF(Py_None);
                sipRes = Py_None;
            }
            else
            {
                sipRes = SIPBytes_FromStringAndSize(s, len);
        
                if (!sipRes)
                    sipIsErr = 1;
            }
        
            delete[] s;
        }
#line 7487 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            if (sipIsErr)
                return 0;

            return sipBuildResult(0,"(RNt)",sipRes,a1,sipType_QHostAddress,SIP_NULLPTR,a2);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QUdpSocket, sipName_readDatagram, doc_QUdpSocket_readDatagram);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QUdpSocket_writeDatagram, "writeDatagram(self, bytes, Union[QHostAddress, QHostAddress.SpecialAddress], int) -> int\n"
"writeDatagram(self, Union[QByteArray, bytes, bytearray], Union[QHostAddress, QHostAddress.SpecialAddress], int) -> int\n"
"writeDatagram(self, QNetworkDatagram) -> int");

extern "C" {static PyObject *meth_QUdpSocket_writeDatagram(PyObject *, PyObject *);}
static PyObject *meth_QUdpSocket_writeDatagram(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const char* a0;
        SIP_SSIZE_T a1;
        const  ::QHostAddress* a2;
        int a2State = 0;
         ::quint16 a3;
         ::QUdpSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BkJ1t", &sipSelf, sipType_QUdpSocket, &sipCpp, &a0, &a1, sipType_QHostAddress, &a2, &a2State, &a3))
        {
             ::qint64 sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->writeDatagram(a0,(PY_LONG_LONG)a1,*a2,a3);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QHostAddress *>(a2),sipType_QHostAddress,a2State);

            return PyLong_FromLongLong(sipRes);
        }
    }

    {
        const  ::QByteArray* a0;
        int a0State = 0;
        const  ::QHostAddress* a1;
        int a1State = 0;
         ::quint16 a2;
         ::QUdpSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J1t", &sipSelf, sipType_QUdpSocket, &sipCpp, sipType_QByteArray, &a0, &a0State, sipType_QHostAddress, &a1, &a1State, &a2))
        {
             ::qint64 sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->writeDatagram(*a0,*a1,a2);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);
            sipReleaseType(const_cast< ::QHostAddress *>(a1),sipType_QHostAddress,a1State);

            return PyLong_FromLongLong(sipRes);
        }
    }

    {
        const  ::QNetworkDatagram* a0;
         ::QUdpSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QUdpSocket, &sipCpp, sipType_QNetworkDatagram, &a0))
        {
             ::qint64 sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->writeDatagram(*a0);
            Py_END_ALLOW_THREADS

            return PyLong_FromLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QUdpSocket, sipName_writeDatagram, doc_QUdpSocket_writeDatagram);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QUdpSocket_joinMulticastGroup, "joinMulticastGroup(self, Union[QHostAddress, QHostAddress.SpecialAddress]) -> bool\n"
"joinMulticastGroup(self, Union[QHostAddress, QHostAddress.SpecialAddress], QNetworkInterface) -> bool");

extern "C" {static PyObject *meth_QUdpSocket_joinMulticastGroup(PyObject *, PyObject *);}
static PyObject *meth_QUdpSocket_joinMulticastGroup(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QHostAddress* a0;
        int a0State = 0;
         ::QUdpSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QUdpSocket, &sipCpp, sipType_QHostAddress, &a0, &a0State))
        {
            bool sipRes;

            sipRes = sipCpp->joinMulticastGroup(*a0);
            sipReleaseType(const_cast< ::QHostAddress *>(a0),sipType_QHostAddress,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::QHostAddress* a0;
        int a0State = 0;
        const  ::QNetworkInterface* a1;
         ::QUdpSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J9", &sipSelf, sipType_QUdpSocket, &sipCpp, sipType_QHostAddress, &a0, &a0State, sipType_QNetworkInterface, &a1))
        {
            bool sipRes;

            sipRes = sipCpp->joinMulticastGroup(*a0,*a1);
            sipReleaseType(const_cast< ::QHostAddress *>(a0),sipType_QHostAddress,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QUdpSocket, sipName_joinMulticastGroup, doc_QUdpSocket_joinMulticastGroup);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QUdpSocket_leaveMulticastGroup, "leaveMulticastGroup(self, Union[QHostAddress, QHostAddress.SpecialAddress]) -> bool\n"
"leaveMulticastGroup(self, Union[QHostAddress, QHostAddress.SpecialAddress], QNetworkInterface) -> bool");

extern "C" {static PyObject *meth_QUdpSocket_leaveMulticastGroup(PyObject *, PyObject *);}
static PyObject *meth_QUdpSocket_leaveMulticastGroup(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QHostAddress* a0;
        int a0State = 0;
         ::QUdpSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QUdpSocket, &sipCpp, sipType_QHostAddress, &a0, &a0State))
        {
            bool sipRes;

            sipRes = sipCpp->leaveMulticastGroup(*a0);
            sipReleaseType(const_cast< ::QHostAddress *>(a0),sipType_QHostAddress,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::QHostAddress* a0;
        int a0State = 0;
        const  ::QNetworkInterface* a1;
         ::QUdpSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J9", &sipSelf, sipType_QUdpSocket, &sipCpp, sipType_QHostAddress, &a0, &a0State, sipType_QNetworkInterface, &a1))
        {
            bool sipRes;

            sipRes = sipCpp->leaveMulticastGroup(*a0,*a1);
            sipReleaseType(const_cast< ::QHostAddress *>(a0),sipType_QHostAddress,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QUdpSocket, sipName_leaveMulticastGroup, doc_QUdpSocket_leaveMulticastGroup);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QUdpSocket_multicastInterface, "multicastInterface(self) -> QNetworkInterface");

extern "C" {static PyObject *meth_QUdpSocket_multicastInterface(PyObject *, PyObject *);}
static PyObject *meth_QUdpSocket_multicastInterface(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QUdpSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QUdpSocket, &sipCpp))
        {
             ::QNetworkInterface*sipRes;

            sipRes = new  ::QNetworkInterface(sipCpp->multicastInterface());

            return sipConvertFromNewType(sipRes,sipType_QNetworkInterface,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QUdpSocket, sipName_multicastInterface, doc_QUdpSocket_multicastInterface);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QUdpSocket_setMulticastInterface, "setMulticastInterface(self, QNetworkInterface)");

extern "C" {static PyObject *meth_QUdpSocket_setMulticastInterface(PyObject *, PyObject *);}
static PyObject *meth_QUdpSocket_setMulticastInterface(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkInterface* a0;
         ::QUdpSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QUdpSocket, &sipCpp, sipType_QNetworkInterface, &a0))
        {
            sipCpp->setMulticastInterface(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QUdpSocket, sipName_setMulticastInterface, doc_QUdpSocket_setMulticastInterface);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QUdpSocket_receiveDatagram, "receiveDatagram(self, maxSize: int = -1) -> QNetworkDatagram");

extern "C" {static PyObject *meth_QUdpSocket_receiveDatagram(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QUdpSocket_receiveDatagram(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qint64 a0 = -1;
         ::QUdpSocket *sipCpp;

        static const char *sipKwdList[] = {
            sipName_maxSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|n", &sipSelf, sipType_QUdpSocket, &sipCpp, &a0))
        {
             ::QNetworkDatagram*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::QNetworkDatagram(sipCpp->receiveDatagram(a0));
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QNetworkDatagram,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QUdpSocket, sipName_receiveDatagram, doc_QUdpSocket_receiveDatagram);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QUdpSocket(void *, const sipTypeDef *);}
static void *cast_QUdpSocket(void *sipCppV, const sipTypeDef *targetType)
{
     ::QUdpSocket *sipCpp = reinterpret_cast< ::QUdpSocket *>(sipCppV);

    if (targetType == sipType_QAbstractSocket)
        return static_cast< ::QAbstractSocket *>(sipCpp);

    if (targetType == sipType_QIODevice)
        return static_cast< ::QIODevice *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QUdpSocket(void *, int);}
static void release_QUdpSocket(void *sipCppV, int)
{
     ::QUdpSocket *sipCpp = reinterpret_cast< ::QUdpSocket *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QUdpSocket(sipSimpleWrapper *);}
static void dealloc_QUdpSocket(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQUdpSocket *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QUdpSocket(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QUdpSocket(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QUdpSocket(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQUdpSocket *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQUdpSocket(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QUdpSocket[] = {{1, 255, 1}};


static PyMethodDef methods_QUdpSocket[] = {
    {SIP_MLNAME_CAST(sipName_hasPendingDatagrams), meth_QUdpSocket_hasPendingDatagrams, METH_VARARGS, SIP_MLDOC_CAST(doc_QUdpSocket_hasPendingDatagrams)},
    {SIP_MLNAME_CAST(sipName_joinMulticastGroup), meth_QUdpSocket_joinMulticastGroup, METH_VARARGS, SIP_MLDOC_CAST(doc_QUdpSocket_joinMulticastGroup)},
    {SIP_MLNAME_CAST(sipName_leaveMulticastGroup), meth_QUdpSocket_leaveMulticastGroup, METH_VARARGS, SIP_MLDOC_CAST(doc_QUdpSocket_leaveMulticastGroup)},
    {SIP_MLNAME_CAST(sipName_multicastInterface), meth_QUdpSocket_multicastInterface, METH_VARARGS, SIP_MLDOC_CAST(doc_QUdpSocket_multicastInterface)},
    {SIP_MLNAME_CAST(sipName_pendingDatagramSize), meth_QUdpSocket_pendingDatagramSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QUdpSocket_pendingDatagramSize)},
    {SIP_MLNAME_CAST(sipName_readDatagram), SIP_MLMETH_CAST(meth_QUdpSocket_readDatagram), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QUdpSocket_readDatagram)},
    {SIP_MLNAME_CAST(sipName_receiveDatagram), SIP_MLMETH_CAST(meth_QUdpSocket_receiveDatagram), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QUdpSocket_receiveDatagram)},
    {SIP_MLNAME_CAST(sipName_setMulticastInterface), meth_QUdpSocket_setMulticastInterface, METH_VARARGS, SIP_MLDOC_CAST(doc_QUdpSocket_setMulticastInterface)},
    {SIP_MLNAME_CAST(sipName_writeDatagram), meth_QUdpSocket_writeDatagram, METH_VARARGS, SIP_MLDOC_CAST(doc_QUdpSocket_writeDatagram)}
};

PyDoc_STRVAR(doc_QUdpSocket, "\1QUdpSocket(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QUdpSocket = {
    & ::QUdpSocket::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QUdpSocket = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QUdpSocket,
        {SIP_NULLPTR},
        &plugin_QUdpSocket
    },
    {
        sipNameNr_QUdpSocket,
        {0, 0, 1},
        9, methods_QUdpSocket,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QUdpSocket,
    -1,
    -1,
    supers_QUdpSocket,
    SIP_NULLPTR,
    init_type_QUdpSocket,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QUdpSocket,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QUdpSocket,
    cast_QUdpSocket,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qtcpserver.sip"
#include <qtcpserver.h>
#line 7922 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 7926 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 7929 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qtcpsocket.sip"
#include <qtcpsocket.h>
#line 7932 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 160 "sip/QtCore/qglobal.sip"
#include <QtGlobal>
#line 7935 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkproxy.sip"
#include <qnetworkproxy.h>
#line 7938 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 7941 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhostaddress.sip"
#include <qhostaddress.h>
#line 7944 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 7947 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7950 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7953 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 7956 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 7959 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7962 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 7965 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 7968 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 7971 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 7974 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 7977 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 7980 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 7983 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 7986 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


class sipQTcpServer : public  ::QTcpServer
{
public:
    sipQTcpServer( ::QObject*);
    virtual ~sipQTcpServer();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void incomingConnection( ::qintptr) SIP_OVERRIDE;
     ::QTcpSocket* nextPendingConnection() SIP_OVERRIDE;
    bool hasPendingConnections() const SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQTcpServer(const sipQTcpServer &);
    sipQTcpServer &operator = (const sipQTcpServer &);

    char sipPyMethods[10];
};

sipQTcpServer::sipQTcpServer( ::QObject*a0):  ::QTcpServer(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQTcpServer::~sipQTcpServer()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQTcpServer::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtNetwork_qt_metaobject(sipPySelf,sipType_QTcpServer);

    return  ::QTcpServer::metaObject();
}

int sipQTcpServer::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QTcpServer::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtNetwork_qt_metacall(sipPySelf,sipType_QTcpServer,_c,_id,_a);

    return _id;
}

void *sipQTcpServer::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtNetwork_qt_metacast(sipPySelf, sipType_QTcpServer, _clname, &sipCpp) ? sipCpp :  ::QTcpServer::qt_metacast(_clname));
}

void sipQTcpServer::incomingConnection( ::qintptr a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_incomingConnection);

    if (!sipMeth)
    {
         ::QTcpServer::incomingConnection(a0);
        return;
    }

    extern void sipVH_QtNetwork_40(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::qintptr);

    sipVH_QtNetwork_40(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

 ::QTcpSocket* sipQTcpServer::nextPendingConnection()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_nextPendingConnection);

    if (!sipMeth)
        return  ::QTcpServer::nextPendingConnection();

    extern  ::QTcpSocket* sipVH_QtNetwork_39(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_39(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQTcpServer::hasPendingConnections() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[2]),sipPySelf,SIP_NULLPTR,sipName_hasPendingConnections);

    if (!sipMeth)
        return  ::QTcpServer::hasPendingConnections();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQTcpServer::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QTcpServer::event(a0);

    extern bool sipVH_QtNetwork_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtNetwork_5(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQTcpServer::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QTcpServer::eventFilter(a0,a1);

    extern bool sipVH_QtNetwork_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtNetwork_4(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

void sipQTcpServer::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QTcpServer::timerEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtNetwork_3(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTcpServer::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QTcpServer::childEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtNetwork_2(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTcpServer::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[7],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QTcpServer::customEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtNetwork_1(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTcpServer::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[8],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QTcpServer::connectNotify(a0);
        return;
    }

    extern void sipVH_QtNetwork_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtNetwork_0(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTcpServer::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[9],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QTcpServer::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtNetwork_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtNetwork_0(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QTcpServer_listen, "listen(self, address: Union[QHostAddress, QHostAddress.SpecialAddress] = QHostAddress.Any, port: int = 0) -> bool");

extern "C" {static PyObject *meth_QTcpServer_listen(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_listen(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QHostAddress& a0def = QHostAddress::Any;
        const  ::QHostAddress* a0 = &a0def;
        int a0State = 0;
         ::quint16 a1 = 0;
         ::QTcpServer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_address,
            sipName_port,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|J1t", &sipSelf, sipType_QTcpServer, &sipCpp, sipType_QHostAddress, &a0, &a0State, &a1))
        {
            bool sipRes;

            sipRes = sipCpp->listen(*a0,a1);
            sipReleaseType(const_cast< ::QHostAddress *>(a0),sipType_QHostAddress,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_listen, doc_QTcpServer_listen);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_close, "close(self)");

extern "C" {static PyObject *meth_QTcpServer_close(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_close(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
            sipCpp->close();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_close, doc_QTcpServer_close);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_isListening, "isListening(self) -> bool");

extern "C" {static PyObject *meth_QTcpServer_isListening(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_isListening(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isListening();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_isListening, doc_QTcpServer_isListening);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_setMaxPendingConnections, "setMaxPendingConnections(self, int)");

extern "C" {static PyObject *meth_QTcpServer_setMaxPendingConnections(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_setMaxPendingConnections(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;
         ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QTcpServer, &sipCpp, &a0))
        {
            sipCpp->setMaxPendingConnections(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_setMaxPendingConnections, doc_QTcpServer_setMaxPendingConnections);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_maxPendingConnections, "maxPendingConnections(self) -> int");

extern "C" {static PyObject *meth_QTcpServer_maxPendingConnections(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_maxPendingConnections(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->maxPendingConnections();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_maxPendingConnections, doc_QTcpServer_maxPendingConnections);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_serverPort, "serverPort(self) -> int");

extern "C" {static PyObject *meth_QTcpServer_serverPort(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_serverPort(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
             ::quint16 sipRes;

            sipRes = sipCpp->serverPort();

#if PY_MAJOR_VERSION >= 3
            return PyLong_FromUnsignedLong(sipRes);
#else
            return PyInt_FromLong(sipRes);
#endif
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_serverPort, doc_QTcpServer_serverPort);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_serverAddress, "serverAddress(self) -> QHostAddress");

extern "C" {static PyObject *meth_QTcpServer_serverAddress(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_serverAddress(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
             ::QHostAddress*sipRes;

            sipRes = new  ::QHostAddress(sipCpp->serverAddress());

            return sipConvertFromNewType(sipRes,sipType_QHostAddress,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_serverAddress, doc_QTcpServer_serverAddress);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_socketDescriptor, "socketDescriptor(self) -> sip.voidptr");

extern "C" {static PyObject *meth_QTcpServer_socketDescriptor(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_socketDescriptor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
             ::qintptr*sipRes;

            sipRes = new  ::qintptr(sipCpp->socketDescriptor());

            return sipConvertFromNewType(sipRes,sipType_qintptr,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_socketDescriptor, doc_QTcpServer_socketDescriptor);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_setSocketDescriptor, "setSocketDescriptor(self, sip.voidptr) -> bool");

extern "C" {static PyObject *meth_QTcpServer_setSocketDescriptor(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_setSocketDescriptor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::qintptr* a0;
        int a0State = 0;
         ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QTcpServer, &sipCpp, sipType_qintptr,&a0, &a0State))
        {
            bool sipRes;

            sipRes = sipCpp->setSocketDescriptor(*a0);
            sipReleaseType(a0,sipType_qintptr,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_setSocketDescriptor, doc_QTcpServer_setSocketDescriptor);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_waitForNewConnection, "waitForNewConnection(self, msecs: int = 0) -> Tuple[bool, bool]");

extern "C" {static PyObject *meth_QTcpServer_waitForNewConnection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_waitForNewConnection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0 = 0;
        bool a1;
         ::QTcpServer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_msecs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_QTcpServer, &sipCpp, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->waitForNewConnection(a0,&a1);
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(bb)",sipRes,a1);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_waitForNewConnection, doc_QTcpServer_waitForNewConnection);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_hasPendingConnections, "hasPendingConnections(self) -> bool");

extern "C" {static PyObject *meth_QTcpServer_hasPendingConnections(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_hasPendingConnections(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
            bool sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::QTcpServer::hasPendingConnections() : sipCpp->hasPendingConnections());

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_hasPendingConnections, doc_QTcpServer_hasPendingConnections);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_nextPendingConnection, "nextPendingConnection(self) -> QTcpSocket");

extern "C" {static PyObject *meth_QTcpServer_nextPendingConnection(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_nextPendingConnection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
             ::QTcpSocket*sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::QTcpServer::nextPendingConnection() : sipCpp->nextPendingConnection());

            return sipConvertFromType(sipRes,sipType_QTcpSocket,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_nextPendingConnection, doc_QTcpServer_nextPendingConnection);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_serverError, "serverError(self) -> QAbstractSocket.SocketError");

extern "C" {static PyObject *meth_QTcpServer_serverError(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_serverError(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
             ::QAbstractSocket::SocketError sipRes;

            sipRes = sipCpp->serverError();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QAbstractSocket_SocketError);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_serverError, doc_QTcpServer_serverError);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_errorString, "errorString(self) -> str");

extern "C" {static PyObject *meth_QTcpServer_errorString(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_errorString(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->errorString());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_errorString, doc_QTcpServer_errorString);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_setProxy, "setProxy(self, QNetworkProxy)");

extern "C" {static PyObject *meth_QTcpServer_setProxy(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_setProxy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkProxy* a0;
         ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QTcpServer, &sipCpp, sipType_QNetworkProxy, &a0))
        {
            sipCpp->setProxy(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_setProxy, doc_QTcpServer_setProxy);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_proxy, "proxy(self) -> QNetworkProxy");

extern "C" {static PyObject *meth_QTcpServer_proxy(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_proxy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
             ::QNetworkProxy*sipRes;

            sipRes = new  ::QNetworkProxy(sipCpp->proxy());

            return sipConvertFromNewType(sipRes,sipType_QNetworkProxy,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_proxy, doc_QTcpServer_proxy);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_pauseAccepting, "pauseAccepting(self)");

extern "C" {static PyObject *meth_QTcpServer_pauseAccepting(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_pauseAccepting(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
            sipCpp->pauseAccepting();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_pauseAccepting, doc_QTcpServer_pauseAccepting);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_resumeAccepting, "resumeAccepting(self)");

extern "C" {static PyObject *meth_QTcpServer_resumeAccepting(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_resumeAccepting(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QTcpServer, &sipCpp))
        {
            sipCpp->resumeAccepting();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_resumeAccepting, doc_QTcpServer_resumeAccepting);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_incomingConnection, "incomingConnection(self, sip.voidptr)");

extern "C" {static PyObject *meth_QTcpServer_incomingConnection(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_incomingConnection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::qintptr* a0;
        int a0State = 0;
         ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ1", &sipSelf, sipType_QTcpServer, &sipCpp, sipType_qintptr,&a0, &a0State))
        {
            (sipSelfWasArg ? sipCpp-> ::QTcpServer::incomingConnection(*a0) : sipCpp->incomingConnection(*a0));
            sipReleaseType(a0,sipType_qintptr,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_incomingConnection, doc_QTcpServer_incomingConnection);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QTcpServer_addPendingConnection, "addPendingConnection(self, QTcpSocket)");

extern "C" {static PyObject *meth_QTcpServer_addPendingConnection(PyObject *, PyObject *);}
static PyObject *meth_QTcpServer_addPendingConnection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QTcpSocket* a0;
         ::QTcpServer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ8", &sipSelf, sipType_QTcpServer, &sipCpp, sipType_QTcpSocket, &a0))
        {
            sipCpp->addPendingConnection(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QTcpServer, sipName_addPendingConnection, doc_QTcpServer_addPendingConnection);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QTcpServer(void *, const sipTypeDef *);}
static void *cast_QTcpServer(void *sipCppV, const sipTypeDef *targetType)
{
     ::QTcpServer *sipCpp = reinterpret_cast< ::QTcpServer *>(sipCppV);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QTcpServer(void *, int);}
static void release_QTcpServer(void *sipCppV, int)
{
     ::QTcpServer *sipCpp = reinterpret_cast< ::QTcpServer *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QTcpServer(sipSimpleWrapper *);}
static void dealloc_QTcpServer(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQTcpServer *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QTcpServer(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QTcpServer(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QTcpServer(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQTcpServer *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQTcpServer(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QTcpServer[] = {{12, 0, 1}};


static PyMethodDef methods_QTcpServer[] = {
    {SIP_MLNAME_CAST(sipName_addPendingConnection), meth_QTcpServer_addPendingConnection, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_addPendingConnection)},
    {SIP_MLNAME_CAST(sipName_close), meth_QTcpServer_close, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_close)},
    {SIP_MLNAME_CAST(sipName_errorString), meth_QTcpServer_errorString, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_errorString)},
    {SIP_MLNAME_CAST(sipName_hasPendingConnections), meth_QTcpServer_hasPendingConnections, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_hasPendingConnections)},
    {SIP_MLNAME_CAST(sipName_incomingConnection), meth_QTcpServer_incomingConnection, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_incomingConnection)},
    {SIP_MLNAME_CAST(sipName_isListening), meth_QTcpServer_isListening, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_isListening)},
    {SIP_MLNAME_CAST(sipName_listen), SIP_MLMETH_CAST(meth_QTcpServer_listen), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QTcpServer_listen)},
    {SIP_MLNAME_CAST(sipName_maxPendingConnections), meth_QTcpServer_maxPendingConnections, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_maxPendingConnections)},
    {SIP_MLNAME_CAST(sipName_nextPendingConnection), meth_QTcpServer_nextPendingConnection, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_nextPendingConnection)},
    {SIP_MLNAME_CAST(sipName_pauseAccepting), meth_QTcpServer_pauseAccepting, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_pauseAccepting)},
    {SIP_MLNAME_CAST(sipName_proxy), meth_QTcpServer_proxy, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_proxy)},
    {SIP_MLNAME_CAST(sipName_resumeAccepting), meth_QTcpServer_resumeAccepting, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_resumeAccepting)},
    {SIP_MLNAME_CAST(sipName_serverAddress), meth_QTcpServer_serverAddress, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_serverAddress)},
    {SIP_MLNAME_CAST(sipName_serverError), meth_QTcpServer_serverError, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_serverError)},
    {SIP_MLNAME_CAST(sipName_serverPort), meth_QTcpServer_serverPort, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_serverPort)},
    {SIP_MLNAME_CAST(sipName_setMaxPendingConnections), meth_QTcpServer_setMaxPendingConnections, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_setMaxPendingConnections)},
    {SIP_MLNAME_CAST(sipName_setProxy), meth_QTcpServer_setProxy, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_setProxy)},
    {SIP_MLNAME_CAST(sipName_setSocketDescriptor), meth_QTcpServer_setSocketDescriptor, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_setSocketDescriptor)},
    {SIP_MLNAME_CAST(sipName_socketDescriptor), meth_QTcpServer_socketDescriptor, METH_VARARGS, SIP_MLDOC_CAST(doc_QTcpServer_socketDescriptor)},
    {SIP_MLNAME_CAST(sipName_waitForNewConnection), SIP_MLMETH_CAST(meth_QTcpServer_waitForNewConnection), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QTcpServer_waitForNewConnection)}
};

PyDoc_STRVAR(doc_QTcpServer, "\1QTcpServer(parent: QObject = None)");


/* Define this type's signals. */
static const pyqt5QtSignal signals_QTcpServer[] = {
    {"acceptError(QAbstractSocket::SocketError)", "\1acceptError(self, QAbstractSocket.SocketError)", SIP_NULLPTR, SIP_NULLPTR},
    {"newConnection()", "\1newConnection(self)", SIP_NULLPTR, SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


static pyqt5ClassPluginDef plugin_QTcpServer = {
    & ::QTcpServer::staticMetaObject,
    0,
    signals_QTcpServer,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QTcpServer = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QTcpServer,
        {SIP_NULLPTR},
        &plugin_QTcpServer
    },
    {
        sipNameNr_QTcpServer,
        {0, 0, 1},
        20, methods_QTcpServer,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QTcpServer,
    -1,
    -1,
    supers_QTcpServer,
    SIP_NULLPTR,
    init_type_QTcpServer,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QTcpServer,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QTcpServer,
    cast_QTcpServer,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslsocket.sip"
#include <qsslsocket.h>
#line 8979 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 8983 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 8986 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 8989 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8992 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcertificate.sip"
#include <qsslcertificate.h>
#line 8995 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qiodevice.sip"
#include <qiodevice.h>
#line 8998 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 9001 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 9004 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslerror.sip"
#include <qsslerror.h>
#line 9007 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslconfiguration.sip"
#include <qsslconfiguration.h>
#line 9010 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslpresharedkeyauthenticator.sip"
#include <qsslpresharedkeyauthenticator.h>
#line 9013 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9016 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 9019 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9022 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcipher.sip"
#include <qsslcipher.h>
#line 9025 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslkey.sip"
#include <qsslkey.h>
#line 9028 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 9031 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 160 "sip/QtCore/qglobal.sip"
#include <QtGlobal>
#line 9034 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhostaddress.sip"
#include <qhostaddress.h>
#line 9037 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 9040 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 9043 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkproxy.sip"
#include <qnetworkproxy.h>
#line 9046 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qauthenticator.sip"
#include <qauthenticator.h>
#line 9049 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 9052 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 9055 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 9058 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 9061 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9064 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9067 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 9070 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 9073 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 9076 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 9079 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 9082 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


class sipQSslSocket : public  ::QSslSocket
{
public:
    sipQSslSocket( ::QObject*);
    virtual ~sipQSslSocket();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void resume() SIP_OVERRIDE;
     ::QVariant socketOption( ::QAbstractSocket::SocketOption) SIP_OVERRIDE;
    void setSocketOption( ::QAbstractSocket::SocketOption,const  ::QVariant&) SIP_OVERRIDE;
    bool waitForDisconnected(int) SIP_OVERRIDE;
    bool waitForConnected(int) SIP_OVERRIDE;
     ::qintptr socketDescriptor() const SIP_OVERRIDE;
    bool setSocketDescriptor( ::qintptr, ::QAbstractSocket::SocketState, ::QIODevice::OpenMode) SIP_OVERRIDE;
    void setReadBufferSize( ::qint64) SIP_OVERRIDE;
    void disconnectFromHost() SIP_OVERRIDE;
    void connectToHost(const  ::QString&, ::quint16, ::QIODevice::OpenMode, ::QAbstractSocket::NetworkLayerProtocol) SIP_OVERRIDE;
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;
    bool isSequential() const SIP_OVERRIDE;
    bool open( ::QIODevice::OpenMode) SIP_OVERRIDE;
    void close() SIP_OVERRIDE;
     ::qint64 pos() const SIP_OVERRIDE;
     ::qint64 size() const SIP_OVERRIDE;
    bool seek( ::qint64) SIP_OVERRIDE;
    bool atEnd() const SIP_OVERRIDE;
    bool reset() SIP_OVERRIDE;
     ::qint64 bytesAvailable() const SIP_OVERRIDE;
     ::qint64 bytesToWrite() const SIP_OVERRIDE;
    bool canReadLine() const SIP_OVERRIDE;
    bool waitForReadyRead(int) SIP_OVERRIDE;
    bool waitForBytesWritten(int) SIP_OVERRIDE;
     ::qint64 readData(char*, ::qint64) SIP_OVERRIDE;
     ::qint64 readLineData(char*, ::qint64) SIP_OVERRIDE;
     ::qint64 writeData(const char*,PY_LONG_LONG) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQSslSocket(const sipQSslSocket &);
    sipQSslSocket &operator = (const sipQSslSocket &);

    char sipPyMethods[33];
};

sipQSslSocket::sipQSslSocket( ::QObject*a0):  ::QSslSocket(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQSslSocket::~sipQSslSocket()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQSslSocket::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtNetwork_qt_metaobject(sipPySelf,sipType_QSslSocket);

    return  ::QSslSocket::metaObject();
}

int sipQSslSocket::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QSslSocket::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtNetwork_qt_metacall(sipPySelf,sipType_QSslSocket,_c,_id,_a);

    return _id;
}

void *sipQSslSocket::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtNetwork_qt_metacast(sipPySelf, sipType_QSslSocket, _clname, &sipCpp) ? sipCpp :  ::QSslSocket::qt_metacast(_clname));
}

void sipQSslSocket::resume()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_resume);

    if (!sipMeth)
    {
         ::QSslSocket::resume();
        return;
    }

    extern void sipVH_QtNetwork_13(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_QtNetwork_13(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::QVariant sipQSslSocket::socketOption( ::QAbstractSocket::SocketOption a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_socketOption);

    if (!sipMeth)
        return  ::QSslSocket::socketOption(a0);

    extern  ::QVariant sipVH_QtNetwork_27(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QAbstractSocket::SocketOption);

    return sipVH_QtNetwork_27(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQSslSocket::setSocketOption( ::QAbstractSocket::SocketOption a0,const  ::QVariant& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_setSocketOption);

    if (!sipMeth)
    {
         ::QSslSocket::setSocketOption(a0,a1);
        return;
    }

    extern void sipVH_QtNetwork_26(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QAbstractSocket::SocketOption,const  ::QVariant&);

    sipVH_QtNetwork_26(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQSslSocket::waitForDisconnected(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_waitForDisconnected);

    if (!sipMeth)
        return  ::QSslSocket::waitForDisconnected(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQSslSocket::waitForConnected(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_waitForConnected);

    if (!sipMeth)
        return  ::QSslSocket::waitForConnected(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

 ::qintptr sipQSslSocket::socketDescriptor() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[5]),sipPySelf,SIP_NULLPTR,sipName_socketDescriptor);

    if (!sipMeth)
        return  ::QSslSocket::socketDescriptor();

    extern  ::qintptr sipVH_QtNetwork_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_25(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQSslSocket::setSocketDescriptor( ::qintptr a0, ::QAbstractSocket::SocketState a1, ::QIODevice::OpenMode a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_setSocketDescriptor);

    if (!sipMeth)
        return  ::QSslSocket::setSocketDescriptor(a0,a1,a2);

    extern bool sipVH_QtNetwork_24(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::qintptr, ::QAbstractSocket::SocketState, ::QIODevice::OpenMode);

    return sipVH_QtNetwork_24(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2);
}

void sipQSslSocket::setReadBufferSize( ::qint64 a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[7],sipPySelf,SIP_NULLPTR,sipName_setReadBufferSize);

    if (!sipMeth)
    {
         ::QSslSocket::setReadBufferSize(a0);
        return;
    }

    extern void sipVH_QtNetwork_23(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::qint64);

    sipVH_QtNetwork_23(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQSslSocket::disconnectFromHost()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[8],sipPySelf,SIP_NULLPTR,sipName_disconnectFromHost);

    if (!sipMeth)
    {
         ::QSslSocket::disconnectFromHost();
        return;
    }

    extern void sipVH_QtNetwork_13(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_QtNetwork_13(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

void sipQSslSocket::connectToHost(const  ::QString& a0, ::quint16 a1, ::QIODevice::OpenMode a2, ::QAbstractSocket::NetworkLayerProtocol a3)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[9],sipPySelf,SIP_NULLPTR,sipName_connectToHost);

    if (!sipMeth)
    {
         ::QSslSocket::connectToHost(a0,a1,a2,a3);
        return;
    }

    extern void sipVH_QtNetwork_21(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QString&, ::quint16, ::QIODevice::OpenMode, ::QAbstractSocket::NetworkLayerProtocol);

    sipVH_QtNetwork_21(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3);
}

void sipQSslSocket::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[10],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QSslSocket::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtNetwork_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtNetwork_0(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQSslSocket::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[11],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QSslSocket::connectNotify(a0);
        return;
    }

    extern void sipVH_QtNetwork_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtNetwork_0(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQSslSocket::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[12],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QSslSocket::customEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtNetwork_1(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQSslSocket::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[13],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QSslSocket::childEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtNetwork_2(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQSslSocket::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[14],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QSslSocket::timerEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtNetwork_3(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQSslSocket::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[15],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QSslSocket::eventFilter(a0,a1);

    extern bool sipVH_QtNetwork_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtNetwork_4(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQSslSocket::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[16],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QSslSocket::event(a0);

    extern bool sipVH_QtNetwork_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtNetwork_5(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQSslSocket::isSequential() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[17]),sipPySelf,SIP_NULLPTR,sipName_isSequential);

    if (!sipMeth)
        return  ::QSslSocket::isSequential();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQSslSocket::open( ::QIODevice::OpenMode a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[18],sipPySelf,SIP_NULLPTR,sipName_open);

    if (!sipMeth)
        return  ::QSslSocket::open(a0);

    extern bool sipVH_QtNetwork_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QIODevice::OpenMode);

    return sipVH_QtNetwork_20(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQSslSocket::close()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[19],sipPySelf,SIP_NULLPTR,sipName_close);

    if (!sipMeth)
    {
         ::QSslSocket::close();
        return;
    }

    extern void sipVH_QtNetwork_13(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_QtNetwork_13(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::qint64 sipQSslSocket::pos() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[20]),sipPySelf,SIP_NULLPTR,sipName_pos);

    if (!sipMeth)
        return  ::QSslSocket::pos();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::qint64 sipQSslSocket::size() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[21]),sipPySelf,SIP_NULLPTR,sipName_size);

    if (!sipMeth)
        return  ::QSslSocket::size();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQSslSocket::seek( ::qint64 a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[22],sipPySelf,SIP_NULLPTR,sipName_seek);

    if (!sipMeth)
        return  ::QSslSocket::seek(a0);

    extern bool sipVH_QtNetwork_19(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::qint64);

    return sipVH_QtNetwork_19(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQSslSocket::atEnd() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[23]),sipPySelf,SIP_NULLPTR,sipName_atEnd);

    if (!sipMeth)
        return  ::QSslSocket::atEnd();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQSslSocket::reset()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[24],sipPySelf,SIP_NULLPTR,sipName_reset);

    if (!sipMeth)
        return  ::QSslSocket::reset();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::qint64 sipQSslSocket::bytesAvailable() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[25]),sipPySelf,SIP_NULLPTR,sipName_bytesAvailable);

    if (!sipMeth)
        return  ::QSslSocket::bytesAvailable();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::qint64 sipQSslSocket::bytesToWrite() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[26]),sipPySelf,SIP_NULLPTR,sipName_bytesToWrite);

    if (!sipMeth)
        return  ::QSslSocket::bytesToWrite();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQSslSocket::canReadLine() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[27]),sipPySelf,SIP_NULLPTR,sipName_canReadLine);

    if (!sipMeth)
        return  ::QSslSocket::canReadLine();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQSslSocket::waitForReadyRead(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[28],sipPySelf,SIP_NULLPTR,sipName_waitForReadyRead);

    if (!sipMeth)
        return  ::QSslSocket::waitForReadyRead(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQSslSocket::waitForBytesWritten(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[29],sipPySelf,SIP_NULLPTR,sipName_waitForBytesWritten);

    if (!sipMeth)
        return  ::QSslSocket::waitForBytesWritten(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

 ::qint64 sipQSslSocket::readData(char*a0, ::qint64 a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[30],sipPySelf,SIP_NULLPTR,sipName_readData);

    if (!sipMeth)
        return  ::QSslSocket::readData(a0,a1);

    extern  ::qint64 sipVH_QtNetwork_16(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, char*, ::qint64);

    return sipVH_QtNetwork_16(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

 ::qint64 sipQSslSocket::readLineData(char*a0, ::qint64 a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[31],sipPySelf,SIP_NULLPTR,sipName_readLineData);

    if (!sipMeth)
        return  ::QSslSocket::readLineData(a0,a1);

    extern  ::qint64 sipVH_QtNetwork_15(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, char*, ::qint64);

    return sipVH_QtNetwork_15(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

 ::qint64 sipQSslSocket::writeData(const char*a0,PY_LONG_LONG a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[32],sipPySelf,SIP_NULLPTR,sipName_writeData);

    if (!sipMeth)
        return  ::QSslSocket::writeData(a0,a1);

    extern  ::qint64 sipVH_QtNetwork_14(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const char*,PY_LONG_LONG);

    return sipVH_QtNetwork_14(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}


PyDoc_STRVAR(doc_QSslSocket_connectToHostEncrypted, "connectToHostEncrypted(self, str, int, mode: Union[QIODevice.OpenMode, QIODevice.OpenModeFlag] = QIODevice.ReadWrite, protocol: QAbstractSocket.NetworkLayerProtocol = QAbstractSocket.AnyIPProtocol)\n"
"connectToHostEncrypted(self, str, int, str, mode: Union[QIODevice.OpenMode, QIODevice.OpenModeFlag] = QIODevice.ReadWrite, protocol: QAbstractSocket.NetworkLayerProtocol = QAbstractSocket.AnyIPProtocol)");

extern "C" {static PyObject *meth_QSslSocket_connectToHostEncrypted(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_connectToHostEncrypted(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::quint16 a1;
         ::QIODevice::OpenMode a2def = QIODevice::ReadWrite;
         ::QIODevice::OpenMode* a2 = &a2def;
        int a2State = 0;
         ::QAbstractSocket::NetworkLayerProtocol a3 = QAbstractSocket::AnyIPProtocol;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            SIP_NULLPTR,
            sipName_mode,
            sipName_protocol,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1t|J1E", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QString,&a0, &a0State, &a1, sipType_QIODevice_OpenMode, &a2, &a2State, sipType_QAbstractSocket_NetworkLayerProtocol, &a3))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->connectToHostEncrypted(*a0,a1,*a2,a3);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(a2,sipType_QIODevice_OpenMode,a2State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;
         ::quint16 a1;
        const  ::QString* a2;
        int a2State = 0;
         ::QIODevice::OpenMode a3def = QIODevice::ReadWrite;
         ::QIODevice::OpenMode* a3 = &a3def;
        int a3State = 0;
         ::QAbstractSocket::NetworkLayerProtocol a4 = QAbstractSocket::AnyIPProtocol;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            SIP_NULLPTR,
            SIP_NULLPTR,
            sipName_mode,
            sipName_protocol,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1tJ1|J1E", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QString,&a0, &a0State, &a1, sipType_QString,&a2, &a2State, sipType_QIODevice_OpenMode, &a3, &a3State, sipType_QAbstractSocket_NetworkLayerProtocol, &a4))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->connectToHostEncrypted(*a0,a1,*a2,*a3,a4);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(a3,sipType_QIODevice_OpenMode,a3State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_connectToHostEncrypted, doc_QSslSocket_connectToHostEncrypted);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setSocketDescriptor, "setSocketDescriptor(self, sip.voidptr, state: QAbstractSocket.SocketState = QAbstractSocket.ConnectedState, mode: Union[QIODevice.OpenMode, QIODevice.OpenModeFlag] = QIODevice.ReadWrite) -> bool");

extern "C" {static PyObject *meth_QSslSocket_setSocketDescriptor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setSocketDescriptor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::qintptr* a0;
        int a0State = 0;
         ::QAbstractSocket::SocketState a1 = QAbstractSocket::ConnectedState;
         ::QIODevice::OpenMode a2def = QIODevice::ReadWrite;
         ::QIODevice::OpenMode* a2 = &a2def;
        int a2State = 0;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_state,
            sipName_mode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|EJ1", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_qintptr,&a0, &a0State, sipType_QAbstractSocket_SocketState, &a1, sipType_QIODevice_OpenMode, &a2, &a2State))
        {
            bool sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::QSslSocket::setSocketDescriptor(*a0,a1,*a2) : sipCpp->setSocketDescriptor(*a0,a1,*a2));
            sipReleaseType(a0,sipType_qintptr,a0State);
            sipReleaseType(a2,sipType_QIODevice_OpenMode,a2State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setSocketDescriptor, doc_QSslSocket_setSocketDescriptor);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_mode, "mode(self) -> QSslSocket.SslMode");

extern "C" {static PyObject *meth_QSslSocket_mode(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_mode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::QSslSocket::SslMode sipRes;

            sipRes = sipCpp->mode();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSslSocket_SslMode);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_mode, doc_QSslSocket_mode);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_isEncrypted, "isEncrypted(self) -> bool");

extern "C" {static PyObject *meth_QSslSocket_isEncrypted(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_isEncrypted(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isEncrypted();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_isEncrypted, doc_QSslSocket_isEncrypted);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_protocol, "protocol(self) -> QSsl.SslProtocol");

extern "C" {static PyObject *meth_QSslSocket_protocol(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_protocol(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::QSsl::SslProtocol sipRes;

            sipRes = sipCpp->protocol();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSsl_SslProtocol);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_protocol, doc_QSslSocket_protocol);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setProtocol, "setProtocol(self, QSsl.SslProtocol)");

extern "C" {static PyObject *meth_QSslSocket_setProtocol(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setProtocol(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSsl::SslProtocol a0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QSsl_SslProtocol, &a0))
        {
            sipCpp->setProtocol(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setProtocol, doc_QSslSocket_setProtocol);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_bytesAvailable, "bytesAvailable(self) -> int");

extern "C" {static PyObject *meth_QSslSocket_bytesAvailable(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_bytesAvailable(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::qint64 sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::QSslSocket::bytesAvailable() : sipCpp->bytesAvailable());

            return PyLong_FromLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_bytesAvailable, doc_QSslSocket_bytesAvailable);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_bytesToWrite, "bytesToWrite(self) -> int");

extern "C" {static PyObject *meth_QSslSocket_bytesToWrite(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_bytesToWrite(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::qint64 sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::QSslSocket::bytesToWrite() : sipCpp->bytesToWrite());

            return PyLong_FromLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_bytesToWrite, doc_QSslSocket_bytesToWrite);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_canReadLine, "canReadLine(self) -> bool");

extern "C" {static PyObject *meth_QSslSocket_canReadLine(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_canReadLine(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            bool sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::QSslSocket::canReadLine() : sipCpp->canReadLine());

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_canReadLine, doc_QSslSocket_canReadLine);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_close, "close(self)");

extern "C" {static PyObject *meth_QSslSocket_close(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_close(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::QSslSocket::close() : sipCpp->close());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_close, doc_QSslSocket_close);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_atEnd, "atEnd(self) -> bool");

extern "C" {static PyObject *meth_QSslSocket_atEnd(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_atEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            bool sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::QSslSocket::atEnd() : sipCpp->atEnd());

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_atEnd, doc_QSslSocket_atEnd);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_flush, "flush(self) -> bool");

extern "C" {static PyObject *meth_QSslSocket_flush(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_flush(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->flush();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_flush, doc_QSslSocket_flush);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_abort, "abort(self)");

extern "C" {static PyObject *meth_QSslSocket_abort(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_abort(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            sipCpp->abort();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_abort, doc_QSslSocket_abort);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setLocalCertificate, "setLocalCertificate(self, QSslCertificate)\n"
"setLocalCertificate(self, str, format: QSsl.EncodingFormat = QSsl.Pem)");

extern "C" {static PyObject *meth_QSslSocket_setLocalCertificate(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setLocalCertificate(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate* a0;
         ::QSslSocket *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "BJ9", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QSslCertificate, &a0))
        {
            sipCpp->setLocalCertificate(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QSsl::EncodingFormat a1 = QSsl::Pem;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_format,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|E", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QString,&a0, &a0State, sipType_QSsl_EncodingFormat, &a1))
        {
            sipCpp->setLocalCertificate(*a0,a1);
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setLocalCertificate, doc_QSslSocket_setLocalCertificate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_localCertificate, "localCertificate(self) -> QSslCertificate");

extern "C" {static PyObject *meth_QSslSocket_localCertificate(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_localCertificate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::QSslCertificate*sipRes;

            sipRes = new  ::QSslCertificate(sipCpp->localCertificate());

            return sipConvertFromNewType(sipRes,sipType_QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_localCertificate, doc_QSslSocket_localCertificate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_peerCertificate, "peerCertificate(self) -> QSslCertificate");

extern "C" {static PyObject *meth_QSslSocket_peerCertificate(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_peerCertificate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::QSslCertificate*sipRes;

            sipRes = new  ::QSslCertificate(sipCpp->peerCertificate());

            return sipConvertFromNewType(sipRes,sipType_QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_peerCertificate, doc_QSslSocket_peerCertificate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_peerCertificateChain, "peerCertificateChain(self) -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslSocket_peerCertificateChain(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_peerCertificateChain(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>(sipCpp->peerCertificateChain());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_peerCertificateChain, doc_QSslSocket_peerCertificateChain);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_sessionCipher, "sessionCipher(self) -> QSslCipher");

extern "C" {static PyObject *meth_QSslSocket_sessionCipher(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_sessionCipher(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::QSslCipher*sipRes;

            sipRes = new  ::QSslCipher(sipCpp->sessionCipher());

            return sipConvertFromNewType(sipRes,sipType_QSslCipher,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_sessionCipher, doc_QSslSocket_sessionCipher);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setPrivateKey, "setPrivateKey(self, QSslKey)\n"
"setPrivateKey(self, str, algorithm: QSsl.KeyAlgorithm = QSsl.Rsa, format: QSsl.EncodingFormat = QSsl.Pem, passPhrase: Union[QByteArray, bytes, bytearray] = QByteArray())");

extern "C" {static PyObject *meth_QSslSocket_setPrivateKey(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setPrivateKey(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslKey* a0;
         ::QSslSocket *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "BJ9", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QSslKey, &a0))
        {
            sipCpp->setPrivateKey(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QSsl::KeyAlgorithm a1 = QSsl::Rsa;
         ::QSsl::EncodingFormat a2 = QSsl::Pem;
        const  ::QByteArray& a3def = QByteArray();
        const  ::QByteArray* a3 = &a3def;
        int a3State = 0;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_algorithm,
            sipName_format,
            sipName_passPhrase,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|EEJ1", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QString,&a0, &a0State, sipType_QSsl_KeyAlgorithm, &a1, sipType_QSsl_EncodingFormat, &a2, sipType_QByteArray, &a3, &a3State))
        {
            sipCpp->setPrivateKey(*a0,a1,a2,*a3);
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QByteArray *>(a3),sipType_QByteArray,a3State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setPrivateKey, doc_QSslSocket_setPrivateKey);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_privateKey, "privateKey(self) -> QSslKey");

extern "C" {static PyObject *meth_QSslSocket_privateKey(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_privateKey(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::QSslKey*sipRes;

            sipRes = new  ::QSslKey(sipCpp->privateKey());

            return sipConvertFromNewType(sipRes,sipType_QSslKey,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_privateKey, doc_QSslSocket_privateKey);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_ciphers, "ciphers(self) -> List[QSslCipher]");

extern "C" {static PyObject *meth_QSslSocket_ciphers(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_ciphers(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            QList< ::QSslCipher>*sipRes;

            sipRes = new QList< ::QSslCipher>(sipCpp->ciphers());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCipher,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_ciphers, doc_QSslSocket_ciphers);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setCiphers, "setCiphers(self, Iterable[QSslCipher])\n"
"setCiphers(self, str)");

extern "C" {static PyObject *meth_QSslSocket_setCiphers(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setCiphers(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const QList< ::QSslCipher>* a0;
        int a0State = 0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QList_0100QSslCipher,&a0, &a0State))
        {
            sipCpp->setCiphers(*a0);
            sipReleaseType(const_cast<QList< ::QSslCipher> *>(a0),sipType_QList_0100QSslCipher,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QString,&a0, &a0State))
        {
            sipCpp->setCiphers(*a0);
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setCiphers, doc_QSslSocket_setCiphers);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setDefaultCiphers, "setDefaultCiphers(Iterable[QSslCipher])");

extern "C" {static PyObject *meth_QSslSocket_setDefaultCiphers(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setDefaultCiphers(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const QList< ::QSslCipher>* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_QList_0100QSslCipher,&a0, &a0State))
        {
             ::QSslSocket::setDefaultCiphers(*a0);
            sipReleaseType(const_cast<QList< ::QSslCipher> *>(a0),sipType_QList_0100QSslCipher,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setDefaultCiphers, doc_QSslSocket_setDefaultCiphers);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_defaultCiphers, "defaultCiphers() -> List[QSslCipher]");

extern "C" {static PyObject *meth_QSslSocket_defaultCiphers(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_defaultCiphers(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            QList< ::QSslCipher>*sipRes;

            sipRes = new QList< ::QSslCipher>( ::QSslSocket::defaultCiphers());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCipher,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_defaultCiphers, doc_QSslSocket_defaultCiphers);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_supportedCiphers, "supportedCiphers() -> List[QSslCipher]");

extern "C" {static PyObject *meth_QSslSocket_supportedCiphers(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_supportedCiphers(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            QList< ::QSslCipher>*sipRes;

            sipRes = new QList< ::QSslCipher>( ::QSslSocket::supportedCiphers());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCipher,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_supportedCiphers, doc_QSslSocket_supportedCiphers);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_addCaCertificates, "addCaCertificates(self, str, format: QSsl.EncodingFormat = QSsl.Pem, syntax: QRegExp.PatternSyntax = QRegExp.FixedString) -> bool\n"
"addCaCertificates(self, Iterable[QSslCertificate])");

extern "C" {static PyObject *meth_QSslSocket_addCaCertificates(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_addCaCertificates(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QSsl::EncodingFormat a1 = QSsl::Pem;
         ::QRegExp::PatternSyntax a2 = QRegExp::FixedString;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_format,
            sipName_syntax,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|EE", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QString,&a0, &a0State, sipType_QSsl_EncodingFormat, &a1, sipType_QRegExp_PatternSyntax, &a2))
        {
            bool sipRes;

            sipRes = sipCpp->addCaCertificates(*a0,a1,a2);
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const QList< ::QSslCertificate>* a0;
        int a0State = 0;
         ::QSslSocket *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "BJ1", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QList_0100QSslCertificate,&a0, &a0State))
        {
            sipCpp->addCaCertificates(*a0);
            sipReleaseType(const_cast<QList< ::QSslCertificate> *>(a0),sipType_QList_0100QSslCertificate,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_addCaCertificates, doc_QSslSocket_addCaCertificates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_addCaCertificate, "addCaCertificate(self, QSslCertificate)");

extern "C" {static PyObject *meth_QSslSocket_addCaCertificate(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_addCaCertificate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate* a0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QSslCertificate, &a0))
        {
            sipCpp->addCaCertificate(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_addCaCertificate, doc_QSslSocket_addCaCertificate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setCaCertificates, "setCaCertificates(self, Iterable[QSslCertificate])");

extern "C" {static PyObject *meth_QSslSocket_setCaCertificates(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setCaCertificates(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const QList< ::QSslCertificate>* a0;
        int a0State = 0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QList_0100QSslCertificate,&a0, &a0State))
        {
            sipCpp->setCaCertificates(*a0);
            sipReleaseType(const_cast<QList< ::QSslCertificate> *>(a0),sipType_QList_0100QSslCertificate,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setCaCertificates, doc_QSslSocket_setCaCertificates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_caCertificates, "caCertificates(self) -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslSocket_caCertificates(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_caCertificates(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>(sipCpp->caCertificates());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_caCertificates, doc_QSslSocket_caCertificates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_addDefaultCaCertificates, "addDefaultCaCertificates(str, format: QSsl.EncodingFormat = QSsl.Pem, syntax: QRegExp.PatternSyntax = QRegExp.FixedString) -> bool\n"
"addDefaultCaCertificates(Iterable[QSslCertificate])");

extern "C" {static PyObject *meth_QSslSocket_addDefaultCaCertificates(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_addDefaultCaCertificates(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QSsl::EncodingFormat a1 = QSsl::Pem;
         ::QRegExp::PatternSyntax a2 = QRegExp::FixedString;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_format,
            sipName_syntax,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1|EE", sipType_QString,&a0, &a0State, sipType_QSsl_EncodingFormat, &a1, sipType_QRegExp_PatternSyntax, &a2))
        {
            bool sipRes;

            sipRes =  ::QSslSocket::addDefaultCaCertificates(*a0,a1,a2);
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const QList< ::QSslCertificate>* a0;
        int a0State = 0;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "J1", sipType_QList_0100QSslCertificate,&a0, &a0State))
        {
             ::QSslSocket::addDefaultCaCertificates(*a0);
            sipReleaseType(const_cast<QList< ::QSslCertificate> *>(a0),sipType_QList_0100QSslCertificate,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_addDefaultCaCertificates, doc_QSslSocket_addDefaultCaCertificates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_addDefaultCaCertificate, "addDefaultCaCertificate(QSslCertificate)");

extern "C" {static PyObject *meth_QSslSocket_addDefaultCaCertificate(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_addDefaultCaCertificate(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate* a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_QSslCertificate, &a0))
        {
             ::QSslSocket::addDefaultCaCertificate(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_addDefaultCaCertificate, doc_QSslSocket_addDefaultCaCertificate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setDefaultCaCertificates, "setDefaultCaCertificates(Iterable[QSslCertificate])");

extern "C" {static PyObject *meth_QSslSocket_setDefaultCaCertificates(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setDefaultCaCertificates(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const QList< ::QSslCertificate>* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_QList_0100QSslCertificate,&a0, &a0State))
        {
             ::QSslSocket::setDefaultCaCertificates(*a0);
            sipReleaseType(const_cast<QList< ::QSslCertificate> *>(a0),sipType_QList_0100QSslCertificate,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setDefaultCaCertificates, doc_QSslSocket_setDefaultCaCertificates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_defaultCaCertificates, "defaultCaCertificates() -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslSocket_defaultCaCertificates(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_defaultCaCertificates(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>( ::QSslSocket::defaultCaCertificates());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_defaultCaCertificates, doc_QSslSocket_defaultCaCertificates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_systemCaCertificates, "systemCaCertificates() -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslSocket_systemCaCertificates(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_systemCaCertificates(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>( ::QSslSocket::systemCaCertificates());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_systemCaCertificates, doc_QSslSocket_systemCaCertificates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_waitForConnected, "waitForConnected(self, msecs: int = 30000) -> bool");

extern "C" {static PyObject *meth_QSslSocket_waitForConnected(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_waitForConnected(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int a0 = 30000;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            sipName_msecs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_QSslSocket, &sipCpp, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::QSslSocket::waitForConnected(a0) : sipCpp->waitForConnected(a0));
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_waitForConnected, doc_QSslSocket_waitForConnected);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_waitForEncrypted, "waitForEncrypted(self, msecs: int = 30000) -> bool");

extern "C" {static PyObject *meth_QSslSocket_waitForEncrypted(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_waitForEncrypted(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0 = 30000;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            sipName_msecs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_QSslSocket, &sipCpp, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->waitForEncrypted(a0);
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_waitForEncrypted, doc_QSslSocket_waitForEncrypted);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_waitForReadyRead, "waitForReadyRead(self, msecs: int = 30000) -> bool");

extern "C" {static PyObject *meth_QSslSocket_waitForReadyRead(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_waitForReadyRead(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int a0 = 30000;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            sipName_msecs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_QSslSocket, &sipCpp, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::QSslSocket::waitForReadyRead(a0) : sipCpp->waitForReadyRead(a0));
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_waitForReadyRead, doc_QSslSocket_waitForReadyRead);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_waitForBytesWritten, "waitForBytesWritten(self, msecs: int = 30000) -> bool");

extern "C" {static PyObject *meth_QSslSocket_waitForBytesWritten(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_waitForBytesWritten(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int a0 = 30000;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            sipName_msecs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_QSslSocket, &sipCpp, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::QSslSocket::waitForBytesWritten(a0) : sipCpp->waitForBytesWritten(a0));
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_waitForBytesWritten, doc_QSslSocket_waitForBytesWritten);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_waitForDisconnected, "waitForDisconnected(self, msecs: int = 30000) -> bool");

extern "C" {static PyObject *meth_QSslSocket_waitForDisconnected(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_waitForDisconnected(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int a0 = 30000;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            sipName_msecs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_QSslSocket, &sipCpp, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::QSslSocket::waitForDisconnected(a0) : sipCpp->waitForDisconnected(a0));
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_waitForDisconnected, doc_QSslSocket_waitForDisconnected);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_sslErrors, "sslErrors(self) -> List[QSslError]");

extern "C" {static PyObject *meth_QSslSocket_sslErrors(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_sslErrors(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            QList< ::QSslError>*sipRes;

            sipRes = new QList< ::QSslError>(sipCpp->sslErrors());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslError,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_sslErrors, doc_QSslSocket_sslErrors);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_supportsSsl, "supportsSsl() -> bool");

extern "C" {static PyObject *meth_QSslSocket_supportsSsl(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_supportsSsl(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            bool sipRes;

            sipRes =  ::QSslSocket::supportsSsl();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_supportsSsl, doc_QSslSocket_supportsSsl);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_startClientEncryption, "startClientEncryption(self)");

extern "C" {static PyObject *meth_QSslSocket_startClientEncryption(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_startClientEncryption(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            sipCpp->startClientEncryption();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_startClientEncryption, doc_QSslSocket_startClientEncryption);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_startServerEncryption, "startServerEncryption(self)");

extern "C" {static PyObject *meth_QSslSocket_startServerEncryption(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_startServerEncryption(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            sipCpp->startServerEncryption();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_startServerEncryption, doc_QSslSocket_startServerEncryption);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_ignoreSslErrors, "ignoreSslErrors(self)\n"
"ignoreSslErrors(self, Iterable[QSslError])");

extern "C" {static PyObject *meth_QSslSocket_ignoreSslErrors(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_ignoreSslErrors(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            sipCpp->ignoreSslErrors();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const QList< ::QSslError>* a0;
        int a0State = 0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QList_0100QSslError,&a0, &a0State))
        {
            sipCpp->ignoreSslErrors(*a0);
            sipReleaseType(const_cast<QList< ::QSslError> *>(a0),sipType_QList_0100QSslError,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_ignoreSslErrors, doc_QSslSocket_ignoreSslErrors);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_readData, "readData(self, int) -> bytes");

extern "C" {static PyObject *meth_QSslSocket_readData(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_readData(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::qint64 a0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pn", &sipSelf, sipType_QSslSocket, &sipCpp, &a0))
        {
            PyObject * sipRes = SIP_NULLPTR;
            int sipIsErr = 0;

#line 105 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslsocket.sip"
        // Return the data read or None if there was an error.
        if (a0 < 0)
        {
            PyErr_SetString(PyExc_ValueError, "maximum length of data to be read cannot be negative");
            sipIsErr = 1;
        }
        else
        {
            char *s = new char[a0];
            qint64 len;
        
            Py_BEGIN_ALLOW_THREADS
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            len = sipSelfWasArg ? sipCpp->QSslSocket::readData(s, a0) : sipCpp->readData(s, a0);
        #else
            len = sipCpp->sipProtectVirt_readData(sipSelfWasArg, s, a0);
        #endif
            Py_END_ALLOW_THREADS
        
            if (len < 0)
            {
                Py_INCREF(Py_None);
                sipRes = Py_None;
            }
            else
            {
                sipRes = SIPBytes_FromStringAndSize(s, len);
        
                if (!sipRes)
                    sipIsErr = 1;
            }
        
            delete[] s;
        }
#line 11236 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_readData, doc_QSslSocket_readData);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_writeData, "writeData(self, bytes) -> int");

extern "C" {static PyObject *meth_QSslSocket_writeData(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_writeData(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const char* a0;
        SIP_SSIZE_T a1;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pk", &sipSelf, sipType_QSslSocket, &sipCpp, &a0, &a1))
        {
             ::qint64 sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::QSslSocket::writeData(a0,(PY_LONG_LONG)a1) : sipCpp->writeData(a0,(PY_LONG_LONG)a1));
            Py_END_ALLOW_THREADS

            return PyLong_FromLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_writeData, doc_QSslSocket_writeData);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_peerVerifyMode, "peerVerifyMode(self) -> QSslSocket.PeerVerifyMode");

extern "C" {static PyObject *meth_QSslSocket_peerVerifyMode(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_peerVerifyMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::QSslSocket::PeerVerifyMode sipRes;

            sipRes = sipCpp->peerVerifyMode();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSslSocket_PeerVerifyMode);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_peerVerifyMode, doc_QSslSocket_peerVerifyMode);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setPeerVerifyMode, "setPeerVerifyMode(self, QSslSocket.PeerVerifyMode)");

extern "C" {static PyObject *meth_QSslSocket_setPeerVerifyMode(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setPeerVerifyMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslSocket::PeerVerifyMode a0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QSslSocket_PeerVerifyMode, &a0))
        {
            sipCpp->setPeerVerifyMode(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setPeerVerifyMode, doc_QSslSocket_setPeerVerifyMode);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_peerVerifyDepth, "peerVerifyDepth(self) -> int");

extern "C" {static PyObject *meth_QSslSocket_peerVerifyDepth(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_peerVerifyDepth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->peerVerifyDepth();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_peerVerifyDepth, doc_QSslSocket_peerVerifyDepth);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setPeerVerifyDepth, "setPeerVerifyDepth(self, int)");

extern "C" {static PyObject *meth_QSslSocket_setPeerVerifyDepth(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setPeerVerifyDepth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QSslSocket, &sipCpp, &a0))
        {
            sipCpp->setPeerVerifyDepth(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setPeerVerifyDepth, doc_QSslSocket_setPeerVerifyDepth);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setReadBufferSize, "setReadBufferSize(self, int)");

extern "C" {static PyObject *meth_QSslSocket_setReadBufferSize(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setReadBufferSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::qint64 a0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bn", &sipSelf, sipType_QSslSocket, &sipCpp, &a0))
        {
            (sipSelfWasArg ? sipCpp-> ::QSslSocket::setReadBufferSize(a0) : sipCpp->setReadBufferSize(a0));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setReadBufferSize, doc_QSslSocket_setReadBufferSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_encryptedBytesAvailable, "encryptedBytesAvailable(self) -> int");

extern "C" {static PyObject *meth_QSslSocket_encryptedBytesAvailable(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_encryptedBytesAvailable(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::qint64 sipRes;

            sipRes = sipCpp->encryptedBytesAvailable();

            return PyLong_FromLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_encryptedBytesAvailable, doc_QSslSocket_encryptedBytesAvailable);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_encryptedBytesToWrite, "encryptedBytesToWrite(self) -> int");

extern "C" {static PyObject *meth_QSslSocket_encryptedBytesToWrite(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_encryptedBytesToWrite(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::qint64 sipRes;

            sipRes = sipCpp->encryptedBytesToWrite();

            return PyLong_FromLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_encryptedBytesToWrite, doc_QSslSocket_encryptedBytesToWrite);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_sslConfiguration, "sslConfiguration(self) -> QSslConfiguration");

extern "C" {static PyObject *meth_QSslSocket_sslConfiguration(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_sslConfiguration(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::QSslConfiguration*sipRes;

            sipRes = new  ::QSslConfiguration(sipCpp->sslConfiguration());

            return sipConvertFromNewType(sipRes,sipType_QSslConfiguration,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_sslConfiguration, doc_QSslSocket_sslConfiguration);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setSslConfiguration, "setSslConfiguration(self, QSslConfiguration)");

extern "C" {static PyObject *meth_QSslSocket_setSslConfiguration(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setSslConfiguration(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration* a0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QSslConfiguration, &a0))
        {
            sipCpp->setSslConfiguration(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setSslConfiguration, doc_QSslSocket_setSslConfiguration);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setSocketOption, "setSocketOption(self, QAbstractSocket.SocketOption, Any)");

extern "C" {static PyObject *meth_QSslSocket_setSocketOption(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setSocketOption(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QAbstractSocket::SocketOption a0;
        const  ::QVariant* a1;
        int a1State = 0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BEJ1", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QAbstractSocket_SocketOption, &a0, sipType_QVariant, &a1, &a1State))
        {
            (sipSelfWasArg ? sipCpp-> ::QSslSocket::setSocketOption(a0,*a1) : sipCpp->setSocketOption(a0,*a1));
            sipReleaseType(const_cast< ::QVariant *>(a1),sipType_QVariant,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setSocketOption, doc_QSslSocket_setSocketOption);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_socketOption, "socketOption(self, QAbstractSocket.SocketOption) -> Any");

extern "C" {static PyObject *meth_QSslSocket_socketOption(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_socketOption(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QAbstractSocket::SocketOption a0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QAbstractSocket_SocketOption, &a0))
        {
             ::QVariant*sipRes;

            sipRes = new  ::QVariant((sipSelfWasArg ? sipCpp-> ::QSslSocket::socketOption(a0) : sipCpp->socketOption(a0)));

            return sipConvertFromNewType(sipRes,sipType_QVariant,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_socketOption, doc_QSslSocket_socketOption);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_peerVerifyName, "peerVerifyName(self) -> str");

extern "C" {static PyObject *meth_QSslSocket_peerVerifyName(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_peerVerifyName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->peerVerifyName());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_peerVerifyName, doc_QSslSocket_peerVerifyName);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setPeerVerifyName, "setPeerVerifyName(self, str)");

extern "C" {static PyObject *meth_QSslSocket_setPeerVerifyName(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setPeerVerifyName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QString,&a0, &a0State))
        {
            sipCpp->setPeerVerifyName(*a0);
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setPeerVerifyName, doc_QSslSocket_setPeerVerifyName);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_resume, "resume(self)");

extern "C" {static PyObject *meth_QSslSocket_resume(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_resume(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::QSslSocket::resume() : sipCpp->resume());
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_resume, doc_QSslSocket_resume);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_connectToHost, "connectToHost(self, str, int, mode: Union[QIODevice.OpenMode, QIODevice.OpenModeFlag] = QIODevice.ReadWrite, protocol: QAbstractSocket.NetworkLayerProtocol = QAbstractSocket.AnyIPProtocol)");

extern "C" {static PyObject *meth_QSslSocket_connectToHost(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_connectToHost(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QString* a0;
        int a0State = 0;
         ::quint16 a1;
         ::QIODevice::OpenMode a2def = QIODevice::ReadWrite;
         ::QIODevice::OpenMode* a2 = &a2def;
        int a2State = 0;
         ::QAbstractSocket::NetworkLayerProtocol a3 = QAbstractSocket::AnyIPProtocol;
         ::QSslSocket *sipCpp;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            SIP_NULLPTR,
            sipName_mode,
            sipName_protocol,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1t|J1E", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QString,&a0, &a0State, &a1, sipType_QIODevice_OpenMode, &a2, &a2State, sipType_QAbstractSocket_NetworkLayerProtocol, &a3))
        {
            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::QSslSocket::connectToHost(*a0,a1,*a2,a3) : sipCpp->connectToHost(*a0,a1,*a2,a3));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(a2,sipType_QIODevice_OpenMode,a2State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_connectToHost, doc_QSslSocket_connectToHost);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_disconnectFromHost, "disconnectFromHost(self)");

extern "C" {static PyObject *meth_QSslSocket_disconnectFromHost(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_disconnectFromHost(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::QSslSocket::disconnectFromHost() : sipCpp->disconnectFromHost());
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_disconnectFromHost, doc_QSslSocket_disconnectFromHost);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_sslLibraryVersionNumber, "sslLibraryVersionNumber() -> int");

extern "C" {static PyObject *meth_QSslSocket_sslLibraryVersionNumber(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_sslLibraryVersionNumber(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            long sipRes;

            sipRes =  ::QSslSocket::sslLibraryVersionNumber();

            return PyLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_sslLibraryVersionNumber, doc_QSslSocket_sslLibraryVersionNumber);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_sslLibraryVersionString, "sslLibraryVersionString() -> str");

extern "C" {static PyObject *meth_QSslSocket_sslLibraryVersionString(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_sslLibraryVersionString(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::QString*sipRes;

            sipRes = new  ::QString( ::QSslSocket::sslLibraryVersionString());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_sslLibraryVersionString, doc_QSslSocket_sslLibraryVersionString);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_setLocalCertificateChain, "setLocalCertificateChain(self, Iterable[QSslCertificate])");

extern "C" {static PyObject *meth_QSslSocket_setLocalCertificateChain(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_setLocalCertificateChain(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const QList< ::QSslCertificate>* a0;
        int a0State = 0;
         ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslSocket, &sipCpp, sipType_QList_0100QSslCertificate,&a0, &a0State))
        {
            sipCpp->setLocalCertificateChain(*a0);
            sipReleaseType(const_cast<QList< ::QSslCertificate> *>(a0),sipType_QList_0100QSslCertificate,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_setLocalCertificateChain, doc_QSslSocket_setLocalCertificateChain);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_localCertificateChain, "localCertificateChain(self) -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslSocket_localCertificateChain(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_localCertificateChain(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>(sipCpp->localCertificateChain());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_localCertificateChain, doc_QSslSocket_localCertificateChain);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_sessionProtocol, "sessionProtocol(self) -> QSsl.SslProtocol");

extern "C" {static PyObject *meth_QSslSocket_sessionProtocol(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_sessionProtocol(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslSocket *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslSocket, &sipCpp))
        {
             ::QSsl::SslProtocol sipRes;

            sipRes = sipCpp->sessionProtocol();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSsl_SslProtocol);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_sessionProtocol, doc_QSslSocket_sessionProtocol);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_sslLibraryBuildVersionNumber, "sslLibraryBuildVersionNumber() -> int");

extern "C" {static PyObject *meth_QSslSocket_sslLibraryBuildVersionNumber(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_sslLibraryBuildVersionNumber(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            long sipRes;

            sipRes =  ::QSslSocket::sslLibraryBuildVersionNumber();

            return PyLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_sslLibraryBuildVersionNumber, doc_QSslSocket_sslLibraryBuildVersionNumber);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslSocket_sslLibraryBuildVersionString, "sslLibraryBuildVersionString() -> str");

extern "C" {static PyObject *meth_QSslSocket_sslLibraryBuildVersionString(PyObject *, PyObject *);}
static PyObject *meth_QSslSocket_sslLibraryBuildVersionString(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::QString*sipRes;

            sipRes = new  ::QString( ::QSslSocket::sslLibraryBuildVersionString());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslSocket, sipName_sslLibraryBuildVersionString, doc_QSslSocket_sslLibraryBuildVersionString);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QSslSocket(void *, const sipTypeDef *);}
static void *cast_QSslSocket(void *sipCppV, const sipTypeDef *targetType)
{
     ::QSslSocket *sipCpp = reinterpret_cast< ::QSslSocket *>(sipCppV);

    if (targetType == sipType_QTcpSocket)
        return static_cast< ::QTcpSocket *>(sipCpp);

    if (targetType == sipType_QAbstractSocket)
        return static_cast< ::QAbstractSocket *>(sipCpp);

    if (targetType == sipType_QIODevice)
        return static_cast< ::QIODevice *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QSslSocket(void *, int);}
static void release_QSslSocket(void *sipCppV, int)
{
     ::QSslSocket *sipCpp = reinterpret_cast< ::QSslSocket *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QSslSocket(sipSimpleWrapper *);}
static void dealloc_QSslSocket(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQSslSocket *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSslSocket(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QSslSocket(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSslSocket(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQSslSocket *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQSslSocket(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QSslSocket[] = {{129, 255, 1}};


static PyMethodDef methods_QSslSocket[] = {
    {SIP_MLNAME_CAST(sipName_abort), meth_QSslSocket_abort, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_abort)},
    {SIP_MLNAME_CAST(sipName_addCaCertificate), meth_QSslSocket_addCaCertificate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_addCaCertificate)},
    {SIP_MLNAME_CAST(sipName_addCaCertificates), SIP_MLMETH_CAST(meth_QSslSocket_addCaCertificates), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_addCaCertificates)},
    {SIP_MLNAME_CAST(sipName_addDefaultCaCertificate), meth_QSslSocket_addDefaultCaCertificate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_addDefaultCaCertificate)},
    {SIP_MLNAME_CAST(sipName_addDefaultCaCertificates), SIP_MLMETH_CAST(meth_QSslSocket_addDefaultCaCertificates), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_addDefaultCaCertificates)},
    {SIP_MLNAME_CAST(sipName_atEnd), meth_QSslSocket_atEnd, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_atEnd)},
    {SIP_MLNAME_CAST(sipName_bytesAvailable), meth_QSslSocket_bytesAvailable, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_bytesAvailable)},
    {SIP_MLNAME_CAST(sipName_bytesToWrite), meth_QSslSocket_bytesToWrite, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_bytesToWrite)},
    {SIP_MLNAME_CAST(sipName_caCertificates), meth_QSslSocket_caCertificates, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_caCertificates)},
    {SIP_MLNAME_CAST(sipName_canReadLine), meth_QSslSocket_canReadLine, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_canReadLine)},
    {SIP_MLNAME_CAST(sipName_ciphers), meth_QSslSocket_ciphers, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_ciphers)},
    {SIP_MLNAME_CAST(sipName_close), meth_QSslSocket_close, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_close)},
    {SIP_MLNAME_CAST(sipName_connectToHost), SIP_MLMETH_CAST(meth_QSslSocket_connectToHost), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_connectToHost)},
    {SIP_MLNAME_CAST(sipName_connectToHostEncrypted), SIP_MLMETH_CAST(meth_QSslSocket_connectToHostEncrypted), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_connectToHostEncrypted)},
    {SIP_MLNAME_CAST(sipName_defaultCaCertificates), meth_QSslSocket_defaultCaCertificates, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_defaultCaCertificates)},
    {SIP_MLNAME_CAST(sipName_defaultCiphers), meth_QSslSocket_defaultCiphers, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_defaultCiphers)},
    {SIP_MLNAME_CAST(sipName_disconnectFromHost), meth_QSslSocket_disconnectFromHost, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_disconnectFromHost)},
    {SIP_MLNAME_CAST(sipName_encryptedBytesAvailable), meth_QSslSocket_encryptedBytesAvailable, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_encryptedBytesAvailable)},
    {SIP_MLNAME_CAST(sipName_encryptedBytesToWrite), meth_QSslSocket_encryptedBytesToWrite, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_encryptedBytesToWrite)},
    {SIP_MLNAME_CAST(sipName_flush), meth_QSslSocket_flush, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_flush)},
    {SIP_MLNAME_CAST(sipName_ignoreSslErrors), meth_QSslSocket_ignoreSslErrors, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_ignoreSslErrors)},
    {SIP_MLNAME_CAST(sipName_isEncrypted), meth_QSslSocket_isEncrypted, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_isEncrypted)},
    {SIP_MLNAME_CAST(sipName_localCertificate), meth_QSslSocket_localCertificate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_localCertificate)},
    {SIP_MLNAME_CAST(sipName_localCertificateChain), meth_QSslSocket_localCertificateChain, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_localCertificateChain)},
    {SIP_MLNAME_CAST(sipName_mode), meth_QSslSocket_mode, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_mode)},
    {SIP_MLNAME_CAST(sipName_peerCertificate), meth_QSslSocket_peerCertificate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_peerCertificate)},
    {SIP_MLNAME_CAST(sipName_peerCertificateChain), meth_QSslSocket_peerCertificateChain, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_peerCertificateChain)},
    {SIP_MLNAME_CAST(sipName_peerVerifyDepth), meth_QSslSocket_peerVerifyDepth, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_peerVerifyDepth)},
    {SIP_MLNAME_CAST(sipName_peerVerifyMode), meth_QSslSocket_peerVerifyMode, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_peerVerifyMode)},
    {SIP_MLNAME_CAST(sipName_peerVerifyName), meth_QSslSocket_peerVerifyName, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_peerVerifyName)},
    {SIP_MLNAME_CAST(sipName_privateKey), meth_QSslSocket_privateKey, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_privateKey)},
    {SIP_MLNAME_CAST(sipName_protocol), meth_QSslSocket_protocol, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_protocol)},
    {SIP_MLNAME_CAST(sipName_readData), meth_QSslSocket_readData, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_readData)},
    {SIP_MLNAME_CAST(sipName_resume), meth_QSslSocket_resume, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_resume)},
    {SIP_MLNAME_CAST(sipName_sessionCipher), meth_QSslSocket_sessionCipher, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_sessionCipher)},
    {SIP_MLNAME_CAST(sipName_sessionProtocol), meth_QSslSocket_sessionProtocol, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_sessionProtocol)},
    {SIP_MLNAME_CAST(sipName_setCaCertificates), meth_QSslSocket_setCaCertificates, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setCaCertificates)},
    {SIP_MLNAME_CAST(sipName_setCiphers), meth_QSslSocket_setCiphers, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setCiphers)},
    {SIP_MLNAME_CAST(sipName_setDefaultCaCertificates), meth_QSslSocket_setDefaultCaCertificates, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setDefaultCaCertificates)},
    {SIP_MLNAME_CAST(sipName_setDefaultCiphers), meth_QSslSocket_setDefaultCiphers, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setDefaultCiphers)},
    {SIP_MLNAME_CAST(sipName_setLocalCertificate), SIP_MLMETH_CAST(meth_QSslSocket_setLocalCertificate), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_setLocalCertificate)},
    {SIP_MLNAME_CAST(sipName_setLocalCertificateChain), meth_QSslSocket_setLocalCertificateChain, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setLocalCertificateChain)},
    {SIP_MLNAME_CAST(sipName_setPeerVerifyDepth), meth_QSslSocket_setPeerVerifyDepth, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setPeerVerifyDepth)},
    {SIP_MLNAME_CAST(sipName_setPeerVerifyMode), meth_QSslSocket_setPeerVerifyMode, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setPeerVerifyMode)},
    {SIP_MLNAME_CAST(sipName_setPeerVerifyName), meth_QSslSocket_setPeerVerifyName, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setPeerVerifyName)},
    {SIP_MLNAME_CAST(sipName_setPrivateKey), SIP_MLMETH_CAST(meth_QSslSocket_setPrivateKey), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_setPrivateKey)},
    {SIP_MLNAME_CAST(sipName_setProtocol), meth_QSslSocket_setProtocol, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setProtocol)},
    {SIP_MLNAME_CAST(sipName_setReadBufferSize), meth_QSslSocket_setReadBufferSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setReadBufferSize)},
    {SIP_MLNAME_CAST(sipName_setSocketDescriptor), SIP_MLMETH_CAST(meth_QSslSocket_setSocketDescriptor), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_setSocketDescriptor)},
    {SIP_MLNAME_CAST(sipName_setSocketOption), meth_QSslSocket_setSocketOption, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setSocketOption)},
    {SIP_MLNAME_CAST(sipName_setSslConfiguration), meth_QSslSocket_setSslConfiguration, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_setSslConfiguration)},
    {SIP_MLNAME_CAST(sipName_socketOption), meth_QSslSocket_socketOption, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_socketOption)},
    {SIP_MLNAME_CAST(sipName_sslConfiguration), meth_QSslSocket_sslConfiguration, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_sslConfiguration)},
    {SIP_MLNAME_CAST(sipName_sslErrors), meth_QSslSocket_sslErrors, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_sslErrors)},
    {SIP_MLNAME_CAST(sipName_sslLibraryBuildVersionNumber), meth_QSslSocket_sslLibraryBuildVersionNumber, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_sslLibraryBuildVersionNumber)},
    {SIP_MLNAME_CAST(sipName_sslLibraryBuildVersionString), meth_QSslSocket_sslLibraryBuildVersionString, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_sslLibraryBuildVersionString)},
    {SIP_MLNAME_CAST(sipName_sslLibraryVersionNumber), meth_QSslSocket_sslLibraryVersionNumber, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_sslLibraryVersionNumber)},
    {SIP_MLNAME_CAST(sipName_sslLibraryVersionString), meth_QSslSocket_sslLibraryVersionString, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_sslLibraryVersionString)},
    {SIP_MLNAME_CAST(sipName_startClientEncryption), meth_QSslSocket_startClientEncryption, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_startClientEncryption)},
    {SIP_MLNAME_CAST(sipName_startServerEncryption), meth_QSslSocket_startServerEncryption, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_startServerEncryption)},
    {SIP_MLNAME_CAST(sipName_supportedCiphers), meth_QSslSocket_supportedCiphers, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_supportedCiphers)},
    {SIP_MLNAME_CAST(sipName_supportsSsl), meth_QSslSocket_supportsSsl, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_supportsSsl)},
    {SIP_MLNAME_CAST(sipName_systemCaCertificates), meth_QSslSocket_systemCaCertificates, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_systemCaCertificates)},
    {SIP_MLNAME_CAST(sipName_waitForBytesWritten), SIP_MLMETH_CAST(meth_QSslSocket_waitForBytesWritten), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_waitForBytesWritten)},
    {SIP_MLNAME_CAST(sipName_waitForConnected), SIP_MLMETH_CAST(meth_QSslSocket_waitForConnected), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_waitForConnected)},
    {SIP_MLNAME_CAST(sipName_waitForDisconnected), SIP_MLMETH_CAST(meth_QSslSocket_waitForDisconnected), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_waitForDisconnected)},
    {SIP_MLNAME_CAST(sipName_waitForEncrypted), SIP_MLMETH_CAST(meth_QSslSocket_waitForEncrypted), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_waitForEncrypted)},
    {SIP_MLNAME_CAST(sipName_waitForReadyRead), SIP_MLMETH_CAST(meth_QSslSocket_waitForReadyRead), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslSocket_waitForReadyRead)},
    {SIP_MLNAME_CAST(sipName_writeData), meth_QSslSocket_writeData, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslSocket_writeData)}
};

static sipEnumMemberDef enummembers_QSslSocket[] = {
    {sipName_AutoVerifyPeer, static_cast<int>( ::QSslSocket::AutoVerifyPeer), 126},
    {sipName_QueryPeer, static_cast<int>( ::QSslSocket::QueryPeer), 126},
    {sipName_SslClientMode, static_cast<int>( ::QSslSocket::SslClientMode), 127},
    {sipName_SslServerMode, static_cast<int>( ::QSslSocket::SslServerMode), 127},
    {sipName_UnencryptedMode, static_cast<int>( ::QSslSocket::UnencryptedMode), 127},
    {sipName_VerifyNone, static_cast<int>( ::QSslSocket::VerifyNone), 126},
    {sipName_VerifyPeer, static_cast<int>( ::QSslSocket::VerifyPeer), 126},
};

PyDoc_STRVAR(doc_QSslSocket, "\1QSslSocket(parent: QObject = None)");


/* Define this type's signals. */
static const pyqt5QtSignal signals_QSslSocket[] = {
    {"encryptedBytesWritten(qint64)", "\1encryptedBytesWritten(self, int)", SIP_NULLPTR, SIP_NULLPTR},
    {"peerVerifyError(QSslError)", "\1peerVerifyError(self, QSslError)", SIP_NULLPTR, SIP_NULLPTR},
    {"preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator*)", "\1preSharedKeyAuthenticationRequired(self, QSslPreSharedKeyAuthenticator)", SIP_NULLPTR, SIP_NULLPTR},
    {"modeChanged(QSslSocket::SslMode)", "\1modeChanged(self, QSslSocket.SslMode)", SIP_NULLPTR, SIP_NULLPTR},
    {"encrypted()", "\1encrypted(self)", SIP_NULLPTR, SIP_NULLPTR},
    {"sslErrors(QList<QSslError>)", "\1sslErrors(self, Iterable[QSslError])", &methods_QSslSocket[53], SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


static pyqt5ClassPluginDef plugin_QSslSocket = {
    & ::QSslSocket::staticMetaObject,
    0,
    signals_QSslSocket,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSslSocket = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSslSocket,
        {SIP_NULLPTR},
        &plugin_QSslSocket
    },
    {
        sipNameNr_QSslSocket,
        {0, 0, 1},
        69, methods_QSslSocket,
        7, enummembers_QSslSocket,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSslSocket,
    -1,
    -1,
    supers_QSslSocket,
    SIP_NULLPTR,
    init_type_QSslSocket,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSslSocket,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QSslSocket,
    cast_QSslSocket,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qtcpsocket.sip"
#include <qtcpsocket.h>
#line 12189 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 12193 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qhostaddress.sip"
#include <qhostaddress.h>
#line 12196 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 12199 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 12202 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 12205 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qabstractsocket.sip"
#include <qabstractsocket.h>
#line 12208 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 12211 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkproxy.sip"
#include <qnetworkproxy.h>
#line 12214 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qauthenticator.sip"
#include <qauthenticator.h>
#line 12217 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 160 "sip/QtCore/qglobal.sip"
#include <QtGlobal>
#line 12220 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qiodevice.sip"
#include <qiodevice.h>
#line 12223 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 12226 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 12229 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 12232 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 12235 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 12238 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 12241 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 12244 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 12247 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 12250 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 12253 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 12256 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 12259 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 12262 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


class sipQTcpSocket : public  ::QTcpSocket
{
public:
    sipQTcpSocket( ::QObject*);
    virtual ~sipQTcpSocket();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::qint64 writeData(const char*,PY_LONG_LONG) SIP_OVERRIDE;
     ::qint64 readLineData(char*, ::qint64) SIP_OVERRIDE;
     ::qint64 readData(char*, ::qint64) SIP_OVERRIDE;
    bool waitForBytesWritten(int) SIP_OVERRIDE;
    bool waitForReadyRead(int) SIP_OVERRIDE;
    bool canReadLine() const SIP_OVERRIDE;
     ::qint64 bytesToWrite() const SIP_OVERRIDE;
     ::qint64 bytesAvailable() const SIP_OVERRIDE;
    bool reset() SIP_OVERRIDE;
    bool atEnd() const SIP_OVERRIDE;
    bool seek( ::qint64) SIP_OVERRIDE;
     ::qint64 size() const SIP_OVERRIDE;
     ::qint64 pos() const SIP_OVERRIDE;
    void close() SIP_OVERRIDE;
    bool open( ::QIODevice::OpenMode) SIP_OVERRIDE;
    bool isSequential() const SIP_OVERRIDE;
    bool event( ::QEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void connectToHost(const  ::QString&, ::quint16, ::QIODevice::OpenMode, ::QAbstractSocket::NetworkLayerProtocol) SIP_OVERRIDE;
    void connectToHost(const  ::QHostAddress&, ::quint16, ::QIODevice::OpenMode) SIP_OVERRIDE;
    void disconnectFromHost() SIP_OVERRIDE;
    void setReadBufferSize( ::qint64) SIP_OVERRIDE;
    bool setSocketDescriptor( ::qintptr, ::QAbstractSocket::SocketState, ::QIODevice::OpenMode) SIP_OVERRIDE;
     ::qintptr socketDescriptor() const SIP_OVERRIDE;
    bool waitForConnected(int) SIP_OVERRIDE;
    bool waitForDisconnected(int) SIP_OVERRIDE;
    void setSocketOption( ::QAbstractSocket::SocketOption,const  ::QVariant&) SIP_OVERRIDE;
     ::QVariant socketOption( ::QAbstractSocket::SocketOption) SIP_OVERRIDE;
    void resume() SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQTcpSocket(const sipQTcpSocket &);
    sipQTcpSocket &operator = (const sipQTcpSocket &);

    char sipPyMethods[34];
};

sipQTcpSocket::sipQTcpSocket( ::QObject*a0):  ::QTcpSocket(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQTcpSocket::~sipQTcpSocket()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQTcpSocket::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtNetwork_qt_metaobject(sipPySelf,sipType_QTcpSocket);

    return  ::QTcpSocket::metaObject();
}

int sipQTcpSocket::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QTcpSocket::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtNetwork_qt_metacall(sipPySelf,sipType_QTcpSocket,_c,_id,_a);

    return _id;
}

void *sipQTcpSocket::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtNetwork_qt_metacast(sipPySelf, sipType_QTcpSocket, _clname, &sipCpp) ? sipCpp :  ::QTcpSocket::qt_metacast(_clname));
}

 ::qint64 sipQTcpSocket::writeData(const char*a0,PY_LONG_LONG a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_writeData);

    if (!sipMeth)
        return  ::QTcpSocket::writeData(a0,a1);

    extern  ::qint64 sipVH_QtNetwork_14(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const char*,PY_LONG_LONG);

    return sipVH_QtNetwork_14(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

 ::qint64 sipQTcpSocket::readLineData(char*a0, ::qint64 a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_readLineData);

    if (!sipMeth)
        return  ::QTcpSocket::readLineData(a0,a1);

    extern  ::qint64 sipVH_QtNetwork_15(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, char*, ::qint64);

    return sipVH_QtNetwork_15(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

 ::qint64 sipQTcpSocket::readData(char*a0, ::qint64 a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_readData);

    if (!sipMeth)
        return  ::QTcpSocket::readData(a0,a1);

    extern  ::qint64 sipVH_QtNetwork_16(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, char*, ::qint64);

    return sipVH_QtNetwork_16(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQTcpSocket::waitForBytesWritten(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_waitForBytesWritten);

    if (!sipMeth)
        return  ::QTcpSocket::waitForBytesWritten(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQTcpSocket::waitForReadyRead(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_waitForReadyRead);

    if (!sipMeth)
        return  ::QTcpSocket::waitForReadyRead(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQTcpSocket::canReadLine() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[5]),sipPySelf,SIP_NULLPTR,sipName_canReadLine);

    if (!sipMeth)
        return  ::QTcpSocket::canReadLine();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::qint64 sipQTcpSocket::bytesToWrite() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[6]),sipPySelf,SIP_NULLPTR,sipName_bytesToWrite);

    if (!sipMeth)
        return  ::QTcpSocket::bytesToWrite();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::qint64 sipQTcpSocket::bytesAvailable() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[7]),sipPySelf,SIP_NULLPTR,sipName_bytesAvailable);

    if (!sipMeth)
        return  ::QTcpSocket::bytesAvailable();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQTcpSocket::reset()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[8],sipPySelf,SIP_NULLPTR,sipName_reset);

    if (!sipMeth)
        return  ::QTcpSocket::reset();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQTcpSocket::atEnd() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[9]),sipPySelf,SIP_NULLPTR,sipName_atEnd);

    if (!sipMeth)
        return  ::QTcpSocket::atEnd();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQTcpSocket::seek( ::qint64 a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[10],sipPySelf,SIP_NULLPTR,sipName_seek);

    if (!sipMeth)
        return  ::QTcpSocket::seek(a0);

    extern bool sipVH_QtNetwork_19(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::qint64);

    return sipVH_QtNetwork_19(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

 ::qint64 sipQTcpSocket::size() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[11]),sipPySelf,SIP_NULLPTR,sipName_size);

    if (!sipMeth)
        return  ::QTcpSocket::size();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::qint64 sipQTcpSocket::pos() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[12]),sipPySelf,SIP_NULLPTR,sipName_pos);

    if (!sipMeth)
        return  ::QTcpSocket::pos();

    extern  ::qint64 sipVH_QtNetwork_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_10(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

void sipQTcpSocket::close()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[13],sipPySelf,SIP_NULLPTR,sipName_close);

    if (!sipMeth)
    {
         ::QTcpSocket::close();
        return;
    }

    extern void sipVH_QtNetwork_13(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_QtNetwork_13(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQTcpSocket::open( ::QIODevice::OpenMode a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[14],sipPySelf,SIP_NULLPTR,sipName_open);

    if (!sipMeth)
        return  ::QTcpSocket::open(a0);

    extern bool sipVH_QtNetwork_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QIODevice::OpenMode);

    return sipVH_QtNetwork_20(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQTcpSocket::isSequential() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[15]),sipPySelf,SIP_NULLPTR,sipName_isSequential);

    if (!sipMeth)
        return  ::QTcpSocket::isSequential();

    extern bool sipVH_QtNetwork_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_18(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQTcpSocket::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[16],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QTcpSocket::event(a0);

    extern bool sipVH_QtNetwork_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtNetwork_5(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQTcpSocket::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[17],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QTcpSocket::eventFilter(a0,a1);

    extern bool sipVH_QtNetwork_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtNetwork_4(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

void sipQTcpSocket::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[18],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QTcpSocket::timerEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtNetwork_3(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTcpSocket::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[19],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QTcpSocket::childEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtNetwork_2(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTcpSocket::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[20],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QTcpSocket::customEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtNetwork_1(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTcpSocket::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[21],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QTcpSocket::connectNotify(a0);
        return;
    }

    extern void sipVH_QtNetwork_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtNetwork_0(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTcpSocket::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[22],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QTcpSocket::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtNetwork_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtNetwork_0(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTcpSocket::connectToHost(const  ::QString& a0, ::quint16 a1, ::QIODevice::OpenMode a2, ::QAbstractSocket::NetworkLayerProtocol a3)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[23],sipPySelf,SIP_NULLPTR,sipName_connectToHost);

    if (!sipMeth)
    {
         ::QTcpSocket::connectToHost(a0,a1,a2,a3);
        return;
    }

    extern void sipVH_QtNetwork_21(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QString&, ::quint16, ::QIODevice::OpenMode, ::QAbstractSocket::NetworkLayerProtocol);

    sipVH_QtNetwork_21(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3);
}

void sipQTcpSocket::connectToHost(const  ::QHostAddress& a0, ::quint16 a1, ::QIODevice::OpenMode a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[24],sipPySelf,SIP_NULLPTR,sipName_connectToHost);

    if (!sipMeth)
    {
         ::QTcpSocket::connectToHost(a0,a1,a2);
        return;
    }

    extern void sipVH_QtNetwork_22(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QHostAddress&, ::quint16, ::QIODevice::OpenMode);

    sipVH_QtNetwork_22(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2);
}

void sipQTcpSocket::disconnectFromHost()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[25],sipPySelf,SIP_NULLPTR,sipName_disconnectFromHost);

    if (!sipMeth)
    {
         ::QTcpSocket::disconnectFromHost();
        return;
    }

    extern void sipVH_QtNetwork_13(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_QtNetwork_13(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

void sipQTcpSocket::setReadBufferSize( ::qint64 a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[26],sipPySelf,SIP_NULLPTR,sipName_setReadBufferSize);

    if (!sipMeth)
    {
         ::QTcpSocket::setReadBufferSize(a0);
        return;
    }

    extern void sipVH_QtNetwork_23(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::qint64);

    sipVH_QtNetwork_23(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQTcpSocket::setSocketDescriptor( ::qintptr a0, ::QAbstractSocket::SocketState a1, ::QIODevice::OpenMode a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[27],sipPySelf,SIP_NULLPTR,sipName_setSocketDescriptor);

    if (!sipMeth)
        return  ::QTcpSocket::setSocketDescriptor(a0,a1,a2);

    extern bool sipVH_QtNetwork_24(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::qintptr, ::QAbstractSocket::SocketState, ::QIODevice::OpenMode);

    return sipVH_QtNetwork_24(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2);
}

 ::qintptr sipQTcpSocket::socketDescriptor() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[28]),sipPySelf,SIP_NULLPTR,sipName_socketDescriptor);

    if (!sipMeth)
        return  ::QTcpSocket::socketDescriptor();

    extern  ::qintptr sipVH_QtNetwork_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH_QtNetwork_25(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQTcpSocket::waitForConnected(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[29],sipPySelf,SIP_NULLPTR,sipName_waitForConnected);

    if (!sipMeth)
        return  ::QTcpSocket::waitForConnected(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQTcpSocket::waitForDisconnected(int a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[30],sipPySelf,SIP_NULLPTR,sipName_waitForDisconnected);

    if (!sipMeth)
        return  ::QTcpSocket::waitForDisconnected(a0);

    extern bool sipVH_QtNetwork_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH_QtNetwork_17(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTcpSocket::setSocketOption( ::QAbstractSocket::SocketOption a0,const  ::QVariant& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[31],sipPySelf,SIP_NULLPTR,sipName_setSocketOption);

    if (!sipMeth)
    {
         ::QTcpSocket::setSocketOption(a0,a1);
        return;
    }

    extern void sipVH_QtNetwork_26(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QAbstractSocket::SocketOption,const  ::QVariant&);

    sipVH_QtNetwork_26(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

 ::QVariant sipQTcpSocket::socketOption( ::QAbstractSocket::SocketOption a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[32],sipPySelf,SIP_NULLPTR,sipName_socketOption);

    if (!sipMeth)
        return  ::QTcpSocket::socketOption(a0);

    extern  ::QVariant sipVH_QtNetwork_27(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QAbstractSocket::SocketOption);

    return sipVH_QtNetwork_27(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQTcpSocket::resume()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[33],sipPySelf,SIP_NULLPTR,sipName_resume);

    if (!sipMeth)
    {
         ::QTcpSocket::resume();
        return;
    }

    extern void sipVH_QtNetwork_13(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_QtNetwork_13(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QTcpSocket(void *, const sipTypeDef *);}
static void *cast_QTcpSocket(void *sipCppV, const sipTypeDef *targetType)
{
     ::QTcpSocket *sipCpp = reinterpret_cast< ::QTcpSocket *>(sipCppV);

    if (targetType == sipType_QAbstractSocket)
        return static_cast< ::QAbstractSocket *>(sipCpp);

    if (targetType == sipType_QIODevice)
        return static_cast< ::QIODevice *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QTcpSocket(void *, int);}
static void release_QTcpSocket(void *sipCppV, int)
{
     ::QTcpSocket *sipCpp = reinterpret_cast< ::QTcpSocket *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QTcpSocket(sipSimpleWrapper *);}
static void dealloc_QTcpSocket(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQTcpSocket *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QTcpSocket(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QTcpSocket(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QTcpSocket(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQTcpSocket *sipCpp = SIP_NULLPTR;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQTcpSocket(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QTcpSocket[] = {{1, 255, 1}};

PyDoc_STRVAR(doc_QTcpSocket, "\1QTcpSocket(parent: QObject = None)");


static pyqt5ClassPluginDef plugin_QTcpSocket = {
    & ::QTcpSocket::staticMetaObject,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QTcpSocket = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QTcpSocket,
        {SIP_NULLPTR},
        &plugin_QTcpSocket
    },
    {
        sipNameNr_QTcpSocket,
        {0, 0, 1},
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QTcpSocket,
    -1,
    -1,
    supers_QTcpSocket,
    SIP_NULLPTR,
    init_type_QTcpSocket,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QTcpSocket,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QTcpSocket,
    cast_QTcpSocket,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslpresharedkeyauthenticator.sip"
#include <qsslpresharedkeyauthenticator.h>
#line 13044 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 13048 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


PyDoc_STRVAR(doc_QSslPreSharedKeyAuthenticator_swap, "swap(self, QSslPreSharedKeyAuthenticator)");

extern "C" {static PyObject *meth_QSslPreSharedKeyAuthenticator_swap(PyObject *, PyObject *);}
static PyObject *meth_QSslPreSharedKeyAuthenticator_swap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslPreSharedKeyAuthenticator* a0;
         ::QSslPreSharedKeyAuthenticator *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslPreSharedKeyAuthenticator, &sipCpp, sipType_QSslPreSharedKeyAuthenticator, &a0))
        {
            sipCpp->swap(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslPreSharedKeyAuthenticator, sipName_swap, doc_QSslPreSharedKeyAuthenticator_swap);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslPreSharedKeyAuthenticator_identityHint, "identityHint(self) -> QByteArray");

extern "C" {static PyObject *meth_QSslPreSharedKeyAuthenticator_identityHint(PyObject *, PyObject *);}
static PyObject *meth_QSslPreSharedKeyAuthenticator_identityHint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslPreSharedKeyAuthenticator *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslPreSharedKeyAuthenticator, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->identityHint());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslPreSharedKeyAuthenticator, sipName_identityHint, doc_QSslPreSharedKeyAuthenticator_identityHint);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslPreSharedKeyAuthenticator_setIdentity, "setIdentity(self, Union[QByteArray, bytes, bytearray])");

extern "C" {static PyObject *meth_QSslPreSharedKeyAuthenticator_setIdentity(PyObject *, PyObject *);}
static PyObject *meth_QSslPreSharedKeyAuthenticator_setIdentity(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray* a0;
        int a0State = 0;
         ::QSslPreSharedKeyAuthenticator *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslPreSharedKeyAuthenticator, &sipCpp, sipType_QByteArray, &a0, &a0State))
        {
            sipCpp->setIdentity(*a0);
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslPreSharedKeyAuthenticator, sipName_setIdentity, doc_QSslPreSharedKeyAuthenticator_setIdentity);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslPreSharedKeyAuthenticator_identity, "identity(self) -> QByteArray");

extern "C" {static PyObject *meth_QSslPreSharedKeyAuthenticator_identity(PyObject *, PyObject *);}
static PyObject *meth_QSslPreSharedKeyAuthenticator_identity(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslPreSharedKeyAuthenticator *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslPreSharedKeyAuthenticator, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->identity());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslPreSharedKeyAuthenticator, sipName_identity, doc_QSslPreSharedKeyAuthenticator_identity);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslPreSharedKeyAuthenticator_maximumIdentityLength, "maximumIdentityLength(self) -> int");

extern "C" {static PyObject *meth_QSslPreSharedKeyAuthenticator_maximumIdentityLength(PyObject *, PyObject *);}
static PyObject *meth_QSslPreSharedKeyAuthenticator_maximumIdentityLength(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslPreSharedKeyAuthenticator *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslPreSharedKeyAuthenticator, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->maximumIdentityLength();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslPreSharedKeyAuthenticator, sipName_maximumIdentityLength, doc_QSslPreSharedKeyAuthenticator_maximumIdentityLength);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslPreSharedKeyAuthenticator_setPreSharedKey, "setPreSharedKey(self, Union[QByteArray, bytes, bytearray])");

extern "C" {static PyObject *meth_QSslPreSharedKeyAuthenticator_setPreSharedKey(PyObject *, PyObject *);}
static PyObject *meth_QSslPreSharedKeyAuthenticator_setPreSharedKey(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray* a0;
        int a0State = 0;
         ::QSslPreSharedKeyAuthenticator *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslPreSharedKeyAuthenticator, &sipCpp, sipType_QByteArray, &a0, &a0State))
        {
            sipCpp->setPreSharedKey(*a0);
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslPreSharedKeyAuthenticator, sipName_setPreSharedKey, doc_QSslPreSharedKeyAuthenticator_setPreSharedKey);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslPreSharedKeyAuthenticator_preSharedKey, "preSharedKey(self) -> QByteArray");

extern "C" {static PyObject *meth_QSslPreSharedKeyAuthenticator_preSharedKey(PyObject *, PyObject *);}
static PyObject *meth_QSslPreSharedKeyAuthenticator_preSharedKey(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslPreSharedKeyAuthenticator *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslPreSharedKeyAuthenticator, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->preSharedKey());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslPreSharedKeyAuthenticator, sipName_preSharedKey, doc_QSslPreSharedKeyAuthenticator_preSharedKey);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslPreSharedKeyAuthenticator_maximumPreSharedKeyLength, "maximumPreSharedKeyLength(self) -> int");

extern "C" {static PyObject *meth_QSslPreSharedKeyAuthenticator_maximumPreSharedKeyLength(PyObject *, PyObject *);}
static PyObject *meth_QSslPreSharedKeyAuthenticator_maximumPreSharedKeyLength(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslPreSharedKeyAuthenticator *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslPreSharedKeyAuthenticator, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->maximumPreSharedKeyLength();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslPreSharedKeyAuthenticator, sipName_maximumPreSharedKeyLength, doc_QSslPreSharedKeyAuthenticator_maximumPreSharedKeyLength);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *slot_QSslPreSharedKeyAuthenticator___eq__(PyObject *,PyObject *);}
static PyObject *slot_QSslPreSharedKeyAuthenticator___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslPreSharedKeyAuthenticator *sipCpp = reinterpret_cast< ::QSslPreSharedKeyAuthenticator *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslPreSharedKeyAuthenticator));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslPreSharedKeyAuthenticator* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslPreSharedKeyAuthenticator, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, eq_slot, sipType_QSslPreSharedKeyAuthenticator, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QSslPreSharedKeyAuthenticator___ne__(PyObject *,PyObject *);}
static PyObject *slot_QSslPreSharedKeyAuthenticator___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslPreSharedKeyAuthenticator *sipCpp = reinterpret_cast< ::QSslPreSharedKeyAuthenticator *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslPreSharedKeyAuthenticator));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslPreSharedKeyAuthenticator* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslPreSharedKeyAuthenticator, &a0))
        {
            bool sipRes;

            sipRes = operator!=((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, ne_slot, sipType_QSslPreSharedKeyAuthenticator, sipSelf, sipArg);
}


/* Call the instance's destructor. */
extern "C" {static void release_QSslPreSharedKeyAuthenticator(void *, int);}
static void release_QSslPreSharedKeyAuthenticator(void *sipCppV, int)
{
    delete reinterpret_cast< ::QSslPreSharedKeyAuthenticator *>(sipCppV);
}


extern "C" {static void assign_QSslPreSharedKeyAuthenticator(void *, SIP_SSIZE_T, void *);}
static void assign_QSslPreSharedKeyAuthenticator(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QSslPreSharedKeyAuthenticator *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QSslPreSharedKeyAuthenticator *>(sipSrc);
}


extern "C" {static void *array_QSslPreSharedKeyAuthenticator(SIP_SSIZE_T);}
static void *array_QSslPreSharedKeyAuthenticator(SIP_SSIZE_T sipNrElem)
{
    return new  ::QSslPreSharedKeyAuthenticator[sipNrElem];
}


extern "C" {static void *copy_QSslPreSharedKeyAuthenticator(const void *, SIP_SSIZE_T);}
static void *copy_QSslPreSharedKeyAuthenticator(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QSslPreSharedKeyAuthenticator(reinterpret_cast<const  ::QSslPreSharedKeyAuthenticator *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QSslPreSharedKeyAuthenticator(sipSimpleWrapper *);}
static void dealloc_QSslPreSharedKeyAuthenticator(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSslPreSharedKeyAuthenticator(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QSslPreSharedKeyAuthenticator(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSslPreSharedKeyAuthenticator(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QSslPreSharedKeyAuthenticator *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new  ::QSslPreSharedKeyAuthenticator();

            return sipCpp;
        }
    }

    {
        const  ::QSslPreSharedKeyAuthenticator* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QSslPreSharedKeyAuthenticator, &a0))
        {
            sipCpp = new  ::QSslPreSharedKeyAuthenticator(*a0);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QSslPreSharedKeyAuthenticator[] = {
    {(void *)slot_QSslPreSharedKeyAuthenticator___eq__, eq_slot},
    {(void *)slot_QSslPreSharedKeyAuthenticator___ne__, ne_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_QSslPreSharedKeyAuthenticator[] = {
    {SIP_MLNAME_CAST(sipName_identity), meth_QSslPreSharedKeyAuthenticator_identity, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslPreSharedKeyAuthenticator_identity)},
    {SIP_MLNAME_CAST(sipName_identityHint), meth_QSslPreSharedKeyAuthenticator_identityHint, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslPreSharedKeyAuthenticator_identityHint)},
    {SIP_MLNAME_CAST(sipName_maximumIdentityLength), meth_QSslPreSharedKeyAuthenticator_maximumIdentityLength, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslPreSharedKeyAuthenticator_maximumIdentityLength)},
    {SIP_MLNAME_CAST(sipName_maximumPreSharedKeyLength), meth_QSslPreSharedKeyAuthenticator_maximumPreSharedKeyLength, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslPreSharedKeyAuthenticator_maximumPreSharedKeyLength)},
    {SIP_MLNAME_CAST(sipName_preSharedKey), meth_QSslPreSharedKeyAuthenticator_preSharedKey, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslPreSharedKeyAuthenticator_preSharedKey)},
    {SIP_MLNAME_CAST(sipName_setIdentity), meth_QSslPreSharedKeyAuthenticator_setIdentity, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslPreSharedKeyAuthenticator_setIdentity)},
    {SIP_MLNAME_CAST(sipName_setPreSharedKey), meth_QSslPreSharedKeyAuthenticator_setPreSharedKey, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslPreSharedKeyAuthenticator_setPreSharedKey)},
    {SIP_MLNAME_CAST(sipName_swap), meth_QSslPreSharedKeyAuthenticator_swap, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslPreSharedKeyAuthenticator_swap)}
};

PyDoc_STRVAR(doc_QSslPreSharedKeyAuthenticator, "\1QSslPreSharedKeyAuthenticator()\n"
"QSslPreSharedKeyAuthenticator(QSslPreSharedKeyAuthenticator)");


static pyqt5ClassPluginDef plugin_QSslPreSharedKeyAuthenticator = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSslPreSharedKeyAuthenticator = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSslPreSharedKeyAuthenticator,
        {SIP_NULLPTR},
        &plugin_QSslPreSharedKeyAuthenticator
    },
    {
        sipNameNr_QSslPreSharedKeyAuthenticator,
        {0, 0, 1},
        8, methods_QSslPreSharedKeyAuthenticator,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSslPreSharedKeyAuthenticator,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    slots_QSslPreSharedKeyAuthenticator,
    init_type_QSslPreSharedKeyAuthenticator,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSslPreSharedKeyAuthenticator,
    assign_QSslPreSharedKeyAuthenticator,
    array_QSslPreSharedKeyAuthenticator,
    copy_QSslPreSharedKeyAuthenticator,
    release_QSslPreSharedKeyAuthenticator,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslkey.sip"
#include <qsslkey.h>
#line 13495 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 13499 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 13502 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qiodevice.sip"
#include <qiodevice.h>
#line 13505 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


PyDoc_STRVAR(doc_QSslKey_isNull, "isNull(self) -> bool");

extern "C" {static PyObject *meth_QSslKey_isNull(PyObject *, PyObject *);}
static PyObject *meth_QSslKey_isNull(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslKey *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslKey, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isNull();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslKey, sipName_isNull, doc_QSslKey_isNull);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslKey_clear, "clear(self)");

extern "C" {static PyObject *meth_QSslKey_clear(PyObject *, PyObject *);}
static PyObject *meth_QSslKey_clear(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslKey *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslKey, &sipCpp))
        {
            sipCpp->clear();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslKey, sipName_clear, doc_QSslKey_clear);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslKey_length, "length(self) -> int");

extern "C" {static PyObject *meth_QSslKey_length(PyObject *, PyObject *);}
static PyObject *meth_QSslKey_length(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslKey *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslKey, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->length();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslKey, sipName_length, doc_QSslKey_length);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslKey_type, "type(self) -> QSsl.KeyType");

extern "C" {static PyObject *meth_QSslKey_type(PyObject *, PyObject *);}
static PyObject *meth_QSslKey_type(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslKey *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslKey, &sipCpp))
        {
             ::QSsl::KeyType sipRes;

            sipRes = sipCpp->type();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSsl_KeyType);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslKey, sipName_type, doc_QSslKey_type);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslKey_algorithm, "algorithm(self) -> QSsl.KeyAlgorithm");

extern "C" {static PyObject *meth_QSslKey_algorithm(PyObject *, PyObject *);}
static PyObject *meth_QSslKey_algorithm(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslKey *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslKey, &sipCpp))
        {
             ::QSsl::KeyAlgorithm sipRes;

            sipRes = sipCpp->algorithm();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSsl_KeyAlgorithm);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslKey, sipName_algorithm, doc_QSslKey_algorithm);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslKey_toPem, "toPem(self, passPhrase: Union[QByteArray, bytes, bytearray] = QByteArray()) -> QByteArray");

extern "C" {static PyObject *meth_QSslKey_toPem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslKey_toPem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray& a0def = QByteArray();
        const  ::QByteArray* a0 = &a0def;
        int a0State = 0;
        const  ::QSslKey *sipCpp;

        static const char *sipKwdList[] = {
            sipName_passPhrase,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|J1", &sipSelf, sipType_QSslKey, &sipCpp, sipType_QByteArray, &a0, &a0State))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->toPem(*a0));
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslKey, sipName_toPem, doc_QSslKey_toPem);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslKey_toDer, "toDer(self, passPhrase: Union[QByteArray, bytes, bytearray] = QByteArray()) -> QByteArray");

extern "C" {static PyObject *meth_QSslKey_toDer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslKey_toDer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray& a0def = QByteArray();
        const  ::QByteArray* a0 = &a0def;
        int a0State = 0;
        const  ::QSslKey *sipCpp;

        static const char *sipKwdList[] = {
            sipName_passPhrase,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|J1", &sipSelf, sipType_QSslKey, &sipCpp, sipType_QByteArray, &a0, &a0State))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->toDer(*a0));
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslKey, sipName_toDer, doc_QSslKey_toDer);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslKey_handle, "handle(self) -> sip.voidptr");

extern "C" {static PyObject *meth_QSslKey_handle(PyObject *, PyObject *);}
static PyObject *meth_QSslKey_handle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslKey *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslKey, &sipCpp))
        {
             ::Qt::HANDLE sipRes;

            sipRes = sipCpp->handle();

            return sipConvertFromVoidPtr((void *)sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslKey, sipName_handle, doc_QSslKey_handle);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslKey_swap, "swap(self, QSslKey)");

extern "C" {static PyObject *meth_QSslKey_swap(PyObject *, PyObject *);}
static PyObject *meth_QSslKey_swap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslKey* a0;
         ::QSslKey *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslKey, &sipCpp, sipType_QSslKey, &a0))
        {
            sipCpp->swap(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslKey, sipName_swap, doc_QSslKey_swap);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *slot_QSslKey___ne__(PyObject *,PyObject *);}
static PyObject *slot_QSslKey___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslKey *sipCpp = reinterpret_cast< ::QSslKey *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslKey));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslKey* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslKey, &a0))
        {
            bool sipRes;

            sipRes = sipCpp-> ::QSslKey::operator!=(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, ne_slot, sipType_QSslKey, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QSslKey___eq__(PyObject *,PyObject *);}
static PyObject *slot_QSslKey___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslKey *sipCpp = reinterpret_cast< ::QSslKey *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslKey));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslKey* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslKey, &a0))
        {
            bool sipRes;

            sipRes = sipCpp-> ::QSslKey::operator==(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, eq_slot, sipType_QSslKey, sipSelf, sipArg);
}


/* Call the instance's destructor. */
extern "C" {static void release_QSslKey(void *, int);}
static void release_QSslKey(void *sipCppV, int)
{
    delete reinterpret_cast< ::QSslKey *>(sipCppV);
}


extern "C" {static void assign_QSslKey(void *, SIP_SSIZE_T, void *);}
static void assign_QSslKey(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QSslKey *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QSslKey *>(sipSrc);
}


extern "C" {static void *array_QSslKey(SIP_SSIZE_T);}
static void *array_QSslKey(SIP_SSIZE_T sipNrElem)
{
    return new  ::QSslKey[sipNrElem];
}


extern "C" {static void *copy_QSslKey(const void *, SIP_SSIZE_T);}
static void *copy_QSslKey(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QSslKey(reinterpret_cast<const  ::QSslKey *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QSslKey(sipSimpleWrapper *);}
static void dealloc_QSslKey(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSslKey(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QSslKey(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSslKey(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QSslKey *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new  ::QSslKey();

            return sipCpp;
        }
    }

    {
        const  ::QByteArray* a0;
        int a0State = 0;
         ::QSsl::KeyAlgorithm a1;
         ::QSsl::EncodingFormat a2 = QSsl::Pem;
         ::QSsl::KeyType a3 = QSsl::PrivateKey;
        const  ::QByteArray& a4def = QByteArray();
        const  ::QByteArray* a4 = &a4def;
        int a4State = 0;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            SIP_NULLPTR,
            sipName_encoding,
            sipName_type,
            sipName_passPhrase,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1E|EEJ1", sipType_QByteArray, &a0, &a0State, sipType_QSsl_KeyAlgorithm, &a1, sipType_QSsl_EncodingFormat, &a2, sipType_QSsl_KeyType, &a3, sipType_QByteArray, &a4, &a4State))
        {
            sipCpp = new  ::QSslKey(*a0,a1,a2,a3,*a4);
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);
            sipReleaseType(const_cast< ::QByteArray *>(a4),sipType_QByteArray,a4State);

            return sipCpp;
        }
    }

    {
         ::QIODevice* a0;
         ::QSsl::KeyAlgorithm a1;
         ::QSsl::EncodingFormat a2 = QSsl::Pem;
         ::QSsl::KeyType a3 = QSsl::PrivateKey;
        const  ::QByteArray& a4def = QByteArray();
        const  ::QByteArray* a4 = &a4def;
        int a4State = 0;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            SIP_NULLPTR,
            sipName_encoding,
            sipName_type,
            sipName_passPhrase,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8E|EEJ1", sipType_QIODevice, &a0, sipType_QSsl_KeyAlgorithm, &a1, sipType_QSsl_EncodingFormat, &a2, sipType_QSsl_KeyType, &a3, sipType_QByteArray, &a4, &a4State))
        {
            sipCpp = new  ::QSslKey(a0,a1,a2,a3,*a4);
            sipReleaseType(const_cast< ::QByteArray *>(a4),sipType_QByteArray,a4State);

            return sipCpp;
        }
    }

    {
         ::Qt::HANDLE a0;
         ::QSsl::KeyType a1 = QSsl::PrivateKey;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_type,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "v|E", &a0, sipType_QSsl_KeyType, &a1))
        {
            sipCpp = new  ::QSslKey(a0,a1);

            return sipCpp;
        }
    }

    {
        const  ::QSslKey* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QSslKey, &a0))
        {
            sipCpp = new  ::QSslKey(*a0);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QSslKey[] = {
    {(void *)slot_QSslKey___ne__, ne_slot},
    {(void *)slot_QSslKey___eq__, eq_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_QSslKey[] = {
    {SIP_MLNAME_CAST(sipName_algorithm), meth_QSslKey_algorithm, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslKey_algorithm)},
    {SIP_MLNAME_CAST(sipName_clear), meth_QSslKey_clear, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslKey_clear)},
    {SIP_MLNAME_CAST(sipName_handle), meth_QSslKey_handle, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslKey_handle)},
    {SIP_MLNAME_CAST(sipName_isNull), meth_QSslKey_isNull, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslKey_isNull)},
    {SIP_MLNAME_CAST(sipName_length), meth_QSslKey_length, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslKey_length)},
    {SIP_MLNAME_CAST(sipName_swap), meth_QSslKey_swap, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslKey_swap)},
    {SIP_MLNAME_CAST(sipName_toDer), SIP_MLMETH_CAST(meth_QSslKey_toDer), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslKey_toDer)},
    {SIP_MLNAME_CAST(sipName_toPem), SIP_MLMETH_CAST(meth_QSslKey_toPem), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslKey_toPem)},
    {SIP_MLNAME_CAST(sipName_type), meth_QSslKey_type, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslKey_type)}
};

PyDoc_STRVAR(doc_QSslKey, "\1QSslKey()\n"
"QSslKey(Union[QByteArray, bytes, bytearray], QSsl.KeyAlgorithm, encoding: QSsl.EncodingFormat = QSsl.Pem, type: QSsl.KeyType = QSsl.PrivateKey, passPhrase: Union[QByteArray, bytes, bytearray] = QByteArray())\n"
"QSslKey(QIODevice, QSsl.KeyAlgorithm, encoding: QSsl.EncodingFormat = QSsl.Pem, type: QSsl.KeyType = QSsl.PrivateKey, passPhrase: Union[QByteArray, bytes, bytearray] = QByteArray())\n"
"QSslKey(sip.voidptr, type: QSsl.KeyType = QSsl.PrivateKey)\n"
"QSslKey(QSslKey)");


static pyqt5ClassPluginDef plugin_QSslKey = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSslKey = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSslKey,
        {SIP_NULLPTR},
        &plugin_QSslKey
    },
    {
        sipNameNr_QSslKey,
        {0, 0, 1},
        9, methods_QSslKey,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSslKey,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    slots_QSslKey,
    init_type_QSslKey,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSslKey,
    assign_QSslKey,
    array_QSslKey,
    copy_QSslKey,
    release_QSslKey,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslerror.sip"
#include <qsslerror.h>
#line 14069 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcertificate.sip"
#include <qsslcertificate.h>
#line 14073 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 14076 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


PyDoc_STRVAR(doc_QSslError_error, "error(self) -> QSslError.SslError");

extern "C" {static PyObject *meth_QSslError_error(PyObject *, PyObject *);}
static PyObject *meth_QSslError_error(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslError, &sipCpp))
        {
             ::QSslError::SslError sipRes;

            sipRes = sipCpp->error();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSslError_SslError);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslError, sipName_error, doc_QSslError_error);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslError_errorString, "errorString(self) -> str");

extern "C" {static PyObject *meth_QSslError_errorString(PyObject *, PyObject *);}
static PyObject *meth_QSslError_errorString(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslError, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->errorString());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslError, sipName_errorString, doc_QSslError_errorString);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslError_certificate, "certificate(self) -> QSslCertificate");

extern "C" {static PyObject *meth_QSslError_certificate(PyObject *, PyObject *);}
static PyObject *meth_QSslError_certificate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslError, &sipCpp))
        {
             ::QSslCertificate*sipRes;

            sipRes = new  ::QSslCertificate(sipCpp->certificate());

            return sipConvertFromNewType(sipRes,sipType_QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslError, sipName_certificate, doc_QSslError_certificate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslError_swap, "swap(self, QSslError)");

extern "C" {static PyObject *meth_QSslError_swap(PyObject *, PyObject *);}
static PyObject *meth_QSslError_swap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslError* a0;
         ::QSslError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslError, &sipCpp, sipType_QSslError, &a0))
        {
            sipCpp->swap(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslError, sipName_swap, doc_QSslError_swap);

    return SIP_NULLPTR;
}


extern "C" {static long slot_QSslError___hash__(PyObject *);}
static long slot_QSslError___hash__(PyObject *sipSelf)
{
     ::QSslError *sipCpp = reinterpret_cast< ::QSslError *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslError));

    if (!sipCpp)
        return 0L;


    {
        {
            long sipRes = 0;

#line 76 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslerror.sip"
        sipRes = qHash(*sipCpp);
#line 14206 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            return sipRes;
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_QSslError___ne__(PyObject *,PyObject *);}
static PyObject *slot_QSslError___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslError *sipCpp = reinterpret_cast< ::QSslError *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslError));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslError* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslError, &a0))
        {
            bool sipRes;

            sipRes = sipCpp-> ::QSslError::operator!=(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, ne_slot, sipType_QSslError, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QSslError___eq__(PyObject *,PyObject *);}
static PyObject *slot_QSslError___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslError *sipCpp = reinterpret_cast< ::QSslError *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslError));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslError* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslError, &a0))
        {
            bool sipRes;

            sipRes = sipCpp-> ::QSslError::operator==(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, eq_slot, sipType_QSslError, sipSelf, sipArg);
}


/* Call the instance's destructor. */
extern "C" {static void release_QSslError(void *, int);}
static void release_QSslError(void *sipCppV, int)
{
    delete reinterpret_cast< ::QSslError *>(sipCppV);
}


extern "C" {static void assign_QSslError(void *, SIP_SSIZE_T, void *);}
static void assign_QSslError(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QSslError *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QSslError *>(sipSrc);
}


extern "C" {static void *array_QSslError(SIP_SSIZE_T);}
static void *array_QSslError(SIP_SSIZE_T sipNrElem)
{
    return new  ::QSslError[sipNrElem];
}


extern "C" {static void *copy_QSslError(const void *, SIP_SSIZE_T);}
static void *copy_QSslError(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QSslError(reinterpret_cast<const  ::QSslError *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QSslError(sipSimpleWrapper *);}
static void dealloc_QSslError(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSslError(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QSslError(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSslError(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QSslError *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new  ::QSslError();

            return sipCpp;
        }
    }

    {
         ::QSslError::SslError a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "E", sipType_QSslError_SslError, &a0))
        {
            sipCpp = new  ::QSslError(a0);

            return sipCpp;
        }
    }

    {
         ::QSslError::SslError a0;
        const  ::QSslCertificate* a1;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "EJ9", sipType_QSslError_SslError, &a0, sipType_QSslCertificate, &a1))
        {
            sipCpp = new  ::QSslError(a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::QSslError* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QSslError, &a0))
        {
            sipCpp = new  ::QSslError(*a0);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QSslError[] = {
    {(void *)slot_QSslError___hash__, hash_slot},
    {(void *)slot_QSslError___ne__, ne_slot},
    {(void *)slot_QSslError___eq__, eq_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_QSslError[] = {
    {SIP_MLNAME_CAST(sipName_certificate), meth_QSslError_certificate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslError_certificate)},
    {SIP_MLNAME_CAST(sipName_error), meth_QSslError_error, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslError_error)},
    {SIP_MLNAME_CAST(sipName_errorString), meth_QSslError_errorString, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslError_errorString)},
    {SIP_MLNAME_CAST(sipName_swap), meth_QSslError_swap, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslError_swap)}
};

static sipEnumMemberDef enummembers_QSslError[] = {
    {sipName_AuthorityIssuerSerialNumberMismatch, static_cast<int>( ::QSslError::AuthorityIssuerSerialNumberMismatch), 122},
    {sipName_CertificateBlacklisted, static_cast<int>( ::QSslError::CertificateBlacklisted), 122},
    {sipName_CertificateExpired, static_cast<int>( ::QSslError::CertificateExpired), 122},
    {sipName_CertificateNotYetValid, static_cast<int>( ::QSslError::CertificateNotYetValid), 122},
    {sipName_CertificateRejected, static_cast<int>( ::QSslError::CertificateRejected), 122},
    {sipName_CertificateRevoked, static_cast<int>( ::QSslError::CertificateRevoked), 122},
    {sipName_CertificateSignatureFailed, static_cast<int>( ::QSslError::CertificateSignatureFailed), 122},
    {sipName_CertificateUntrusted, static_cast<int>( ::QSslError::CertificateUntrusted), 122},
    {sipName_HostNameMismatch, static_cast<int>( ::QSslError::HostNameMismatch), 122},
    {sipName_InvalidCaCertificate, static_cast<int>( ::QSslError::InvalidCaCertificate), 122},
    {sipName_InvalidNotAfterField, static_cast<int>( ::QSslError::InvalidNotAfterField), 122},
    {sipName_InvalidNotBeforeField, static_cast<int>( ::QSslError::InvalidNotBeforeField), 122},
    {sipName_InvalidPurpose, static_cast<int>( ::QSslError::InvalidPurpose), 122},
    {sipName_NoError, static_cast<int>( ::QSslError::NoError), 122},
    {sipName_NoPeerCertificate, static_cast<int>( ::QSslError::NoPeerCertificate), 122},
    {sipName_NoSslSupport, static_cast<int>( ::QSslError::NoSslSupport), 122},
    {sipName_PathLengthExceeded, static_cast<int>( ::QSslError::PathLengthExceeded), 122},
    {sipName_SelfSignedCertificate, static_cast<int>( ::QSslError::SelfSignedCertificate), 122},
    {sipName_SelfSignedCertificateInChain, static_cast<int>( ::QSslError::SelfSignedCertificateInChain), 122},
    {sipName_SubjectIssuerMismatch, static_cast<int>( ::QSslError::SubjectIssuerMismatch), 122},
    {sipName_UnableToDecodeIssuerPublicKey, static_cast<int>( ::QSslError::UnableToDecodeIssuerPublicKey), 122},
    {sipName_UnableToDecryptCertificateSignature, static_cast<int>( ::QSslError::UnableToDecryptCertificateSignature), 122},
    {sipName_UnableToGetIssuerCertificate, static_cast<int>( ::QSslError::UnableToGetIssuerCertificate), 122},
    {sipName_UnableToGetLocalIssuerCertificate, static_cast<int>( ::QSslError::UnableToGetLocalIssuerCertificate), 122},
    {sipName_UnableToVerifyFirstCertificate, static_cast<int>( ::QSslError::UnableToVerifyFirstCertificate), 122},
    {sipName_UnspecifiedError, static_cast<int>( ::QSslError::UnspecifiedError), 122},
};

PyDoc_STRVAR(doc_QSslError, "\1QSslError()\n"
"QSslError(QSslError.SslError)\n"
"QSslError(QSslError.SslError, QSslCertificate)\n"
"QSslError(QSslError)");


static pyqt5ClassPluginDef plugin_QSslError = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSslError = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSslError,
        {SIP_NULLPTR},
        &plugin_QSslError
    },
    {
        sipNameNr_QSslError,
        {0, 0, 1},
        4, methods_QSslError,
        26, enummembers_QSslError,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSslError,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    slots_QSslError,
    init_type_QSslError,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSslError,
    assign_QSslError,
    array_QSslError,
    copy_QSslError,
    release_QSslError,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslellipticcurve.sip"
#include <qsslellipticcurve.h>
#line 14485 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 14489 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


PyDoc_STRVAR(doc_QSslEllipticCurve_fromShortName, "fromShortName(str) -> QSslEllipticCurve");

extern "C" {static PyObject *meth_QSslEllipticCurve_fromShortName(PyObject *, PyObject *);}
static PyObject *meth_QSslEllipticCurve_fromShortName(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QString* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_QString,&a0, &a0State))
        {
             ::QSslEllipticCurve*sipRes;

            sipRes = new  ::QSslEllipticCurve( ::QSslEllipticCurve::fromShortName(*a0));
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return sipConvertFromNewType(sipRes,sipType_QSslEllipticCurve,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslEllipticCurve, sipName_fromShortName, doc_QSslEllipticCurve_fromShortName);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslEllipticCurve_fromLongName, "fromLongName(str) -> QSslEllipticCurve");

extern "C" {static PyObject *meth_QSslEllipticCurve_fromLongName(PyObject *, PyObject *);}
static PyObject *meth_QSslEllipticCurve_fromLongName(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QString* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_QString,&a0, &a0State))
        {
             ::QSslEllipticCurve*sipRes;

            sipRes = new  ::QSslEllipticCurve( ::QSslEllipticCurve::fromLongName(*a0));
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return sipConvertFromNewType(sipRes,sipType_QSslEllipticCurve,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslEllipticCurve, sipName_fromLongName, doc_QSslEllipticCurve_fromLongName);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslEllipticCurve_shortName, "shortName(self) -> str");

extern "C" {static PyObject *meth_QSslEllipticCurve_shortName(PyObject *, PyObject *);}
static PyObject *meth_QSslEllipticCurve_shortName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslEllipticCurve *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslEllipticCurve, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->shortName());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslEllipticCurve, sipName_shortName, doc_QSslEllipticCurve_shortName);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslEllipticCurve_longName, "longName(self) -> str");

extern "C" {static PyObject *meth_QSslEllipticCurve_longName(PyObject *, PyObject *);}
static PyObject *meth_QSslEllipticCurve_longName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslEllipticCurve *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslEllipticCurve, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->longName());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslEllipticCurve, sipName_longName, doc_QSslEllipticCurve_longName);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslEllipticCurve_isValid, "isValid(self) -> bool");

extern "C" {static PyObject *meth_QSslEllipticCurve_isValid(PyObject *, PyObject *);}
static PyObject *meth_QSslEllipticCurve_isValid(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslEllipticCurve *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslEllipticCurve, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isValid();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslEllipticCurve, sipName_isValid, doc_QSslEllipticCurve_isValid);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslEllipticCurve_isTlsNamedCurve, "isTlsNamedCurve(self) -> bool");

extern "C" {static PyObject *meth_QSslEllipticCurve_isTlsNamedCurve(PyObject *, PyObject *);}
static PyObject *meth_QSslEllipticCurve_isTlsNamedCurve(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslEllipticCurve *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslEllipticCurve, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isTlsNamedCurve();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslEllipticCurve, sipName_isTlsNamedCurve, doc_QSslEllipticCurve_isTlsNamedCurve);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *slot_QSslEllipticCurve___eq__(PyObject *,PyObject *);}
static PyObject *slot_QSslEllipticCurve___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslEllipticCurve *sipCpp = reinterpret_cast< ::QSslEllipticCurve *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslEllipticCurve));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslEllipticCurve* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslEllipticCurve, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, eq_slot, sipType_QSslEllipticCurve, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QSslEllipticCurve___ne__(PyObject *,PyObject *);}
static PyObject *slot_QSslEllipticCurve___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslEllipticCurve *sipCpp = reinterpret_cast< ::QSslEllipticCurve *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslEllipticCurve));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslEllipticCurve* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslEllipticCurve, &a0))
        {
            bool sipRes;

            sipRes = operator!=((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, ne_slot, sipType_QSslEllipticCurve, sipSelf, sipArg);
}


extern "C" {static long slot_QSslEllipticCurve___hash__(PyObject *);}
static long slot_QSslEllipticCurve___hash__(PyObject *sipSelf)
{
     ::QSslEllipticCurve *sipCpp = reinterpret_cast< ::QSslEllipticCurve *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslEllipticCurve));

    if (!sipCpp)
        return 0L;


    {
        {
            long sipRes = 0;

#line 42 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslellipticcurve.sip"
        sipRes = qHash(*sipCpp);
#line 14743 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            return sipRes;
        }
    }

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_QSslEllipticCurve(void *, int);}
static void release_QSslEllipticCurve(void *sipCppV, int)
{
    delete reinterpret_cast< ::QSslEllipticCurve *>(sipCppV);
}


extern "C" {static void assign_QSslEllipticCurve(void *, SIP_SSIZE_T, void *);}
static void assign_QSslEllipticCurve(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QSslEllipticCurve *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QSslEllipticCurve *>(sipSrc);
}


extern "C" {static void *array_QSslEllipticCurve(SIP_SSIZE_T);}
static void *array_QSslEllipticCurve(SIP_SSIZE_T sipNrElem)
{
    return new  ::QSslEllipticCurve[sipNrElem];
}


extern "C" {static void *copy_QSslEllipticCurve(const void *, SIP_SSIZE_T);}
static void *copy_QSslEllipticCurve(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QSslEllipticCurve(reinterpret_cast<const  ::QSslEllipticCurve *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QSslEllipticCurve(sipSimpleWrapper *);}
static void dealloc_QSslEllipticCurve(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSslEllipticCurve(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QSslEllipticCurve(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSslEllipticCurve(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QSslEllipticCurve *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new  ::QSslEllipticCurve();

            return sipCpp;
        }
    }

    {
        const  ::QSslEllipticCurve* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QSslEllipticCurve, &a0))
        {
            sipCpp = new  ::QSslEllipticCurve(*a0);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QSslEllipticCurve[] = {
    {(void *)slot_QSslEllipticCurve___eq__, eq_slot},
    {(void *)slot_QSslEllipticCurve___ne__, ne_slot},
    {(void *)slot_QSslEllipticCurve___hash__, hash_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_QSslEllipticCurve[] = {
    {SIP_MLNAME_CAST(sipName_fromLongName), meth_QSslEllipticCurve_fromLongName, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslEllipticCurve_fromLongName)},
    {SIP_MLNAME_CAST(sipName_fromShortName), meth_QSslEllipticCurve_fromShortName, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslEllipticCurve_fromShortName)},
    {SIP_MLNAME_CAST(sipName_isTlsNamedCurve), meth_QSslEllipticCurve_isTlsNamedCurve, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslEllipticCurve_isTlsNamedCurve)},
    {SIP_MLNAME_CAST(sipName_isValid), meth_QSslEllipticCurve_isValid, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslEllipticCurve_isValid)},
    {SIP_MLNAME_CAST(sipName_longName), meth_QSslEllipticCurve_longName, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslEllipticCurve_longName)},
    {SIP_MLNAME_CAST(sipName_shortName), meth_QSslEllipticCurve_shortName, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslEllipticCurve_shortName)}
};

PyDoc_STRVAR(doc_QSslEllipticCurve, "\1QSslEllipticCurve()\n"
"QSslEllipticCurve(QSslEllipticCurve)");


static pyqt5ClassPluginDef plugin_QSslEllipticCurve = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSslEllipticCurve = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSslEllipticCurve,
        {SIP_NULLPTR},
        &plugin_QSslEllipticCurve
    },
    {
        sipNameNr_QSslEllipticCurve,
        {0, 0, 1},
        6, methods_QSslEllipticCurve,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSslEllipticCurve,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    slots_QSslEllipticCurve,
    init_type_QSslEllipticCurve,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSslEllipticCurve,
    assign_QSslEllipticCurve,
    array_QSslEllipticCurve,
    copy_QSslEllipticCurve,
    release_QSslEllipticCurve,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssldiffiehellmanparameters.sip"
#include <qssldiffiehellmanparameters.h>
#line 14904 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 14908 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 14911 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 14914 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qiodevice.sip"
#include <qiodevice.h>
#line 14917 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


PyDoc_STRVAR(doc_QSslDiffieHellmanParameters_swap, "swap(self, QSslDiffieHellmanParameters)");

extern "C" {static PyObject *meth_QSslDiffieHellmanParameters_swap(PyObject *, PyObject *);}
static PyObject *meth_QSslDiffieHellmanParameters_swap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslDiffieHellmanParameters* a0;
         ::QSslDiffieHellmanParameters *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslDiffieHellmanParameters, &sipCpp, sipType_QSslDiffieHellmanParameters, &a0))
        {
            sipCpp->swap(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslDiffieHellmanParameters, sipName_swap, doc_QSslDiffieHellmanParameters_swap);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslDiffieHellmanParameters_defaultParameters, "defaultParameters() -> QSslDiffieHellmanParameters");

extern "C" {static PyObject *meth_QSslDiffieHellmanParameters_defaultParameters(PyObject *, PyObject *);}
static PyObject *meth_QSslDiffieHellmanParameters_defaultParameters(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::QSslDiffieHellmanParameters*sipRes;

            sipRes = new  ::QSslDiffieHellmanParameters( ::QSslDiffieHellmanParameters::defaultParameters());

            return sipConvertFromNewType(sipRes,sipType_QSslDiffieHellmanParameters,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslDiffieHellmanParameters, sipName_defaultParameters, doc_QSslDiffieHellmanParameters_defaultParameters);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslDiffieHellmanParameters_fromEncoded, "fromEncoded(Union[QByteArray, bytes, bytearray], encoding: QSsl.EncodingFormat = QSsl.EncodingFormat.Pem) -> QSslDiffieHellmanParameters\n"
"fromEncoded(QIODevice, encoding: QSsl.EncodingFormat = QSsl.EncodingFormat.Pem) -> QSslDiffieHellmanParameters");

extern "C" {static PyObject *meth_QSslDiffieHellmanParameters_fromEncoded(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslDiffieHellmanParameters_fromEncoded(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray* a0;
        int a0State = 0;
         ::QSsl::EncodingFormat a1 = QSsl::EncodingFormat::Pem;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_encoding,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1|E", sipType_QByteArray, &a0, &a0State, sipType_QSsl_EncodingFormat, &a1))
        {
             ::QSslDiffieHellmanParameters*sipRes;

            sipRes = new  ::QSslDiffieHellmanParameters( ::QSslDiffieHellmanParameters::fromEncoded(*a0,a1));
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            return sipConvertFromNewType(sipRes,sipType_QSslDiffieHellmanParameters,SIP_NULLPTR);
        }
    }

    {
         ::QIODevice* a0;
         ::QSsl::EncodingFormat a1 = QSsl::EncodingFormat::Pem;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_encoding,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J8|E", sipType_QIODevice, &a0, sipType_QSsl_EncodingFormat, &a1))
        {
             ::QSslDiffieHellmanParameters*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::QSslDiffieHellmanParameters( ::QSslDiffieHellmanParameters::fromEncoded(a0,a1));
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QSslDiffieHellmanParameters,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslDiffieHellmanParameters, sipName_fromEncoded, doc_QSslDiffieHellmanParameters_fromEncoded);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslDiffieHellmanParameters_isEmpty, "isEmpty(self) -> bool");

extern "C" {static PyObject *meth_QSslDiffieHellmanParameters_isEmpty(PyObject *, PyObject *);}
static PyObject *meth_QSslDiffieHellmanParameters_isEmpty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslDiffieHellmanParameters *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslDiffieHellmanParameters, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isEmpty();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslDiffieHellmanParameters, sipName_isEmpty, doc_QSslDiffieHellmanParameters_isEmpty);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslDiffieHellmanParameters_isValid, "isValid(self) -> bool");

extern "C" {static PyObject *meth_QSslDiffieHellmanParameters_isValid(PyObject *, PyObject *);}
static PyObject *meth_QSslDiffieHellmanParameters_isValid(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslDiffieHellmanParameters *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslDiffieHellmanParameters, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isValid();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslDiffieHellmanParameters, sipName_isValid, doc_QSslDiffieHellmanParameters_isValid);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslDiffieHellmanParameters_error, "error(self) -> QSslDiffieHellmanParameters.Error");

extern "C" {static PyObject *meth_QSslDiffieHellmanParameters_error(PyObject *, PyObject *);}
static PyObject *meth_QSslDiffieHellmanParameters_error(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslDiffieHellmanParameters *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslDiffieHellmanParameters, &sipCpp))
        {
             ::QSslDiffieHellmanParameters::Error sipRes;

            sipRes = sipCpp->error();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSslDiffieHellmanParameters_Error);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslDiffieHellmanParameters, sipName_error, doc_QSslDiffieHellmanParameters_error);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslDiffieHellmanParameters_errorString, "errorString(self) -> str");

extern "C" {static PyObject *meth_QSslDiffieHellmanParameters_errorString(PyObject *, PyObject *);}
static PyObject *meth_QSslDiffieHellmanParameters_errorString(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslDiffieHellmanParameters *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslDiffieHellmanParameters, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->errorString());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslDiffieHellmanParameters, sipName_errorString, doc_QSslDiffieHellmanParameters_errorString);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *slot_QSslDiffieHellmanParameters___eq__(PyObject *,PyObject *);}
static PyObject *slot_QSslDiffieHellmanParameters___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslDiffieHellmanParameters *sipCpp = reinterpret_cast< ::QSslDiffieHellmanParameters *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslDiffieHellmanParameters));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslDiffieHellmanParameters* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslDiffieHellmanParameters, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, eq_slot, sipType_QSslDiffieHellmanParameters, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QSslDiffieHellmanParameters___ne__(PyObject *,PyObject *);}
static PyObject *slot_QSslDiffieHellmanParameters___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslDiffieHellmanParameters *sipCpp = reinterpret_cast< ::QSslDiffieHellmanParameters *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslDiffieHellmanParameters));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslDiffieHellmanParameters* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslDiffieHellmanParameters, &a0))
        {
            bool sipRes;

            sipRes = operator!=((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, ne_slot, sipType_QSslDiffieHellmanParameters, sipSelf, sipArg);
}


extern "C" {static long slot_QSslDiffieHellmanParameters___hash__(PyObject *);}
static long slot_QSslDiffieHellmanParameters___hash__(PyObject *sipSelf)
{
     ::QSslDiffieHellmanParameters *sipCpp = reinterpret_cast< ::QSslDiffieHellmanParameters *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslDiffieHellmanParameters));

    if (!sipCpp)
        return 0L;


    {
        {
            long sipRes = 0;

#line 53 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssldiffiehellmanparameters.sip"
        sipRes = qHash(*sipCpp);
#line 15224 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            return sipRes;
        }
    }

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_QSslDiffieHellmanParameters(void *, int);}
static void release_QSslDiffieHellmanParameters(void *sipCppV, int)
{
    delete reinterpret_cast< ::QSslDiffieHellmanParameters *>(sipCppV);
}


extern "C" {static void assign_QSslDiffieHellmanParameters(void *, SIP_SSIZE_T, void *);}
static void assign_QSslDiffieHellmanParameters(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QSslDiffieHellmanParameters *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QSslDiffieHellmanParameters *>(sipSrc);
}


extern "C" {static void *array_QSslDiffieHellmanParameters(SIP_SSIZE_T);}
static void *array_QSslDiffieHellmanParameters(SIP_SSIZE_T sipNrElem)
{
    return new  ::QSslDiffieHellmanParameters[sipNrElem];
}


extern "C" {static void *copy_QSslDiffieHellmanParameters(const void *, SIP_SSIZE_T);}
static void *copy_QSslDiffieHellmanParameters(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QSslDiffieHellmanParameters(reinterpret_cast<const  ::QSslDiffieHellmanParameters *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QSslDiffieHellmanParameters(sipSimpleWrapper *);}
static void dealloc_QSslDiffieHellmanParameters(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSslDiffieHellmanParameters(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QSslDiffieHellmanParameters(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSslDiffieHellmanParameters(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QSslDiffieHellmanParameters *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new  ::QSslDiffieHellmanParameters();

            return sipCpp;
        }
    }

    {
        const  ::QSslDiffieHellmanParameters* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QSslDiffieHellmanParameters, &a0))
        {
            sipCpp = new  ::QSslDiffieHellmanParameters(*a0);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QSslDiffieHellmanParameters[] = {
    {(void *)slot_QSslDiffieHellmanParameters___eq__, eq_slot},
    {(void *)slot_QSslDiffieHellmanParameters___ne__, ne_slot},
    {(void *)slot_QSslDiffieHellmanParameters___hash__, hash_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_QSslDiffieHellmanParameters[] = {
    {SIP_MLNAME_CAST(sipName_defaultParameters), meth_QSslDiffieHellmanParameters_defaultParameters, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslDiffieHellmanParameters_defaultParameters)},
    {SIP_MLNAME_CAST(sipName_error), meth_QSslDiffieHellmanParameters_error, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslDiffieHellmanParameters_error)},
    {SIP_MLNAME_CAST(sipName_errorString), meth_QSslDiffieHellmanParameters_errorString, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslDiffieHellmanParameters_errorString)},
    {SIP_MLNAME_CAST(sipName_fromEncoded), SIP_MLMETH_CAST(meth_QSslDiffieHellmanParameters_fromEncoded), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslDiffieHellmanParameters_fromEncoded)},
    {SIP_MLNAME_CAST(sipName_isEmpty), meth_QSslDiffieHellmanParameters_isEmpty, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslDiffieHellmanParameters_isEmpty)},
    {SIP_MLNAME_CAST(sipName_isValid), meth_QSslDiffieHellmanParameters_isValid, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslDiffieHellmanParameters_isValid)},
    {SIP_MLNAME_CAST(sipName_swap), meth_QSslDiffieHellmanParameters_swap, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslDiffieHellmanParameters_swap)}
};

static sipEnumMemberDef enummembers_QSslDiffieHellmanParameters[] = {
    {sipName_InvalidInputDataError, static_cast<int>( ::QSslDiffieHellmanParameters::InvalidInputDataError), 119},
    {sipName_NoError, static_cast<int>( ::QSslDiffieHellmanParameters::NoError), 119},
    {sipName_UnsafeParametersError, static_cast<int>( ::QSslDiffieHellmanParameters::UnsafeParametersError), 119},
};

PyDoc_STRVAR(doc_QSslDiffieHellmanParameters, "\1QSslDiffieHellmanParameters()\n"
"QSslDiffieHellmanParameters(QSslDiffieHellmanParameters)");


static pyqt5ClassPluginDef plugin_QSslDiffieHellmanParameters = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSslDiffieHellmanParameters = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSslDiffieHellmanParameters,
        {SIP_NULLPTR},
        &plugin_QSslDiffieHellmanParameters
    },
    {
        sipNameNr_QSslDiffieHellmanParameters,
        {0, 0, 1},
        7, methods_QSslDiffieHellmanParameters,
        3, enummembers_QSslDiffieHellmanParameters,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSslDiffieHellmanParameters,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    slots_QSslDiffieHellmanParameters,
    init_type_QSslDiffieHellmanParameters,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSslDiffieHellmanParameters,
    assign_QSslDiffieHellmanParameters,
    array_QSslDiffieHellmanParameters,
    copy_QSslDiffieHellmanParameters,
    release_QSslDiffieHellmanParameters,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslconfiguration.sip"
#include <qsslconfiguration.h>
#line 15392 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 27 "sip/QtCore/qpycore_qmap.sip"
#include <qmap.h>
#line 15396 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 15399 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 15402 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssldiffiehellmanparameters.sip"
#include <qssldiffiehellmanparameters.h>
#line 15405 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslkey.sip"
#include <qsslkey.h>
#line 15408 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "sip/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 15411 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslellipticcurve.sip"
#include <qsslellipticcurve.h>
#line 15414 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 15417 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcertificate.sip"
#include <qsslcertificate.h>
#line 15420 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 15423 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcipher.sip"
#include <qsslcipher.h>
#line 15426 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 15429 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 15432 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslsocket.sip"
#include <qsslsocket.h>
#line 15435 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


PyDoc_STRVAR(doc_QSslConfiguration_isNull, "isNull(self) -> bool");

extern "C" {static PyObject *meth_QSslConfiguration_isNull(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_isNull(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isNull();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_isNull, doc_QSslConfiguration_isNull);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_protocol, "protocol(self) -> QSsl.SslProtocol");

extern "C" {static PyObject *meth_QSslConfiguration_protocol(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_protocol(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QSsl::SslProtocol sipRes;

            sipRes = sipCpp->protocol();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSsl_SslProtocol);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_protocol, doc_QSslConfiguration_protocol);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setProtocol, "setProtocol(self, QSsl.SslProtocol)");

extern "C" {static PyObject *meth_QSslConfiguration_setProtocol(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setProtocol(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSsl::SslProtocol a0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QSsl_SslProtocol, &a0))
        {
            sipCpp->setProtocol(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setProtocol, doc_QSslConfiguration_setProtocol);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_peerVerifyMode, "peerVerifyMode(self) -> QSslSocket.PeerVerifyMode");

extern "C" {static PyObject *meth_QSslConfiguration_peerVerifyMode(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_peerVerifyMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QSslSocket::PeerVerifyMode sipRes;

            sipRes = sipCpp->peerVerifyMode();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSslSocket_PeerVerifyMode);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_peerVerifyMode, doc_QSslConfiguration_peerVerifyMode);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setPeerVerifyMode, "setPeerVerifyMode(self, QSslSocket.PeerVerifyMode)");

extern "C" {static PyObject *meth_QSslConfiguration_setPeerVerifyMode(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setPeerVerifyMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslSocket::PeerVerifyMode a0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QSslSocket_PeerVerifyMode, &a0))
        {
            sipCpp->setPeerVerifyMode(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setPeerVerifyMode, doc_QSslConfiguration_setPeerVerifyMode);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_peerVerifyDepth, "peerVerifyDepth(self) -> int");

extern "C" {static PyObject *meth_QSslConfiguration_peerVerifyDepth(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_peerVerifyDepth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->peerVerifyDepth();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_peerVerifyDepth, doc_QSslConfiguration_peerVerifyDepth);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setPeerVerifyDepth, "setPeerVerifyDepth(self, int)");

extern "C" {static PyObject *meth_QSslConfiguration_setPeerVerifyDepth(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setPeerVerifyDepth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QSslConfiguration, &sipCpp, &a0))
        {
            sipCpp->setPeerVerifyDepth(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setPeerVerifyDepth, doc_QSslConfiguration_setPeerVerifyDepth);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_localCertificate, "localCertificate(self) -> QSslCertificate");

extern "C" {static PyObject *meth_QSslConfiguration_localCertificate(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_localCertificate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QSslCertificate*sipRes;

            sipRes = new  ::QSslCertificate(sipCpp->localCertificate());

            return sipConvertFromNewType(sipRes,sipType_QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_localCertificate, doc_QSslConfiguration_localCertificate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setLocalCertificate, "setLocalCertificate(self, QSslCertificate)");

extern "C" {static PyObject *meth_QSslConfiguration_setLocalCertificate(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setLocalCertificate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate* a0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QSslCertificate, &a0))
        {
            sipCpp->setLocalCertificate(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setLocalCertificate, doc_QSslConfiguration_setLocalCertificate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_peerCertificate, "peerCertificate(self) -> QSslCertificate");

extern "C" {static PyObject *meth_QSslConfiguration_peerCertificate(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_peerCertificate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QSslCertificate*sipRes;

            sipRes = new  ::QSslCertificate(sipCpp->peerCertificate());

            return sipConvertFromNewType(sipRes,sipType_QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_peerCertificate, doc_QSslConfiguration_peerCertificate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_peerCertificateChain, "peerCertificateChain(self) -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslConfiguration_peerCertificateChain(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_peerCertificateChain(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>(sipCpp->peerCertificateChain());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_peerCertificateChain, doc_QSslConfiguration_peerCertificateChain);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_sessionCipher, "sessionCipher(self) -> QSslCipher");

extern "C" {static PyObject *meth_QSslConfiguration_sessionCipher(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_sessionCipher(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QSslCipher*sipRes;

            sipRes = new  ::QSslCipher(sipCpp->sessionCipher());

            return sipConvertFromNewType(sipRes,sipType_QSslCipher,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_sessionCipher, doc_QSslConfiguration_sessionCipher);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_privateKey, "privateKey(self) -> QSslKey");

extern "C" {static PyObject *meth_QSslConfiguration_privateKey(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_privateKey(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QSslKey*sipRes;

            sipRes = new  ::QSslKey(sipCpp->privateKey());

            return sipConvertFromNewType(sipRes,sipType_QSslKey,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_privateKey, doc_QSslConfiguration_privateKey);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setPrivateKey, "setPrivateKey(self, QSslKey)");

extern "C" {static PyObject *meth_QSslConfiguration_setPrivateKey(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setPrivateKey(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslKey* a0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QSslKey, &a0))
        {
            sipCpp->setPrivateKey(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setPrivateKey, doc_QSslConfiguration_setPrivateKey);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_ciphers, "ciphers(self) -> List[QSslCipher]");

extern "C" {static PyObject *meth_QSslConfiguration_ciphers(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_ciphers(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
            QList< ::QSslCipher>*sipRes;

            sipRes = new QList< ::QSslCipher>(sipCpp->ciphers());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCipher,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_ciphers, doc_QSslConfiguration_ciphers);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setCiphers, "setCiphers(self, Iterable[QSslCipher])");

extern "C" {static PyObject *meth_QSslConfiguration_setCiphers(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setCiphers(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const QList< ::QSslCipher>* a0;
        int a0State = 0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QList_0100QSslCipher,&a0, &a0State))
        {
            sipCpp->setCiphers(*a0);
            sipReleaseType(const_cast<QList< ::QSslCipher> *>(a0),sipType_QList_0100QSslCipher,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setCiphers, doc_QSslConfiguration_setCiphers);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_caCertificates, "caCertificates(self) -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslConfiguration_caCertificates(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_caCertificates(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>(sipCpp->caCertificates());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_caCertificates, doc_QSslConfiguration_caCertificates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setCaCertificates, "setCaCertificates(self, Iterable[QSslCertificate])");

extern "C" {static PyObject *meth_QSslConfiguration_setCaCertificates(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setCaCertificates(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const QList< ::QSslCertificate>* a0;
        int a0State = 0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QList_0100QSslCertificate,&a0, &a0State))
        {
            sipCpp->setCaCertificates(*a0);
            sipReleaseType(const_cast<QList< ::QSslCertificate> *>(a0),sipType_QList_0100QSslCertificate,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setCaCertificates, doc_QSslConfiguration_setCaCertificates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_defaultConfiguration, "defaultConfiguration() -> QSslConfiguration");

extern "C" {static PyObject *meth_QSslConfiguration_defaultConfiguration(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_defaultConfiguration(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::QSslConfiguration*sipRes;

            sipRes = new  ::QSslConfiguration( ::QSslConfiguration::defaultConfiguration());

            return sipConvertFromNewType(sipRes,sipType_QSslConfiguration,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_defaultConfiguration, doc_QSslConfiguration_defaultConfiguration);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setDefaultConfiguration, "setDefaultConfiguration(QSslConfiguration)");

extern "C" {static PyObject *meth_QSslConfiguration_setDefaultConfiguration(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setDefaultConfiguration(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration* a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_QSslConfiguration, &a0))
        {
             ::QSslConfiguration::setDefaultConfiguration(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setDefaultConfiguration, doc_QSslConfiguration_setDefaultConfiguration);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setSslOption, "setSslOption(self, QSsl.SslOption, bool)");

extern "C" {static PyObject *meth_QSslConfiguration_setSslOption(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setSslOption(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSsl::SslOption a0;
        bool a1;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BEb", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QSsl_SslOption, &a0, &a1))
        {
            sipCpp->setSslOption(a0,a1);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setSslOption, doc_QSslConfiguration_setSslOption);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_testSslOption, "testSslOption(self, QSsl.SslOption) -> bool");

extern "C" {static PyObject *meth_QSslConfiguration_testSslOption(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_testSslOption(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSsl::SslOption a0;
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QSsl_SslOption, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->testSslOption(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_testSslOption, doc_QSslConfiguration_testSslOption);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_swap, "swap(self, QSslConfiguration)");

extern "C" {static PyObject *meth_QSslConfiguration_swap(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_swap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslConfiguration* a0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QSslConfiguration, &a0))
        {
            sipCpp->swap(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_swap, doc_QSslConfiguration_swap);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_localCertificateChain, "localCertificateChain(self) -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslConfiguration_localCertificateChain(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_localCertificateChain(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>(sipCpp->localCertificateChain());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_localCertificateChain, doc_QSslConfiguration_localCertificateChain);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setLocalCertificateChain, "setLocalCertificateChain(self, Iterable[QSslCertificate])");

extern "C" {static PyObject *meth_QSslConfiguration_setLocalCertificateChain(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setLocalCertificateChain(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const QList< ::QSslCertificate>* a0;
        int a0State = 0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QList_0100QSslCertificate,&a0, &a0State))
        {
            sipCpp->setLocalCertificateChain(*a0);
            sipReleaseType(const_cast<QList< ::QSslCertificate> *>(a0),sipType_QList_0100QSslCertificate,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setLocalCertificateChain, doc_QSslConfiguration_setLocalCertificateChain);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_sessionTicket, "sessionTicket(self) -> QByteArray");

extern "C" {static PyObject *meth_QSslConfiguration_sessionTicket(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_sessionTicket(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->sessionTicket());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_sessionTicket, doc_QSslConfiguration_sessionTicket);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setSessionTicket, "setSessionTicket(self, Union[QByteArray, bytes, bytearray])");

extern "C" {static PyObject *meth_QSslConfiguration_setSessionTicket(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setSessionTicket(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray* a0;
        int a0State = 0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QByteArray, &a0, &a0State))
        {
            sipCpp->setSessionTicket(*a0);
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setSessionTicket, doc_QSslConfiguration_setSessionTicket);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_sessionTicketLifeTimeHint, "sessionTicketLifeTimeHint(self) -> int");

extern "C" {static PyObject *meth_QSslConfiguration_sessionTicketLifeTimeHint(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_sessionTicketLifeTimeHint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->sessionTicketLifeTimeHint();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_sessionTicketLifeTimeHint, doc_QSslConfiguration_sessionTicketLifeTimeHint);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setAllowedNextProtocols, "setAllowedNextProtocols(self, Iterable[Union[QByteArray, bytes, bytearray]])");

extern "C" {static PyObject *meth_QSslConfiguration_setAllowedNextProtocols(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setAllowedNextProtocols(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        QList< ::QByteArray>* a0;
        int a0State = 0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QList_0100QByteArray,&a0, &a0State))
        {
            sipCpp->setAllowedNextProtocols(*a0);
            sipReleaseType(a0,sipType_QList_0100QByteArray,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setAllowedNextProtocols, doc_QSslConfiguration_setAllowedNextProtocols);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_allowedNextProtocols, "allowedNextProtocols(self) -> List[QByteArray]");

extern "C" {static PyObject *meth_QSslConfiguration_allowedNextProtocols(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_allowedNextProtocols(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
            QList< ::QByteArray>*sipRes;

            sipRes = new QList< ::QByteArray>(sipCpp->allowedNextProtocols());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_allowedNextProtocols, doc_QSslConfiguration_allowedNextProtocols);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_nextNegotiatedProtocol, "nextNegotiatedProtocol(self) -> QByteArray");

extern "C" {static PyObject *meth_QSslConfiguration_nextNegotiatedProtocol(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_nextNegotiatedProtocol(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->nextNegotiatedProtocol());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_nextNegotiatedProtocol, doc_QSslConfiguration_nextNegotiatedProtocol);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_nextProtocolNegotiationStatus, "nextProtocolNegotiationStatus(self) -> QSslConfiguration.NextProtocolNegotiationStatus");

extern "C" {static PyObject *meth_QSslConfiguration_nextProtocolNegotiationStatus(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_nextProtocolNegotiationStatus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QSslConfiguration::NextProtocolNegotiationStatus sipRes;

            sipRes = sipCpp->nextProtocolNegotiationStatus();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSslConfiguration_NextProtocolNegotiationStatus);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_nextProtocolNegotiationStatus, doc_QSslConfiguration_nextProtocolNegotiationStatus);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_sessionProtocol, "sessionProtocol(self) -> QSsl.SslProtocol");

extern "C" {static PyObject *meth_QSslConfiguration_sessionProtocol(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_sessionProtocol(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QSsl::SslProtocol sipRes;

            sipRes = sipCpp->sessionProtocol();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSsl_SslProtocol);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_sessionProtocol, doc_QSslConfiguration_sessionProtocol);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_supportedCiphers, "supportedCiphers() -> List[QSslCipher]");

extern "C" {static PyObject *meth_QSslConfiguration_supportedCiphers(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_supportedCiphers(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            QList< ::QSslCipher>*sipRes;

            sipRes = new QList< ::QSslCipher>( ::QSslConfiguration::supportedCiphers());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCipher,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_supportedCiphers, doc_QSslConfiguration_supportedCiphers);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_systemCaCertificates, "systemCaCertificates() -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslConfiguration_systemCaCertificates(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_systemCaCertificates(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>( ::QSslConfiguration::systemCaCertificates());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_systemCaCertificates, doc_QSslConfiguration_systemCaCertificates);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_ellipticCurves, "ellipticCurves(self) -> List[QSslEllipticCurve]");

extern "C" {static PyObject *meth_QSslConfiguration_ellipticCurves(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_ellipticCurves(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
            QVector< ::QSslEllipticCurve>*sipRes;

            sipRes = new QVector< ::QSslEllipticCurve>(sipCpp->ellipticCurves());

            return sipConvertFromNewType(sipRes,sipType_QVector_0100QSslEllipticCurve,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_ellipticCurves, doc_QSslConfiguration_ellipticCurves);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setEllipticCurves, "setEllipticCurves(self, Iterable[QSslEllipticCurve])");

extern "C" {static PyObject *meth_QSslConfiguration_setEllipticCurves(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setEllipticCurves(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const QVector< ::QSslEllipticCurve>* a0;
        int a0State = 0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QVector_0100QSslEllipticCurve,&a0, &a0State))
        {
            sipCpp->setEllipticCurves(*a0);
            sipReleaseType(const_cast<QVector< ::QSslEllipticCurve> *>(a0),sipType_QVector_0100QSslEllipticCurve,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setEllipticCurves, doc_QSslConfiguration_setEllipticCurves);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_supportedEllipticCurves, "supportedEllipticCurves() -> List[QSslEllipticCurve]");

extern "C" {static PyObject *meth_QSslConfiguration_supportedEllipticCurves(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_supportedEllipticCurves(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            QVector< ::QSslEllipticCurve>*sipRes;

            sipRes = new QVector< ::QSslEllipticCurve>( ::QSslConfiguration::supportedEllipticCurves());

            return sipConvertFromNewType(sipRes,sipType_QVector_0100QSslEllipticCurve,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_supportedEllipticCurves, doc_QSslConfiguration_supportedEllipticCurves);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_ephemeralServerKey, "ephemeralServerKey(self) -> QSslKey");

extern "C" {static PyObject *meth_QSslConfiguration_ephemeralServerKey(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_ephemeralServerKey(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QSslKey*sipRes;

            sipRes = new  ::QSslKey(sipCpp->ephemeralServerKey());

            return sipConvertFromNewType(sipRes,sipType_QSslKey,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_ephemeralServerKey, doc_QSslConfiguration_ephemeralServerKey);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_preSharedKeyIdentityHint, "preSharedKeyIdentityHint(self) -> QByteArray");

extern "C" {static PyObject *meth_QSslConfiguration_preSharedKeyIdentityHint(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_preSharedKeyIdentityHint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->preSharedKeyIdentityHint());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_preSharedKeyIdentityHint, doc_QSslConfiguration_preSharedKeyIdentityHint);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setPreSharedKeyIdentityHint, "setPreSharedKeyIdentityHint(self, Union[QByteArray, bytes, bytearray])");

extern "C" {static PyObject *meth_QSslConfiguration_setPreSharedKeyIdentityHint(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setPreSharedKeyIdentityHint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray* a0;
        int a0State = 0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QByteArray, &a0, &a0State))
        {
            sipCpp->setPreSharedKeyIdentityHint(*a0);
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setPreSharedKeyIdentityHint, doc_QSslConfiguration_setPreSharedKeyIdentityHint);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_diffieHellmanParameters, "diffieHellmanParameters(self) -> QSslDiffieHellmanParameters");

extern "C" {static PyObject *meth_QSslConfiguration_diffieHellmanParameters(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_diffieHellmanParameters(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
             ::QSslDiffieHellmanParameters*sipRes;

            sipRes = new  ::QSslDiffieHellmanParameters(sipCpp->diffieHellmanParameters());

            return sipConvertFromNewType(sipRes,sipType_QSslDiffieHellmanParameters,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_diffieHellmanParameters, doc_QSslConfiguration_diffieHellmanParameters);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setDiffieHellmanParameters, "setDiffieHellmanParameters(self, QSslDiffieHellmanParameters)");

extern "C" {static PyObject *meth_QSslConfiguration_setDiffieHellmanParameters(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setDiffieHellmanParameters(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslDiffieHellmanParameters* a0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QSslDiffieHellmanParameters, &a0))
        {
            sipCpp->setDiffieHellmanParameters(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setDiffieHellmanParameters, doc_QSslConfiguration_setDiffieHellmanParameters);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_backendConfiguration, "backendConfiguration(self) -> Dict[QByteArray, Any]");

extern "C" {static PyObject *meth_QSslConfiguration_backendConfiguration(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_backendConfiguration(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslConfiguration, &sipCpp))
        {
            QMap< ::QByteArray, ::QVariant>*sipRes;

            sipRes = new QMap< ::QByteArray, ::QVariant>(sipCpp->backendConfiguration());

            return sipConvertFromNewType(sipRes,sipType_QMap_0100QByteArray_0100QVariant,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_backendConfiguration, doc_QSslConfiguration_backendConfiguration);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setBackendConfigurationOption, "setBackendConfigurationOption(self, Union[QByteArray, bytes, bytearray], Any)");

extern "C" {static PyObject *meth_QSslConfiguration_setBackendConfigurationOption(PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setBackendConfigurationOption(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray* a0;
        int a0State = 0;
        const  ::QVariant* a1;
        int a1State = 0;
         ::QSslConfiguration *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J1", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QByteArray, &a0, &a0State, sipType_QVariant, &a1, &a1State))
        {
            sipCpp->setBackendConfigurationOption(*a0,*a1);
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);
            sipReleaseType(const_cast< ::QVariant *>(a1),sipType_QVariant,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setBackendConfigurationOption, doc_QSslConfiguration_setBackendConfigurationOption);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslConfiguration_setBackendConfiguration, "setBackendConfiguration(self, backendConfiguration: Dict[Union[QByteArray, bytes, bytearray], Any] = {})");

extern "C" {static PyObject *meth_QSslConfiguration_setBackendConfiguration(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslConfiguration_setBackendConfiguration(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const QMap< ::QByteArray, ::QVariant>& a0def = QMap<QByteArray,QVariant>();
        const QMap< ::QByteArray, ::QVariant>* a0 = &a0def;
        int a0State = 0;
         ::QSslConfiguration *sipCpp;

        static const char *sipKwdList[] = {
            sipName_backendConfiguration,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|J1", &sipSelf, sipType_QSslConfiguration, &sipCpp, sipType_QMap_0100QByteArray_0100QVariant,&a0, &a0State))
        {
            sipCpp->setBackendConfiguration(*a0);
            sipReleaseType(const_cast<QMap< ::QByteArray, ::QVariant> *>(a0),sipType_QMap_0100QByteArray_0100QVariant,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslConfiguration, sipName_setBackendConfiguration, doc_QSslConfiguration_setBackendConfiguration);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *slot_QSslConfiguration___ne__(PyObject *,PyObject *);}
static PyObject *slot_QSslConfiguration___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslConfiguration *sipCpp = reinterpret_cast< ::QSslConfiguration *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslConfiguration));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslConfiguration, &a0))
        {
            bool sipRes;

            sipRes = sipCpp-> ::QSslConfiguration::operator!=(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, ne_slot, sipType_QSslConfiguration, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QSslConfiguration___eq__(PyObject *,PyObject *);}
static PyObject *slot_QSslConfiguration___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslConfiguration *sipCpp = reinterpret_cast< ::QSslConfiguration *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslConfiguration));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslConfiguration* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslConfiguration, &a0))
        {
            bool sipRes;

            sipRes = sipCpp-> ::QSslConfiguration::operator==(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, eq_slot, sipType_QSslConfiguration, sipSelf, sipArg);
}


/* Call the instance's destructor. */
extern "C" {static void release_QSslConfiguration(void *, int);}
static void release_QSslConfiguration(void *sipCppV, int)
{
    delete reinterpret_cast< ::QSslConfiguration *>(sipCppV);
}


extern "C" {static void assign_QSslConfiguration(void *, SIP_SSIZE_T, void *);}
static void assign_QSslConfiguration(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QSslConfiguration *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QSslConfiguration *>(sipSrc);
}


extern "C" {static void *array_QSslConfiguration(SIP_SSIZE_T);}
static void *array_QSslConfiguration(SIP_SSIZE_T sipNrElem)
{
    return new  ::QSslConfiguration[sipNrElem];
}


extern "C" {static void *copy_QSslConfiguration(const void *, SIP_SSIZE_T);}
static void *copy_QSslConfiguration(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QSslConfiguration(reinterpret_cast<const  ::QSslConfiguration *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QSslConfiguration(sipSimpleWrapper *);}
static void dealloc_QSslConfiguration(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSslConfiguration(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QSslConfiguration(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSslConfiguration(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QSslConfiguration *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new  ::QSslConfiguration();

            return sipCpp;
        }
    }

    {
        const  ::QSslConfiguration* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QSslConfiguration, &a0))
        {
            sipCpp = new  ::QSslConfiguration(*a0);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QSslConfiguration[] = {
    {(void *)slot_QSslConfiguration___ne__, ne_slot},
    {(void *)slot_QSslConfiguration___eq__, eq_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_QSslConfiguration[] = {
    {SIP_MLNAME_CAST(sipName_allowedNextProtocols), meth_QSslConfiguration_allowedNextProtocols, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_allowedNextProtocols)},
    {SIP_MLNAME_CAST(sipName_backendConfiguration), meth_QSslConfiguration_backendConfiguration, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_backendConfiguration)},
    {SIP_MLNAME_CAST(sipName_caCertificates), meth_QSslConfiguration_caCertificates, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_caCertificates)},
    {SIP_MLNAME_CAST(sipName_ciphers), meth_QSslConfiguration_ciphers, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_ciphers)},
    {SIP_MLNAME_CAST(sipName_defaultConfiguration), meth_QSslConfiguration_defaultConfiguration, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_defaultConfiguration)},
    {SIP_MLNAME_CAST(sipName_diffieHellmanParameters), meth_QSslConfiguration_diffieHellmanParameters, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_diffieHellmanParameters)},
    {SIP_MLNAME_CAST(sipName_ellipticCurves), meth_QSslConfiguration_ellipticCurves, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_ellipticCurves)},
    {SIP_MLNAME_CAST(sipName_ephemeralServerKey), meth_QSslConfiguration_ephemeralServerKey, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_ephemeralServerKey)},
    {SIP_MLNAME_CAST(sipName_isNull), meth_QSslConfiguration_isNull, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_isNull)},
    {SIP_MLNAME_CAST(sipName_localCertificate), meth_QSslConfiguration_localCertificate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_localCertificate)},
    {SIP_MLNAME_CAST(sipName_localCertificateChain), meth_QSslConfiguration_localCertificateChain, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_localCertificateChain)},
    {SIP_MLNAME_CAST(sipName_nextNegotiatedProtocol), meth_QSslConfiguration_nextNegotiatedProtocol, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_nextNegotiatedProtocol)},
    {SIP_MLNAME_CAST(sipName_nextProtocolNegotiationStatus), meth_QSslConfiguration_nextProtocolNegotiationStatus, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_nextProtocolNegotiationStatus)},
    {SIP_MLNAME_CAST(sipName_peerCertificate), meth_QSslConfiguration_peerCertificate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_peerCertificate)},
    {SIP_MLNAME_CAST(sipName_peerCertificateChain), meth_QSslConfiguration_peerCertificateChain, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_peerCertificateChain)},
    {SIP_MLNAME_CAST(sipName_peerVerifyDepth), meth_QSslConfiguration_peerVerifyDepth, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_peerVerifyDepth)},
    {SIP_MLNAME_CAST(sipName_peerVerifyMode), meth_QSslConfiguration_peerVerifyMode, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_peerVerifyMode)},
    {SIP_MLNAME_CAST(sipName_preSharedKeyIdentityHint), meth_QSslConfiguration_preSharedKeyIdentityHint, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_preSharedKeyIdentityHint)},
    {SIP_MLNAME_CAST(sipName_privateKey), meth_QSslConfiguration_privateKey, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_privateKey)},
    {SIP_MLNAME_CAST(sipName_protocol), meth_QSslConfiguration_protocol, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_protocol)},
    {SIP_MLNAME_CAST(sipName_sessionCipher), meth_QSslConfiguration_sessionCipher, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_sessionCipher)},
    {SIP_MLNAME_CAST(sipName_sessionProtocol), meth_QSslConfiguration_sessionProtocol, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_sessionProtocol)},
    {SIP_MLNAME_CAST(sipName_sessionTicket), meth_QSslConfiguration_sessionTicket, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_sessionTicket)},
    {SIP_MLNAME_CAST(sipName_sessionTicketLifeTimeHint), meth_QSslConfiguration_sessionTicketLifeTimeHint, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_sessionTicketLifeTimeHint)},
    {SIP_MLNAME_CAST(sipName_setAllowedNextProtocols), meth_QSslConfiguration_setAllowedNextProtocols, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setAllowedNextProtocols)},
    {SIP_MLNAME_CAST(sipName_setBackendConfiguration), SIP_MLMETH_CAST(meth_QSslConfiguration_setBackendConfiguration), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslConfiguration_setBackendConfiguration)},
    {SIP_MLNAME_CAST(sipName_setBackendConfigurationOption), meth_QSslConfiguration_setBackendConfigurationOption, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setBackendConfigurationOption)},
    {SIP_MLNAME_CAST(sipName_setCaCertificates), meth_QSslConfiguration_setCaCertificates, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setCaCertificates)},
    {SIP_MLNAME_CAST(sipName_setCiphers), meth_QSslConfiguration_setCiphers, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setCiphers)},
    {SIP_MLNAME_CAST(sipName_setDefaultConfiguration), meth_QSslConfiguration_setDefaultConfiguration, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setDefaultConfiguration)},
    {SIP_MLNAME_CAST(sipName_setDiffieHellmanParameters), meth_QSslConfiguration_setDiffieHellmanParameters, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setDiffieHellmanParameters)},
    {SIP_MLNAME_CAST(sipName_setEllipticCurves), meth_QSslConfiguration_setEllipticCurves, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setEllipticCurves)},
    {SIP_MLNAME_CAST(sipName_setLocalCertificate), meth_QSslConfiguration_setLocalCertificate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setLocalCertificate)},
    {SIP_MLNAME_CAST(sipName_setLocalCertificateChain), meth_QSslConfiguration_setLocalCertificateChain, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setLocalCertificateChain)},
    {SIP_MLNAME_CAST(sipName_setPeerVerifyDepth), meth_QSslConfiguration_setPeerVerifyDepth, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setPeerVerifyDepth)},
    {SIP_MLNAME_CAST(sipName_setPeerVerifyMode), meth_QSslConfiguration_setPeerVerifyMode, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setPeerVerifyMode)},
    {SIP_MLNAME_CAST(sipName_setPreSharedKeyIdentityHint), meth_QSslConfiguration_setPreSharedKeyIdentityHint, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setPreSharedKeyIdentityHint)},
    {SIP_MLNAME_CAST(sipName_setPrivateKey), meth_QSslConfiguration_setPrivateKey, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setPrivateKey)},
    {SIP_MLNAME_CAST(sipName_setProtocol), meth_QSslConfiguration_setProtocol, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setProtocol)},
    {SIP_MLNAME_CAST(sipName_setSessionTicket), meth_QSslConfiguration_setSessionTicket, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setSessionTicket)},
    {SIP_MLNAME_CAST(sipName_setSslOption), meth_QSslConfiguration_setSslOption, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_setSslOption)},
    {SIP_MLNAME_CAST(sipName_supportedCiphers), meth_QSslConfiguration_supportedCiphers, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_supportedCiphers)},
    {SIP_MLNAME_CAST(sipName_supportedEllipticCurves), meth_QSslConfiguration_supportedEllipticCurves, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_supportedEllipticCurves)},
    {SIP_MLNAME_CAST(sipName_swap), meth_QSslConfiguration_swap, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_swap)},
    {SIP_MLNAME_CAST(sipName_systemCaCertificates), meth_QSslConfiguration_systemCaCertificates, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_systemCaCertificates)},
    {SIP_MLNAME_CAST(sipName_testSslOption), meth_QSslConfiguration_testSslOption, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslConfiguration_testSslOption)}
};

static sipEnumMemberDef enummembers_QSslConfiguration[] = {
    {sipName_NextProtocolNegotiationNegotiated, static_cast<int>( ::QSslConfiguration::NextProtocolNegotiationNegotiated), 117},
    {sipName_NextProtocolNegotiationNone, static_cast<int>( ::QSslConfiguration::NextProtocolNegotiationNone), 117},
    {sipName_NextProtocolNegotiationUnsupported, static_cast<int>( ::QSslConfiguration::NextProtocolNegotiationUnsupported), 117},
};


extern "C" {static PyObject *varget_QSslConfiguration_NextProtocolHttp1_1(void *, PyObject *, PyObject *);}
static PyObject *varget_QSslConfiguration_NextProtocolHttp1_1(void *, PyObject *, PyObject *)
{
    static PyObject *sipPy = SIP_NULLPTR;
    const char*sipVal;

    if (sipPy)
    {
        Py_INCREF(sipPy);
        return sipPy;
    }

    sipVal =  ::QSslConfiguration::NextProtocolHttp1_1;

    if (sipVal == SIP_NULLPTR)
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return SIPBytes_FromString(sipVal);
}


extern "C" {static PyObject *varget_QSslConfiguration_NextProtocolSpdy3_0(void *, PyObject *, PyObject *);}
static PyObject *varget_QSslConfiguration_NextProtocolSpdy3_0(void *, PyObject *, PyObject *)
{
    static PyObject *sipPy = SIP_NULLPTR;
    const char*sipVal;

    if (sipPy)
    {
        Py_INCREF(sipPy);
        return sipPy;
    }

    sipVal =  ::QSslConfiguration::NextProtocolSpdy3_0;

    if (sipVal == SIP_NULLPTR)
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return SIPBytes_FromString(sipVal);
}

sipVariableDef variables_QSslConfiguration[] = {
    {ClassVariable, sipName_NextProtocolHttp1_1, (PyMethodDef *)varget_QSslConfiguration_NextProtocolHttp1_1, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {ClassVariable, sipName_NextProtocolSpdy3_0, (PyMethodDef *)varget_QSslConfiguration_NextProtocolSpdy3_0, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
};

PyDoc_STRVAR(doc_QSslConfiguration, "\1QSslConfiguration()\n"
"QSslConfiguration(QSslConfiguration)");


static pyqt5ClassPluginDef plugin_QSslConfiguration = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSslConfiguration = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSslConfiguration,
        {SIP_NULLPTR},
        &plugin_QSslConfiguration
    },
    {
        sipNameNr_QSslConfiguration,
        {0, 0, 1},
        46, methods_QSslConfiguration,
        3, enummembers_QSslConfiguration,
        2, variables_QSslConfiguration,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSslConfiguration,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    slots_QSslConfiguration,
    init_type_QSslConfiguration,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSslConfiguration,
    assign_QSslConfiguration,
    array_QSslConfiguration,
    copy_QSslConfiguration,
    release_QSslConfiguration,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcipher.sip"
#include <qsslcipher.h>
#line 17058 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 17062 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 17065 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


PyDoc_STRVAR(doc_QSslCipher_isNull, "isNull(self) -> bool");

extern "C" {static PyObject *meth_QSslCipher_isNull(PyObject *, PyObject *);}
static PyObject *meth_QSslCipher_isNull(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCipher *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCipher, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isNull();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCipher, sipName_isNull, doc_QSslCipher_isNull);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCipher_name, "name(self) -> str");

extern "C" {static PyObject *meth_QSslCipher_name(PyObject *, PyObject *);}
static PyObject *meth_QSslCipher_name(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCipher *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCipher, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->name());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCipher, sipName_name, doc_QSslCipher_name);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCipher_supportedBits, "supportedBits(self) -> int");

extern "C" {static PyObject *meth_QSslCipher_supportedBits(PyObject *, PyObject *);}
static PyObject *meth_QSslCipher_supportedBits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCipher *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCipher, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->supportedBits();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCipher, sipName_supportedBits, doc_QSslCipher_supportedBits);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCipher_usedBits, "usedBits(self) -> int");

extern "C" {static PyObject *meth_QSslCipher_usedBits(PyObject *, PyObject *);}
static PyObject *meth_QSslCipher_usedBits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCipher *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCipher, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->usedBits();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCipher, sipName_usedBits, doc_QSslCipher_usedBits);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCipher_keyExchangeMethod, "keyExchangeMethod(self) -> str");

extern "C" {static PyObject *meth_QSslCipher_keyExchangeMethod(PyObject *, PyObject *);}
static PyObject *meth_QSslCipher_keyExchangeMethod(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCipher *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCipher, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->keyExchangeMethod());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCipher, sipName_keyExchangeMethod, doc_QSslCipher_keyExchangeMethod);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCipher_authenticationMethod, "authenticationMethod(self) -> str");

extern "C" {static PyObject *meth_QSslCipher_authenticationMethod(PyObject *, PyObject *);}
static PyObject *meth_QSslCipher_authenticationMethod(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCipher *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCipher, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->authenticationMethod());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCipher, sipName_authenticationMethod, doc_QSslCipher_authenticationMethod);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCipher_encryptionMethod, "encryptionMethod(self) -> str");

extern "C" {static PyObject *meth_QSslCipher_encryptionMethod(PyObject *, PyObject *);}
static PyObject *meth_QSslCipher_encryptionMethod(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCipher *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCipher, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->encryptionMethod());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCipher, sipName_encryptionMethod, doc_QSslCipher_encryptionMethod);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCipher_protocolString, "protocolString(self) -> str");

extern "C" {static PyObject *meth_QSslCipher_protocolString(PyObject *, PyObject *);}
static PyObject *meth_QSslCipher_protocolString(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCipher *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCipher, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->protocolString());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCipher, sipName_protocolString, doc_QSslCipher_protocolString);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCipher_protocol, "protocol(self) -> QSsl.SslProtocol");

extern "C" {static PyObject *meth_QSslCipher_protocol(PyObject *, PyObject *);}
static PyObject *meth_QSslCipher_protocol(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCipher *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCipher, &sipCpp))
        {
             ::QSsl::SslProtocol sipRes;

            sipRes = sipCpp->protocol();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QSsl_SslProtocol);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCipher, sipName_protocol, doc_QSslCipher_protocol);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCipher_swap, "swap(self, QSslCipher)");

extern "C" {static PyObject *meth_QSslCipher_swap(PyObject *, PyObject *);}
static PyObject *meth_QSslCipher_swap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslCipher* a0;
         ::QSslCipher *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslCipher, &sipCpp, sipType_QSslCipher, &a0))
        {
            sipCpp->swap(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCipher, sipName_swap, doc_QSslCipher_swap);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *slot_QSslCipher___ne__(PyObject *,PyObject *);}
static PyObject *slot_QSslCipher___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslCipher *sipCpp = reinterpret_cast< ::QSslCipher *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslCipher));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCipher* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslCipher, &a0))
        {
            bool sipRes;

            sipRes = sipCpp-> ::QSslCipher::operator!=(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, ne_slot, sipType_QSslCipher, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QSslCipher___eq__(PyObject *,PyObject *);}
static PyObject *slot_QSslCipher___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslCipher *sipCpp = reinterpret_cast< ::QSslCipher *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslCipher));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCipher* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslCipher, &a0))
        {
            bool sipRes;

            sipRes = sipCpp-> ::QSslCipher::operator==(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, eq_slot, sipType_QSslCipher, sipSelf, sipArg);
}


/* Call the instance's destructor. */
extern "C" {static void release_QSslCipher(void *, int);}
static void release_QSslCipher(void *sipCppV, int)
{
    delete reinterpret_cast< ::QSslCipher *>(sipCppV);
}


extern "C" {static void assign_QSslCipher(void *, SIP_SSIZE_T, void *);}
static void assign_QSslCipher(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QSslCipher *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QSslCipher *>(sipSrc);
}


extern "C" {static void *array_QSslCipher(SIP_SSIZE_T);}
static void *array_QSslCipher(SIP_SSIZE_T sipNrElem)
{
    return new  ::QSslCipher[sipNrElem];
}


extern "C" {static void *copy_QSslCipher(const void *, SIP_SSIZE_T);}
static void *copy_QSslCipher(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QSslCipher(reinterpret_cast<const  ::QSslCipher *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QSslCipher(sipSimpleWrapper *);}
static void dealloc_QSslCipher(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSslCipher(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QSslCipher(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSslCipher(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QSslCipher *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new  ::QSslCipher();

            return sipCpp;
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J1", sipType_QString,&a0, &a0State))
        {
            sipCpp = new  ::QSslCipher(*a0);
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return sipCpp;
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QSsl::SslProtocol a1;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J1E", sipType_QString,&a0, &a0State, sipType_QSsl_SslProtocol, &a1))
        {
            sipCpp = new  ::QSslCipher(*a0,a1);
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return sipCpp;
        }
    }

    {
        const  ::QSslCipher* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QSslCipher, &a0))
        {
            sipCpp = new  ::QSslCipher(*a0);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QSslCipher[] = {
    {(void *)slot_QSslCipher___ne__, ne_slot},
    {(void *)slot_QSslCipher___eq__, eq_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_QSslCipher[] = {
    {SIP_MLNAME_CAST(sipName_authenticationMethod), meth_QSslCipher_authenticationMethod, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCipher_authenticationMethod)},
    {SIP_MLNAME_CAST(sipName_encryptionMethod), meth_QSslCipher_encryptionMethod, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCipher_encryptionMethod)},
    {SIP_MLNAME_CAST(sipName_isNull), meth_QSslCipher_isNull, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCipher_isNull)},
    {SIP_MLNAME_CAST(sipName_keyExchangeMethod), meth_QSslCipher_keyExchangeMethod, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCipher_keyExchangeMethod)},
    {SIP_MLNAME_CAST(sipName_name), meth_QSslCipher_name, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCipher_name)},
    {SIP_MLNAME_CAST(sipName_protocol), meth_QSslCipher_protocol, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCipher_protocol)},
    {SIP_MLNAME_CAST(sipName_protocolString), meth_QSslCipher_protocolString, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCipher_protocolString)},
    {SIP_MLNAME_CAST(sipName_supportedBits), meth_QSslCipher_supportedBits, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCipher_supportedBits)},
    {SIP_MLNAME_CAST(sipName_swap), meth_QSslCipher_swap, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCipher_swap)},
    {SIP_MLNAME_CAST(sipName_usedBits), meth_QSslCipher_usedBits, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCipher_usedBits)}
};

PyDoc_STRVAR(doc_QSslCipher, "\1QSslCipher()\n"
"QSslCipher(str)\n"
"QSslCipher(str, QSsl.SslProtocol)\n"
"QSslCipher(QSslCipher)");


static pyqt5ClassPluginDef plugin_QSslCipher = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSslCipher = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSslCipher,
        {SIP_NULLPTR},
        &plugin_QSslCipher
    },
    {
        sipNameNr_QSslCipher,
        {0, 0, 1},
        10, methods_QSslCipher,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSslCipher,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    slots_QSslCipher,
    init_type_QSslCipher,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSslCipher,
    assign_QSslCipher,
    array_QSslCipher,
    copy_QSslCipher,
    release_QSslCipher,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcertificateextension.sip"
#include <qsslcertificateextension.h>
#line 17597 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 17601 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 17604 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


PyDoc_STRVAR(doc_QSslCertificateExtension_swap, "swap(self, QSslCertificateExtension)");

extern "C" {static PyObject *meth_QSslCertificateExtension_swap(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificateExtension_swap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslCertificateExtension* a0;
         ::QSslCertificateExtension *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslCertificateExtension, &sipCpp, sipType_QSslCertificateExtension, &a0))
        {
            sipCpp->swap(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificateExtension, sipName_swap, doc_QSslCertificateExtension_swap);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificateExtension_oid, "oid(self) -> str");

extern "C" {static PyObject *meth_QSslCertificateExtension_oid(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificateExtension_oid(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificateExtension *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificateExtension, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->oid());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificateExtension, sipName_oid, doc_QSslCertificateExtension_oid);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificateExtension_name, "name(self) -> str");

extern "C" {static PyObject *meth_QSslCertificateExtension_name(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificateExtension_name(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificateExtension *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificateExtension, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->name());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificateExtension, sipName_name, doc_QSslCertificateExtension_name);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificateExtension_value, "value(self) -> Any");

extern "C" {static PyObject *meth_QSslCertificateExtension_value(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificateExtension_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificateExtension *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificateExtension, &sipCpp))
        {
             ::QVariant*sipRes;

            sipRes = new  ::QVariant(sipCpp->value());

            return sipConvertFromNewType(sipRes,sipType_QVariant,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificateExtension, sipName_value, doc_QSslCertificateExtension_value);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificateExtension_isCritical, "isCritical(self) -> bool");

extern "C" {static PyObject *meth_QSslCertificateExtension_isCritical(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificateExtension_isCritical(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificateExtension *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificateExtension, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isCritical();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificateExtension, sipName_isCritical, doc_QSslCertificateExtension_isCritical);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificateExtension_isSupported, "isSupported(self) -> bool");

extern "C" {static PyObject *meth_QSslCertificateExtension_isSupported(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificateExtension_isSupported(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificateExtension *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificateExtension, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isSupported();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificateExtension, sipName_isSupported, doc_QSslCertificateExtension_isSupported);

    return SIP_NULLPTR;
}


/* Call the instance's destructor. */
extern "C" {static void release_QSslCertificateExtension(void *, int);}
static void release_QSslCertificateExtension(void *sipCppV, int)
{
    delete reinterpret_cast< ::QSslCertificateExtension *>(sipCppV);
}


extern "C" {static void assign_QSslCertificateExtension(void *, SIP_SSIZE_T, void *);}
static void assign_QSslCertificateExtension(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QSslCertificateExtension *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QSslCertificateExtension *>(sipSrc);
}


extern "C" {static void *array_QSslCertificateExtension(SIP_SSIZE_T);}
static void *array_QSslCertificateExtension(SIP_SSIZE_T sipNrElem)
{
    return new  ::QSslCertificateExtension[sipNrElem];
}


extern "C" {static void *copy_QSslCertificateExtension(const void *, SIP_SSIZE_T);}
static void *copy_QSslCertificateExtension(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QSslCertificateExtension(reinterpret_cast<const  ::QSslCertificateExtension *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QSslCertificateExtension(sipSimpleWrapper *);}
static void dealloc_QSslCertificateExtension(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSslCertificateExtension(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QSslCertificateExtension(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSslCertificateExtension(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QSslCertificateExtension *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new  ::QSslCertificateExtension();

            return sipCpp;
        }
    }

    {
        const  ::QSslCertificateExtension* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QSslCertificateExtension, &a0))
        {
            sipCpp = new  ::QSslCertificateExtension(*a0);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


static PyMethodDef methods_QSslCertificateExtension[] = {
    {SIP_MLNAME_CAST(sipName_isCritical), meth_QSslCertificateExtension_isCritical, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificateExtension_isCritical)},
    {SIP_MLNAME_CAST(sipName_isSupported), meth_QSslCertificateExtension_isSupported, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificateExtension_isSupported)},
    {SIP_MLNAME_CAST(sipName_name), meth_QSslCertificateExtension_name, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificateExtension_name)},
    {SIP_MLNAME_CAST(sipName_oid), meth_QSslCertificateExtension_oid, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificateExtension_oid)},
    {SIP_MLNAME_CAST(sipName_swap), meth_QSslCertificateExtension_swap, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificateExtension_swap)},
    {SIP_MLNAME_CAST(sipName_value), meth_QSslCertificateExtension_value, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificateExtension_value)}
};

PyDoc_STRVAR(doc_QSslCertificateExtension, "\1QSslCertificateExtension()\n"
"QSslCertificateExtension(QSslCertificateExtension)");


static pyqt5ClassPluginDef plugin_QSslCertificateExtension = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSslCertificateExtension = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSslCertificateExtension,
        {SIP_NULLPTR},
        &plugin_QSslCertificateExtension
    },
    {
        sipNameNr_QSslCertificateExtension,
        {0, 0, 1},
        6, methods_QSslCertificateExtension,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSslCertificateExtension,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    SIP_NULLPTR,
    init_type_QSslCertificateExtension,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSslCertificateExtension,
    assign_QSslCertificateExtension,
    array_QSslCertificateExtension,
    copy_QSslCertificateExtension,
    release_QSslCertificateExtension,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcertificate.sip"
#include <qsslcertificate.h>
#line 17917 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "sip/QtCore/qiodevice.sip"
#include <qiodevice.h>
#line 17921 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 17924 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 17927 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 17930 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslkey.sip"
#include <qsslkey.h>
#line 17933 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 17936 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 17939 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslerror.sip"
#include <qsslerror.h>
#line 17942 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 17945 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcertificateextension.sip"
#include <qsslcertificateextension.h>
#line 17948 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 17951 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 17954 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 305 "sip/QtCore/qdatetime.sip"
#include <qdatetime.h>
#line 17957 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qpynetwork_qmap.sip"
#include <qmap.h>
#include <qssl.h>
#line 17961 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 36 "sip/QtCore/qstringlist.sip"
#include <qstringlist.h>
#line 17964 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qcryptographichash.sip"
#include <qcryptographichash.h>
#line 17967 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


PyDoc_STRVAR(doc_QSslCertificate_isNull, "isNull(self) -> bool");

extern "C" {static PyObject *meth_QSslCertificate_isNull(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_isNull(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isNull();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_isNull, doc_QSslCertificate_isNull);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_clear, "clear(self)");

extern "C" {static PyObject *meth_QSslCertificate_clear(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_clear(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
            sipCpp->clear();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_clear, doc_QSslCertificate_clear);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_version, "version(self) -> QByteArray");

extern "C" {static PyObject *meth_QSslCertificate_version(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_version(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->version());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_version, doc_QSslCertificate_version);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_serialNumber, "serialNumber(self) -> QByteArray");

extern "C" {static PyObject *meth_QSslCertificate_serialNumber(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_serialNumber(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->serialNumber());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_serialNumber, doc_QSslCertificate_serialNumber);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_digest, "digest(self, algorithm: QCryptographicHash.Algorithm = QCryptographicHash.Md5) -> QByteArray");

extern "C" {static PyObject *meth_QSslCertificate_digest(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_digest(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QCryptographicHash::Algorithm a0 = QCryptographicHash::Md5;
        const  ::QSslCertificate *sipCpp;

        static const char *sipKwdList[] = {
            sipName_algorithm,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|E", &sipSelf, sipType_QSslCertificate, &sipCpp, sipType_QCryptographicHash_Algorithm, &a0))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->digest(a0));

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_digest, doc_QSslCertificate_digest);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_issuerInfo, "issuerInfo(self, QSslCertificate.SubjectInfo) -> List[str]\n"
"issuerInfo(self, Union[QByteArray, bytes, bytearray]) -> List[str]");

extern "C" {static PyObject *meth_QSslCertificate_issuerInfo(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_issuerInfo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslCertificate::SubjectInfo a0;
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QSslCertificate, &sipCpp, sipType_QSslCertificate_SubjectInfo, &a0))
        {
             ::QStringList*sipRes;

            sipRes = new  ::QStringList(sipCpp->issuerInfo(a0));

            return sipConvertFromNewType(sipRes,sipType_QStringList,SIP_NULLPTR);
        }
    }

    {
        const  ::QByteArray* a0;
        int a0State = 0;
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslCertificate, &sipCpp, sipType_QByteArray, &a0, &a0State))
        {
             ::QStringList*sipRes;

            sipRes = new  ::QStringList(sipCpp->issuerInfo(*a0));
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            return sipConvertFromNewType(sipRes,sipType_QStringList,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_issuerInfo, doc_QSslCertificate_issuerInfo);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_subjectInfo, "subjectInfo(self, QSslCertificate.SubjectInfo) -> List[str]\n"
"subjectInfo(self, Union[QByteArray, bytes, bytearray]) -> List[str]");

extern "C" {static PyObject *meth_QSslCertificate_subjectInfo(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_subjectInfo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslCertificate::SubjectInfo a0;
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_QSslCertificate, &sipCpp, sipType_QSslCertificate_SubjectInfo, &a0))
        {
             ::QStringList*sipRes;

            sipRes = new  ::QStringList(sipCpp->subjectInfo(a0));

            return sipConvertFromNewType(sipRes,sipType_QStringList,SIP_NULLPTR);
        }
    }

    {
        const  ::QByteArray* a0;
        int a0State = 0;
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QSslCertificate, &sipCpp, sipType_QByteArray, &a0, &a0State))
        {
             ::QStringList*sipRes;

            sipRes = new  ::QStringList(sipCpp->subjectInfo(*a0));
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            return sipConvertFromNewType(sipRes,sipType_QStringList,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_subjectInfo, doc_QSslCertificate_subjectInfo);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_subjectAlternativeNames, "subjectAlternativeNames(self) -> Dict[QSsl.AlternativeNameEntryType, List[str]]");

extern "C" {static PyObject *meth_QSslCertificate_subjectAlternativeNames(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_subjectAlternativeNames(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::QMultiMap< ::QSsl::AlternativeNameEntryType, ::QString>*sipRes;

            sipRes = new  ::QMultiMap< ::QSsl::AlternativeNameEntryType, ::QString>(sipCpp->subjectAlternativeNames());

            return sipConvertFromNewType(sipRes,sipType_QMultiMap_0100QSsl_AlternativeNameEntryType_0100QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_subjectAlternativeNames, doc_QSslCertificate_subjectAlternativeNames);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_effectiveDate, "effectiveDate(self) -> QDateTime");

extern "C" {static PyObject *meth_QSslCertificate_effectiveDate(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_effectiveDate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::QDateTime*sipRes;

            sipRes = new  ::QDateTime(sipCpp->effectiveDate());

            return sipConvertFromNewType(sipRes,sipType_QDateTime,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_effectiveDate, doc_QSslCertificate_effectiveDate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_expiryDate, "expiryDate(self) -> QDateTime");

extern "C" {static PyObject *meth_QSslCertificate_expiryDate(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_expiryDate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::QDateTime*sipRes;

            sipRes = new  ::QDateTime(sipCpp->expiryDate());

            return sipConvertFromNewType(sipRes,sipType_QDateTime,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_expiryDate, doc_QSslCertificate_expiryDate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_publicKey, "publicKey(self) -> QSslKey");

extern "C" {static PyObject *meth_QSslCertificate_publicKey(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_publicKey(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::QSslKey*sipRes;

            sipRes = new  ::QSslKey(sipCpp->publicKey());

            return sipConvertFromNewType(sipRes,sipType_QSslKey,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_publicKey, doc_QSslCertificate_publicKey);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_toPem, "toPem(self) -> QByteArray");

extern "C" {static PyObject *meth_QSslCertificate_toPem(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_toPem(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->toPem());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_toPem, doc_QSslCertificate_toPem);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_toDer, "toDer(self) -> QByteArray");

extern "C" {static PyObject *meth_QSslCertificate_toDer(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_toDer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray(sipCpp->toDer());

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_toDer, doc_QSslCertificate_toDer);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_fromPath, "fromPath(str, format: QSsl.EncodingFormat = QSsl.Pem, syntax: QRegExp.PatternSyntax = QRegExp.FixedString) -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslCertificate_fromPath(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_fromPath(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QSsl::EncodingFormat a1 = QSsl::Pem;
         ::QRegExp::PatternSyntax a2 = QRegExp::FixedString;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_format,
            sipName_syntax,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1|EE", sipType_QString,&a0, &a0State, sipType_QSsl_EncodingFormat, &a1, sipType_QRegExp_PatternSyntax, &a2))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>( ::QSslCertificate::fromPath(*a0,a1,a2));
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_fromPath, doc_QSslCertificate_fromPath);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_fromDevice, "fromDevice(QIODevice, format: QSsl.EncodingFormat = QSsl.Pem) -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslCertificate_fromDevice(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_fromDevice(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QIODevice* a0;
         ::QSsl::EncodingFormat a1 = QSsl::Pem;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_format,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J8|E", sipType_QIODevice, &a0, sipType_QSsl_EncodingFormat, &a1))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>( ::QSslCertificate::fromDevice(a0,a1));

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_fromDevice, doc_QSslCertificate_fromDevice);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_fromData, "fromData(Union[QByteArray, bytes, bytearray], format: QSsl.EncodingFormat = QSsl.Pem) -> List[QSslCertificate]");

extern "C" {static PyObject *meth_QSslCertificate_fromData(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_fromData(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QByteArray* a0;
        int a0State = 0;
         ::QSsl::EncodingFormat a1 = QSsl::Pem;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_format,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1|E", sipType_QByteArray, &a0, &a0State, sipType_QSsl_EncodingFormat, &a1))
        {
            QList< ::QSslCertificate>*sipRes;

            sipRes = new QList< ::QSslCertificate>( ::QSslCertificate::fromData(*a0,a1));
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificate,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_fromData, doc_QSslCertificate_fromData);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_handle, "handle(self) -> sip.voidptr");

extern "C" {static PyObject *meth_QSslCertificate_handle(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_handle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::Qt::HANDLE sipRes;

            sipRes = sipCpp->handle();

            return sipConvertFromVoidPtr((void *)sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_handle, doc_QSslCertificate_handle);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_swap, "swap(self, QSslCertificate)");

extern "C" {static PyObject *meth_QSslCertificate_swap(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_swap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSslCertificate* a0;
         ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_QSslCertificate, &sipCpp, sipType_QSslCertificate, &a0))
        {
            sipCpp->swap(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_swap, doc_QSslCertificate_swap);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_isBlacklisted, "isBlacklisted(self) -> bool");

extern "C" {static PyObject *meth_QSslCertificate_isBlacklisted(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_isBlacklisted(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isBlacklisted();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_isBlacklisted, doc_QSslCertificate_isBlacklisted);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_subjectInfoAttributes, "subjectInfoAttributes(self) -> List[QByteArray]");

extern "C" {static PyObject *meth_QSslCertificate_subjectInfoAttributes(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_subjectInfoAttributes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
            QList< ::QByteArray>*sipRes;

            sipRes = new QList< ::QByteArray>(sipCpp->subjectInfoAttributes());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_subjectInfoAttributes, doc_QSslCertificate_subjectInfoAttributes);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_issuerInfoAttributes, "issuerInfoAttributes(self) -> List[QByteArray]");

extern "C" {static PyObject *meth_QSslCertificate_issuerInfoAttributes(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_issuerInfoAttributes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
            QList< ::QByteArray>*sipRes;

            sipRes = new QList< ::QByteArray>(sipCpp->issuerInfoAttributes());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_issuerInfoAttributes, doc_QSslCertificate_issuerInfoAttributes);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_extensions, "extensions(self) -> List[QSslCertificateExtension]");

extern "C" {static PyObject *meth_QSslCertificate_extensions(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_extensions(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
            QList< ::QSslCertificateExtension>*sipRes;

            sipRes = new QList< ::QSslCertificateExtension>(sipCpp->extensions());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslCertificateExtension,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_extensions, doc_QSslCertificate_extensions);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_toText, "toText(self) -> str");

extern "C" {static PyObject *meth_QSslCertificate_toText(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_toText(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->toText());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_toText, doc_QSslCertificate_toText);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_verify, "verify(Iterable[QSslCertificate], hostName: str = '') -> List[QSslError]");

extern "C" {static PyObject *meth_QSslCertificate_verify(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_verify(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        QList< ::QSslCertificate>* a0;
        int a0State = 0;
        const  ::QString& a1def = QString();
        const  ::QString* a1 = &a1def;
        int a1State = 0;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_hostName,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1|J1", sipType_QList_0100QSslCertificate,&a0, &a0State, sipType_QString,&a1, &a1State))
        {
            QList< ::QSslError>*sipRes;

            sipRes = new QList< ::QSslError>( ::QSslCertificate::verify(*a0,*a1));
            sipReleaseType(a0,sipType_QList_0100QSslCertificate,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);

            return sipConvertFromNewType(sipRes,sipType_QList_0100QSslError,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_verify, doc_QSslCertificate_verify);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_isSelfSigned, "isSelfSigned(self) -> bool");

extern "C" {static PyObject *meth_QSslCertificate_isSelfSigned(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_isSelfSigned(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isSelfSigned();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_isSelfSigned, doc_QSslCertificate_isSelfSigned);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_importPkcs12, "importPkcs12(QIODevice, QSslKey, QSslCertificate, caCertificates: Iterable[QSslCertificate] = [], passPhrase: Union[QByteArray, bytes, bytearray] = QByteArray()) -> bool");

extern "C" {static PyObject *meth_QSslCertificate_importPkcs12(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_importPkcs12(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QIODevice* a0;
         ::QSslKey* a1;
         ::QSslCertificate* a2;
        QList< ::QSslCertificate>* a3 = 0;
        int a3State = 0;
        const  ::QByteArray& a4def = QByteArray();
        const  ::QByteArray* a4 = &a4def;
        int a4State = 0;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            SIP_NULLPTR,
            SIP_NULLPTR,
            sipName_caCertificates,
            sipName_passPhrase,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J8J8J8|J0J1", sipType_QIODevice, &a0, sipType_QSslKey, &a1, sipType_QSslCertificate, &a2, sipType_QList_0100QSslCertificate,&a3, &a3State, sipType_QByteArray, &a4, &a4State))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::QSslCertificate::importPkcs12(a0,a1,a2,a3,*a4);
            Py_END_ALLOW_THREADS
            sipReleaseType(a3,sipType_QList_0100QSslCertificate,a3State);
            sipReleaseType(const_cast< ::QByteArray *>(a4),sipType_QByteArray,a4State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_importPkcs12, doc_QSslCertificate_importPkcs12);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_issuerDisplayName, "issuerDisplayName(self) -> str");

extern "C" {static PyObject *meth_QSslCertificate_issuerDisplayName(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_issuerDisplayName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->issuerDisplayName());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_issuerDisplayName, doc_QSslCertificate_issuerDisplayName);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QSslCertificate_subjectDisplayName, "subjectDisplayName(self) -> str");

extern "C" {static PyObject *meth_QSslCertificate_subjectDisplayName(PyObject *, PyObject *);}
static PyObject *meth_QSslCertificate_subjectDisplayName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QSslCertificate, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->subjectDisplayName());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QSslCertificate, sipName_subjectDisplayName, doc_QSslCertificate_subjectDisplayName);

    return SIP_NULLPTR;
}


extern "C" {static long slot_QSslCertificate___hash__(PyObject *);}
static long slot_QSslCertificate___hash__(PyObject *sipSelf)
{
     ::QSslCertificate *sipCpp = reinterpret_cast< ::QSslCertificate *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslCertificate));

    if (!sipCpp)
        return 0L;


    {
        {
            long sipRes = 0;

#line 83 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qsslcertificate.sip"
        sipRes = qHash(*sipCpp);
#line 18865 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            return sipRes;
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_QSslCertificate___ne__(PyObject *,PyObject *);}
static PyObject *slot_QSslCertificate___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslCertificate *sipCpp = reinterpret_cast< ::QSslCertificate *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslCertificate));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslCertificate, &a0))
        {
            bool sipRes;

            sipRes = sipCpp-> ::QSslCertificate::operator!=(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, ne_slot, sipType_QSslCertificate, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QSslCertificate___eq__(PyObject *,PyObject *);}
static PyObject *slot_QSslCertificate___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSslCertificate *sipCpp = reinterpret_cast< ::QSslCertificate *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSslCertificate));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSslCertificate* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QSslCertificate, &a0))
        {
            bool sipRes;

            sipRes = sipCpp-> ::QSslCertificate::operator==(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, eq_slot, sipType_QSslCertificate, sipSelf, sipArg);
}


/* Call the instance's destructor. */
extern "C" {static void release_QSslCertificate(void *, int);}
static void release_QSslCertificate(void *sipCppV, int)
{
    delete reinterpret_cast< ::QSslCertificate *>(sipCppV);
}


extern "C" {static void assign_QSslCertificate(void *, SIP_SSIZE_T, void *);}
static void assign_QSslCertificate(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QSslCertificate *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QSslCertificate *>(sipSrc);
}


extern "C" {static void *array_QSslCertificate(SIP_SSIZE_T);}
static void *array_QSslCertificate(SIP_SSIZE_T sipNrElem)
{
    return new  ::QSslCertificate[sipNrElem];
}


extern "C" {static void *copy_QSslCertificate(const void *, SIP_SSIZE_T);}
static void *copy_QSslCertificate(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QSslCertificate(reinterpret_cast<const  ::QSslCertificate *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QSslCertificate(sipSimpleWrapper *);}
static void dealloc_QSslCertificate(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSslCertificate(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QSslCertificate(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSslCertificate(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QSslCertificate *sipCpp = SIP_NULLPTR;

    {
         ::QIODevice* a0;
         ::QSsl::EncodingFormat a1 = QSsl::Pem;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_format,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8|E", sipType_QIODevice, &a0, sipType_QSsl_EncodingFormat, &a1))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new  ::QSslCertificate(a0,a1);
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QByteArray& a0def = QByteArray();
        const  ::QByteArray* a0 = &a0def;
        int a0State = 0;
         ::QSsl::EncodingFormat a1 = QSsl::Pem;

        static const char *sipKwdList[] = {
            sipName_data,
            sipName_format,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|J1E", sipType_QByteArray, &a0, &a0State, sipType_QSsl_EncodingFormat, &a1))
        {
            sipCpp = new  ::QSslCertificate(*a0,a1);
            sipReleaseType(const_cast< ::QByteArray *>(a0),sipType_QByteArray,a0State);

            return sipCpp;
        }
    }

    {
        const  ::QSslCertificate* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_QSslCertificate, &a0))
        {
            sipCpp = new  ::QSslCertificate(*a0);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QSslCertificate[] = {
    {(void *)slot_QSslCertificate___hash__, hash_slot},
    {(void *)slot_QSslCertificate___ne__, ne_slot},
    {(void *)slot_QSslCertificate___eq__, eq_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_QSslCertificate[] = {
    {SIP_MLNAME_CAST(sipName_clear), meth_QSslCertificate_clear, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_clear)},
    {SIP_MLNAME_CAST(sipName_digest), SIP_MLMETH_CAST(meth_QSslCertificate_digest), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslCertificate_digest)},
    {SIP_MLNAME_CAST(sipName_effectiveDate), meth_QSslCertificate_effectiveDate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_effectiveDate)},
    {SIP_MLNAME_CAST(sipName_expiryDate), meth_QSslCertificate_expiryDate, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_expiryDate)},
    {SIP_MLNAME_CAST(sipName_extensions), meth_QSslCertificate_extensions, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_extensions)},
    {SIP_MLNAME_CAST(sipName_fromData), SIP_MLMETH_CAST(meth_QSslCertificate_fromData), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslCertificate_fromData)},
    {SIP_MLNAME_CAST(sipName_fromDevice), SIP_MLMETH_CAST(meth_QSslCertificate_fromDevice), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslCertificate_fromDevice)},
    {SIP_MLNAME_CAST(sipName_fromPath), SIP_MLMETH_CAST(meth_QSslCertificate_fromPath), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslCertificate_fromPath)},
    {SIP_MLNAME_CAST(sipName_handle), meth_QSslCertificate_handle, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_handle)},
    {SIP_MLNAME_CAST(sipName_importPkcs12), SIP_MLMETH_CAST(meth_QSslCertificate_importPkcs12), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslCertificate_importPkcs12)},
    {SIP_MLNAME_CAST(sipName_isBlacklisted), meth_QSslCertificate_isBlacklisted, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_isBlacklisted)},
    {SIP_MLNAME_CAST(sipName_isNull), meth_QSslCertificate_isNull, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_isNull)},
    {SIP_MLNAME_CAST(sipName_isSelfSigned), meth_QSslCertificate_isSelfSigned, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_isSelfSigned)},
    {SIP_MLNAME_CAST(sipName_issuerDisplayName), meth_QSslCertificate_issuerDisplayName, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_issuerDisplayName)},
    {SIP_MLNAME_CAST(sipName_issuerInfo), meth_QSslCertificate_issuerInfo, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_issuerInfo)},
    {SIP_MLNAME_CAST(sipName_issuerInfoAttributes), meth_QSslCertificate_issuerInfoAttributes, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_issuerInfoAttributes)},
    {SIP_MLNAME_CAST(sipName_publicKey), meth_QSslCertificate_publicKey, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_publicKey)},
    {SIP_MLNAME_CAST(sipName_serialNumber), meth_QSslCertificate_serialNumber, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_serialNumber)},
    {SIP_MLNAME_CAST(sipName_subjectAlternativeNames), meth_QSslCertificate_subjectAlternativeNames, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_subjectAlternativeNames)},
    {SIP_MLNAME_CAST(sipName_subjectDisplayName), meth_QSslCertificate_subjectDisplayName, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_subjectDisplayName)},
    {SIP_MLNAME_CAST(sipName_subjectInfo), meth_QSslCertificate_subjectInfo, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_subjectInfo)},
    {SIP_MLNAME_CAST(sipName_subjectInfoAttributes), meth_QSslCertificate_subjectInfoAttributes, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_subjectInfoAttributes)},
    {SIP_MLNAME_CAST(sipName_swap), meth_QSslCertificate_swap, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_swap)},
    {SIP_MLNAME_CAST(sipName_toDer), meth_QSslCertificate_toDer, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_toDer)},
    {SIP_MLNAME_CAST(sipName_toPem), meth_QSslCertificate_toPem, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_toPem)},
    {SIP_MLNAME_CAST(sipName_toText), meth_QSslCertificate_toText, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_toText)},
    {SIP_MLNAME_CAST(sipName_verify), SIP_MLMETH_CAST(meth_QSslCertificate_verify), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QSslCertificate_verify)},
    {SIP_MLNAME_CAST(sipName_version), meth_QSslCertificate_version, METH_VARARGS, SIP_MLDOC_CAST(doc_QSslCertificate_version)}
};

static sipEnumMemberDef enummembers_QSslCertificate[] = {
    {sipName_CommonName, static_cast<int>( ::QSslCertificate::CommonName), 113},
    {sipName_CountryName, static_cast<int>( ::QSslCertificate::CountryName), 113},
    {sipName_DistinguishedNameQualifier, static_cast<int>( ::QSslCertificate::DistinguishedNameQualifier), 113},
    {sipName_EmailAddress, static_cast<int>( ::QSslCertificate::EmailAddress), 113},
    {sipName_LocalityName, static_cast<int>( ::QSslCertificate::LocalityName), 113},
    {sipName_Organization, static_cast<int>( ::QSslCertificate::Organization), 113},
    {sipName_OrganizationalUnitName, static_cast<int>( ::QSslCertificate::OrganizationalUnitName), 113},
    {sipName_SerialNumber, static_cast<int>( ::QSslCertificate::SerialNumber), 113},
    {sipName_StateOrProvinceName, static_cast<int>( ::QSslCertificate::StateOrProvinceName), 113},
};

PyDoc_STRVAR(doc_QSslCertificate, "\1QSslCertificate(QIODevice, format: QSsl.EncodingFormat = QSsl.Pem)\n"
"QSslCertificate(data: Union[QByteArray, bytes, bytearray] = QByteArray(), format: QSsl.EncodingFormat = QSsl.Pem)\n"
"QSslCertificate(QSslCertificate)");


static pyqt5ClassPluginDef plugin_QSslCertificate = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSslCertificate = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSslCertificate,
        {SIP_NULLPTR},
        &plugin_QSslCertificate
    },
    {
        sipNameNr_QSslCertificate,
        {0, 0, 1},
        28, methods_QSslCertificate,
        9, enummembers_QSslCertificate,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSslCertificate,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    slots_QSslCertificate,
    init_type_QSslCertificate,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSslCertificate,
    assign_QSslCertificate,
    array_QSslCertificate,
    copy_QSslCertificate,
    release_QSslCertificate,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 19156 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 19160 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static long slot_QSsl_SslOptions___hash__(PyObject *);}
static long slot_QSsl_SslOptions___hash__(PyObject *sipSelf)
{
     ::QSsl::SslOptions *sipCpp = reinterpret_cast< ::QSsl::SslOptions *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSsl_SslOptions));

    if (!sipCpp)
        return 0L;


    {
        {
            long sipRes = 0;

#line 116 "sip/QtCore/qglobal.sip"
        sipRes = sipCpp->operator QSsl::SslOptions::Int();
#line 19178 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            return sipRes;
        }
    }

    return 0;
}


extern "C" {static int slot_QSsl_SslOptions___bool__(PyObject *);}
static int slot_QSsl_SslOptions___bool__(PyObject *sipSelf)
{
     ::QSsl::SslOptions *sipCpp = reinterpret_cast< ::QSsl::SslOptions *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSsl_SslOptions));

    if (!sipCpp)
        return -1;


    {
        {
            int sipRes = 0;

#line 111 "sip/QtCore/qglobal.sip"
        sipRes = (sipCpp->operator QSsl::SslOptions::Int() != 0);
#line 19203 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            return sipRes;
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_QSsl_SslOptions___ne__(PyObject *,PyObject *);}
static PyObject *slot_QSsl_SslOptions___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSsl::SslOptions *sipCpp = reinterpret_cast< ::QSsl::SslOptions *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSsl_SslOptions));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSsl::SslOptions* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J1", sipType_QSsl_SslOptions, &a0, &a0State))
        {
            bool sipRes = 0;

#line 106 "sip/QtCore/qglobal.sip"
        sipRes = (sipCpp->operator QSsl::SslOptions::Int() != a0->operator QSsl::SslOptions::Int());
#line 19233 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
            sipReleaseType(const_cast< ::QSsl::SslOptions *>(a0),sipType_QSsl_SslOptions,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, ne_slot, sipType_QSsl_SslOptions, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QSsl_SslOptions___eq__(PyObject *,PyObject *);}
static PyObject *slot_QSsl_SslOptions___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QSsl::SslOptions *sipCpp = reinterpret_cast< ::QSsl::SslOptions *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSsl_SslOptions));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QSsl::SslOptions* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J1", sipType_QSsl_SslOptions, &a0, &a0State))
        {
            bool sipRes = 0;

#line 101 "sip/QtCore/qglobal.sip"
        sipRes = (sipCpp->operator QSsl::SslOptions::Int() == a0->operator QSsl::SslOptions::Int());
#line 19269 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
            sipReleaseType(const_cast< ::QSsl::SslOptions *>(a0),sipType_QSsl_SslOptions,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, eq_slot, sipType_QSsl_SslOptions, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QSsl_SslOptions___ixor__(PyObject *,PyObject *);}
static PyObject *slot_QSsl_SslOptions___ixor__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_QSsl_SslOptions)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::QSsl::SslOptions *sipCpp = reinterpret_cast< ::QSsl::SslOptions *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSsl_SslOptions));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
#line 95 "sip/QtCore/qglobal.sip"
        *sipCpp = QSsl::SslOptions(*sipCpp ^ a0);
#line 19308 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_QSsl_SslOptions___xor__(PyObject *,PyObject *);}
static PyObject *slot_QSsl_SslOptions___xor__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSsl::SslOptions* a0;
        int a0State = 0;
        int a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J1i", sipType_QSsl_SslOptions, &a0, &a0State, &a1))
        {
             ::QSsl::SslOptions*sipRes;

            sipRes = new  ::QSsl::SslOptions((*a0 ^ a1));
            sipReleaseType(a0,sipType_QSsl_SslOptions,a0State);

            return sipConvertFromNewType(sipRes,sipType_QSsl_SslOptions,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, xor_slot, SIP_NULLPTR, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_QSsl_SslOptions___ior__(PyObject *,PyObject *);}
static PyObject *slot_QSsl_SslOptions___ior__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_QSsl_SslOptions)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::QSsl::SslOptions *sipCpp = reinterpret_cast< ::QSsl::SslOptions *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSsl_SslOptions));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
#line 89 "sip/QtCore/qglobal.sip"
        *sipCpp = QSsl::SslOptions(*sipCpp | a0);
#line 19380 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_QSsl_SslOptions___or__(PyObject *,PyObject *);}
static PyObject *slot_QSsl_SslOptions___or__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSsl::SslOptions* a0;
        int a0State = 0;
        int a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J1i", sipType_QSsl_SslOptions, &a0, &a0State, &a1))
        {
             ::QSsl::SslOptions*sipRes;

            sipRes = new  ::QSsl::SslOptions((*a0 | a1));
            sipReleaseType(a0,sipType_QSsl_SslOptions,a0State);

            return sipConvertFromNewType(sipRes,sipType_QSsl_SslOptions,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, or_slot, SIP_NULLPTR, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_QSsl_SslOptions___iand__(PyObject *,PyObject *);}
static PyObject *slot_QSsl_SslOptions___iand__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_QSsl_SslOptions)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::QSsl::SslOptions *sipCpp = reinterpret_cast< ::QSsl::SslOptions *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSsl_SslOptions));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
            sipCpp-> ::QSsl::SslOptions::operator&=(a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_QSsl_SslOptions___and__(PyObject *,PyObject *);}
static PyObject *slot_QSsl_SslOptions___and__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QSsl::SslOptions* a0;
        int a0State = 0;
        int a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J1i", sipType_QSsl_SslOptions, &a0, &a0State, &a1))
        {
             ::QSsl::SslOptions*sipRes;

            sipRes = new  ::QSsl::SslOptions((*a0 & a1));
            sipReleaseType(a0,sipType_QSsl_SslOptions,a0State);

            return sipConvertFromNewType(sipRes,sipType_QSsl_SslOptions,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, and_slot, SIP_NULLPTR, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_QSsl_SslOptions___invert__(PyObject *);}
static PyObject *slot_QSsl_SslOptions___invert__(PyObject *sipSelf)
{
     ::QSsl::SslOptions *sipCpp = reinterpret_cast< ::QSsl::SslOptions *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSsl_SslOptions));

    if (!sipCpp)
        return SIP_NULLPTR;


    {
        {
             ::QSsl::SslOptions*sipRes;

            sipRes = new  ::QSsl::SslOptions(~(*sipCpp));

            return sipConvertFromNewType(sipRes,sipType_QSsl_SslOptions,SIP_NULLPTR);
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_QSsl_SslOptions___int__(PyObject *);}
static PyObject *slot_QSsl_SslOptions___int__(PyObject *sipSelf)
{
     ::QSsl::SslOptions *sipCpp = reinterpret_cast< ::QSsl::SslOptions *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QSsl_SslOptions));

    if (!sipCpp)
        return SIP_NULLPTR;


    {
        {
            int sipRes;

            sipRes = *sipCpp;

            return SIPLong_FromLong(sipRes);
        }
    }

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_QSsl_SslOptions(void *, int);}
static void release_QSsl_SslOptions(void *sipCppV, int)
{
    delete reinterpret_cast< ::QSsl::SslOptions *>(sipCppV);
}


extern "C" {static void assign_QSsl_SslOptions(void *, SIP_SSIZE_T, void *);}
static void assign_QSsl_SslOptions(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QSsl::SslOptions *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QSsl::SslOptions *>(sipSrc);
}


extern "C" {static void *array_QSsl_SslOptions(SIP_SSIZE_T);}
static void *array_QSsl_SslOptions(SIP_SSIZE_T sipNrElem)
{
    return new  ::QSsl::SslOptions[sipNrElem];
}


extern "C" {static void *copy_QSsl_SslOptions(const void *, SIP_SSIZE_T);}
static void *copy_QSsl_SslOptions(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QSsl::SslOptions(reinterpret_cast<const  ::QSsl::SslOptions *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QSsl_SslOptions(sipSimpleWrapper *);}
static void dealloc_QSsl_SslOptions(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QSsl_SslOptions(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QSsl_SslOptions(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QSsl_SslOptions(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QSsl::SslOptions *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new  ::QSsl::SslOptions();

            return sipCpp;
        }
    }

    {
        int a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "i", &a0))
        {
            sipCpp = new  ::QSsl::SslOptions(a0);

            return sipCpp;
        }
    }

    {
        const  ::QSsl::SslOptions* a0;
        int a0State = 0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J1", sipType_QSsl_SslOptions, &a0, &a0State))
        {
            sipCpp = new  ::QSsl::SslOptions(*a0);
            sipReleaseType(const_cast< ::QSsl::SslOptions *>(a0),sipType_QSsl_SslOptions,a0State);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


extern "C" {static int convertTo_QSsl_SslOptions(PyObject *, void **, int *, PyObject *);}
static int convertTo_QSsl_SslOptions(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
     ::QSsl::SslOptions **sipCppPtr = reinterpret_cast< ::QSsl::SslOptions **>(sipCppPtrV);

#line 121 "sip/QtCore/qglobal.sip"
// Allow an instance of the base enum whenever a QSsl::SslOptions is expected.

if (sipIsErr == NULL)
    return (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_QSsl_SslOption)) ||
            sipCanConvertToType(sipPy, sipType_QSsl_SslOptions, SIP_NO_CONVERTORS));

if (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_QSsl_SslOption)))
{
    *sipCppPtr = new QSsl::SslOptions(int(SIPLong_AsLong(sipPy)));

    return sipGetState(sipTransferObj);
}

*sipCppPtr = reinterpret_cast<QSsl::SslOptions *>(sipConvertToType(sipPy, sipType_QSsl_SslOptions, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
#line 19648 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QSsl_SslOptions[] = {
    {(void *)slot_QSsl_SslOptions___hash__, hash_slot},
    {(void *)slot_QSsl_SslOptions___bool__, bool_slot},
    {(void *)slot_QSsl_SslOptions___ne__, ne_slot},
    {(void *)slot_QSsl_SslOptions___eq__, eq_slot},
    {(void *)slot_QSsl_SslOptions___ixor__, ixor_slot},
    {(void *)slot_QSsl_SslOptions___xor__, xor_slot},
    {(void *)slot_QSsl_SslOptions___ior__, ior_slot},
    {(void *)slot_QSsl_SslOptions___or__, or_slot},
    {(void *)slot_QSsl_SslOptions___iand__, iand_slot},
    {(void *)slot_QSsl_SslOptions___and__, and_slot},
    {(void *)slot_QSsl_SslOptions___invert__, invert_slot},
    {(void *)slot_QSsl_SslOptions___int__, int_slot},
    {0, (sipPySlotType)0}
};

PyDoc_STRVAR(doc_QSsl_SslOptions, "\1QSsl.SslOptions()\n"
"QSsl.SslOptions(Union[QSsl.SslOptions, QSsl.SslOption])\n"
"QSsl.SslOptions(QSsl.SslOptions)");


static pyqt5ClassPluginDef plugin_QSsl_SslOptions = {
    SIP_NULLPTR,
    1,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSsl_SslOptions = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QSsl__SslOptions,
        {SIP_NULLPTR},
        &plugin_QSsl_SslOptions
    },
    {
        sipNameNr_SslOptions,
        {104, 255, 0},
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QSsl_SslOptions,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    slots_QSsl_SslOptions,
    init_type_QSsl_SslOptions,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QSsl_SslOptions,
    assign_QSsl_SslOptions,
    array_QSsl_SslOptions,
    copy_QSsl_SslOptions,
    release_QSsl_SslOptions,
    SIP_NULLPTR,
    convertTo_QSsl_SslOptions,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 28 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qssl.sip"
#include <qssl.h>
#line 19736 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


static sipEnumMemberDef enummembers_QSsl[] = {
    {sipName_AnyProtocol, static_cast<int>( ::QSsl::AnyProtocol), 111},
    {sipName_Der, static_cast<int>( ::QSsl::Der), 106},
    {sipName_DnsEntry, static_cast<int>( ::QSsl::DnsEntry), 105},
    {sipName_Dsa, static_cast<int>( ::QSsl::Dsa), 107},
    {sipName_DtlsV1_0, static_cast<int>( ::QSsl::DtlsV1_0), 111},
    {sipName_DtlsV1_0OrLater, static_cast<int>( ::QSsl::DtlsV1_0OrLater), 111},
    {sipName_DtlsV1_2, static_cast<int>( ::QSsl::DtlsV1_2), 111},
    {sipName_DtlsV1_2OrLater, static_cast<int>( ::QSsl::DtlsV1_2OrLater), 111},
    {sipName_Ec, static_cast<int>( ::QSsl::Ec), 107},
    {sipName_EmailEntry, static_cast<int>( ::QSsl::EmailEntry), 105},
    {sipName_Opaque, static_cast<int>( ::QSsl::Opaque), 107},
    {sipName_Pem, static_cast<int>( ::QSsl::Pem), 106},
    {sipName_PrivateKey, static_cast<int>( ::QSsl::PrivateKey), 108},
    {sipName_PublicKey, static_cast<int>( ::QSsl::PublicKey), 108},
    {sipName_Rsa, static_cast<int>( ::QSsl::Rsa), 107},
    {sipName_SecureProtocols, static_cast<int>( ::QSsl::SecureProtocols), 111},
    {sipName_SslOptionDisableCompression, static_cast<int>( ::QSsl::SslOptionDisableCompression), 109},
    {sipName_SslOptionDisableEmptyFragments, static_cast<int>( ::QSsl::SslOptionDisableEmptyFragments), 109},
    {sipName_SslOptionDisableLegacyRenegotiation, static_cast<int>( ::QSsl::SslOptionDisableLegacyRenegotiation), 109},
    {sipName_SslOptionDisableServerCipherPreference, static_cast<int>( ::QSsl::SslOptionDisableServerCipherPreference), 109},
    {sipName_SslOptionDisableServerNameIndication, static_cast<int>( ::QSsl::SslOptionDisableServerNameIndication), 109},
    {sipName_SslOptionDisableSessionPersistence, static_cast<int>( ::QSsl::SslOptionDisableSessionPersistence), 109},
    {sipName_SslOptionDisableSessionSharing, static_cast<int>( ::QSsl::SslOptionDisableSessionSharing), 109},
    {sipName_SslOptionDisableSessionTickets, static_cast<int>( ::QSsl::SslOptionDisableSessionTickets), 109},
    {sipName_SslV2, static_cast<int>( ::QSsl::SslV2), 111},
    {sipName_SslV3, static_cast<int>( ::QSsl::SslV3), 111},
    {sipName_TlsV1SslV3, static_cast<int>( ::QSsl::TlsV1SslV3), 111},
    {sipName_TlsV1_0, static_cast<int>( ::QSsl::TlsV1_0), 111},
    {sipName_TlsV1_0OrLater, static_cast<int>( ::QSsl::TlsV1_0OrLater), 111},
    {sipName_TlsV1_1, static_cast<int>( ::QSsl::TlsV1_1), 111},
    {sipName_TlsV1_1OrLater, static_cast<int>( ::QSsl::TlsV1_1OrLater), 111},
    {sipName_TlsV1_2, static_cast<int>( ::QSsl::TlsV1_2), 111},
    {sipName_TlsV1_2OrLater, static_cast<int>( ::QSsl::TlsV1_2OrLater), 111},
    {sipName_TlsV1_3, static_cast<int>( ::QSsl::TlsV1_3), 111},
    {sipName_TlsV1_3OrLater, static_cast<int>( ::QSsl::TlsV1_3OrLater), 111},
    {sipName_UnknownProtocol, static_cast<int>( ::QSsl::UnknownProtocol), 111},
};


static pyqt5ClassPluginDef plugin_QSsl = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QSsl = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_NAMESPACE,
        sipNameNr_QSsl,
        {SIP_NULLPTR},
        &plugin_QSsl
    },
    {
        sipNameNr_QSsl,
        {0, 0, 1},
        0, SIP_NULLPTR,
        36, enummembers_QSsl,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 29 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qpassworddigestor.sip"
#include <qpassworddigestor.h>
#line 19838 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 19842 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qcryptographichash.sip"
#include <qcryptographichash.h>
#line 19845 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


PyDoc_STRVAR(doc_QPasswordDigestor_deriveKeyPbkdf2, "deriveKeyPbkdf2(QCryptographicHash.Algorithm, Union[QByteArray, bytes, bytearray], Union[QByteArray, bytes, bytearray], int, int) -> QByteArray");

extern "C" {static PyObject *meth_QPasswordDigestor_deriveKeyPbkdf2(PyObject *, PyObject *);}
static PyObject *meth_QPasswordDigestor_deriveKeyPbkdf2(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QCryptographicHash::Algorithm a0;
        const  ::QByteArray* a1;
        int a1State = 0;
        const  ::QByteArray* a2;
        int a2State = 0;
        int a3;
         ::quint64 a4;

        if (sipParseArgs(&sipParseErr, sipArgs, "EJ1J1io", sipType_QCryptographicHash_Algorithm, &a0, sipType_QByteArray, &a1, &a1State, sipType_QByteArray, &a2, &a2State, &a3, &a4))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray( ::QPasswordDigestor::deriveKeyPbkdf2(a0,*a1,*a2,a3,a4));
            sipReleaseType(const_cast< ::QByteArray *>(a1),sipType_QByteArray,a1State);
            sipReleaseType(const_cast< ::QByteArray *>(a2),sipType_QByteArray,a2State);

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_deriveKeyPbkdf2, doc_QPasswordDigestor_deriveKeyPbkdf2);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QPasswordDigestor_deriveKeyPbkdf1, "deriveKeyPbkdf1(QCryptographicHash.Algorithm, Union[QByteArray, bytes, bytearray], Union[QByteArray, bytes, bytearray], int, int) -> QByteArray");

extern "C" {static PyObject *meth_QPasswordDigestor_deriveKeyPbkdf1(PyObject *, PyObject *);}
static PyObject *meth_QPasswordDigestor_deriveKeyPbkdf1(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QCryptographicHash::Algorithm a0;
        const  ::QByteArray* a1;
        int a1State = 0;
        const  ::QByteArray* a2;
        int a2State = 0;
        int a3;
         ::quint64 a4;

        if (sipParseArgs(&sipParseErr, sipArgs, "EJ1J1io", sipType_QCryptographicHash_Algorithm, &a0, sipType_QByteArray, &a1, &a1State, sipType_QByteArray, &a2, &a2State, &a3, &a4))
        {
             ::QByteArray*sipRes;

            sipRes = new  ::QByteArray( ::QPasswordDigestor::deriveKeyPbkdf1(a0,*a1,*a2,a3,a4));
            sipReleaseType(const_cast< ::QByteArray *>(a1),sipType_QByteArray,a1State);
            sipReleaseType(const_cast< ::QByteArray *>(a2),sipType_QByteArray,a2State);

            return sipConvertFromNewType(sipRes,sipType_QByteArray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_deriveKeyPbkdf1, doc_QPasswordDigestor_deriveKeyPbkdf1);

    return SIP_NULLPTR;
}


static PyMethodDef methods_QPasswordDigestor[] = {
    {SIP_MLNAME_CAST(sipName_deriveKeyPbkdf1), meth_QPasswordDigestor_deriveKeyPbkdf1, METH_VARARGS, SIP_MLDOC_CAST(doc_QPasswordDigestor_deriveKeyPbkdf1)},
    {SIP_MLNAME_CAST(sipName_deriveKeyPbkdf2), meth_QPasswordDigestor_deriveKeyPbkdf2, METH_VARARGS, SIP_MLDOC_CAST(doc_QPasswordDigestor_deriveKeyPbkdf2)}
};


static pyqt5ClassPluginDef plugin_QPasswordDigestor = {
    SIP_NULLPTR,
    0,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QPasswordDigestor = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_NAMESPACE,
        sipNameNr_QPasswordDigestor,
        {SIP_NULLPTR},
        &plugin_QPasswordDigestor
    },
    {
        sipNameNr_QPasswordDigestor,
        {0, 0, 1},
        2, methods_QPasswordDigestor,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworksession.sip"
#include <qnetworksession.h>
#line 19985 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworksession.sip"
#include <qnetworksession.h>
#line 19989 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


extern "C" {static long slot_QNetworkSession_UsagePolicies___hash__(PyObject *);}
static long slot_QNetworkSession_UsagePolicies___hash__(PyObject *sipSelf)
{
     ::QNetworkSession::UsagePolicies *sipCpp = reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QNetworkSession_UsagePolicies));

    if (!sipCpp)
        return 0L;


    {
        {
            long sipRes = 0;

#line 116 "sip/QtCore/qglobal.sip"
        sipRes = sipCpp->operator QNetworkSession::UsagePolicies::Int();
#line 20007 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            return sipRes;
        }
    }

    return 0;
}


extern "C" {static int slot_QNetworkSession_UsagePolicies___bool__(PyObject *);}
static int slot_QNetworkSession_UsagePolicies___bool__(PyObject *sipSelf)
{
     ::QNetworkSession::UsagePolicies *sipCpp = reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QNetworkSession_UsagePolicies));

    if (!sipCpp)
        return -1;


    {
        {
            int sipRes = 0;

#line 111 "sip/QtCore/qglobal.sip"
        sipRes = (sipCpp->operator QNetworkSession::UsagePolicies::Int() != 0);
#line 20032 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            return sipRes;
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_QNetworkSession_UsagePolicies___ne__(PyObject *,PyObject *);}
static PyObject *slot_QNetworkSession_UsagePolicies___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QNetworkSession::UsagePolicies *sipCpp = reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QNetworkSession_UsagePolicies));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession::UsagePolicies* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J1", sipType_QNetworkSession_UsagePolicies, &a0, &a0State))
        {
            bool sipRes = 0;

#line 106 "sip/QtCore/qglobal.sip"
        sipRes = (sipCpp->operator QNetworkSession::UsagePolicies::Int() != a0->operator QNetworkSession::UsagePolicies::Int());
#line 20062 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
            sipReleaseType(const_cast< ::QNetworkSession::UsagePolicies *>(a0),sipType_QNetworkSession_UsagePolicies,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, ne_slot, sipType_QNetworkSession_UsagePolicies, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QNetworkSession_UsagePolicies___eq__(PyObject *,PyObject *);}
static PyObject *slot_QNetworkSession_UsagePolicies___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QNetworkSession::UsagePolicies *sipCpp = reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QNetworkSession_UsagePolicies));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession::UsagePolicies* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J1", sipType_QNetworkSession_UsagePolicies, &a0, &a0State))
        {
            bool sipRes = 0;

#line 101 "sip/QtCore/qglobal.sip"
        sipRes = (sipCpp->operator QNetworkSession::UsagePolicies::Int() == a0->operator QNetworkSession::UsagePolicies::Int());
#line 20098 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
            sipReleaseType(const_cast< ::QNetworkSession::UsagePolicies *>(a0),sipType_QNetworkSession_UsagePolicies,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, eq_slot, sipType_QNetworkSession_UsagePolicies, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QNetworkSession_UsagePolicies___ixor__(PyObject *,PyObject *);}
static PyObject *slot_QNetworkSession_UsagePolicies___ixor__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_QNetworkSession_UsagePolicies)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::QNetworkSession::UsagePolicies *sipCpp = reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QNetworkSession_UsagePolicies));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
#line 95 "sip/QtCore/qglobal.sip"
        *sipCpp = QNetworkSession::UsagePolicies(*sipCpp ^ a0);
#line 20137 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_QNetworkSession_UsagePolicies___xor__(PyObject *,PyObject *);}
static PyObject *slot_QNetworkSession_UsagePolicies___xor__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkSession::UsagePolicies* a0;
        int a0State = 0;
        int a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J1i", sipType_QNetworkSession_UsagePolicies, &a0, &a0State, &a1))
        {
             ::QNetworkSession::UsagePolicies*sipRes;

            sipRes = new  ::QNetworkSession::UsagePolicies((*a0 ^ a1));
            sipReleaseType(a0,sipType_QNetworkSession_UsagePolicies,a0State);

            return sipConvertFromNewType(sipRes,sipType_QNetworkSession_UsagePolicies,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, xor_slot, SIP_NULLPTR, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_QNetworkSession_UsagePolicies___ior__(PyObject *,PyObject *);}
static PyObject *slot_QNetworkSession_UsagePolicies___ior__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_QNetworkSession_UsagePolicies)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::QNetworkSession::UsagePolicies *sipCpp = reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QNetworkSession_UsagePolicies));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
#line 89 "sip/QtCore/qglobal.sip"
        *sipCpp = QNetworkSession::UsagePolicies(*sipCpp | a0);
#line 20209 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_QNetworkSession_UsagePolicies___or__(PyObject *,PyObject *);}
static PyObject *slot_QNetworkSession_UsagePolicies___or__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkSession::UsagePolicies* a0;
        int a0State = 0;
        int a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J1i", sipType_QNetworkSession_UsagePolicies, &a0, &a0State, &a1))
        {
             ::QNetworkSession::UsagePolicies*sipRes;

            sipRes = new  ::QNetworkSession::UsagePolicies((*a0 | a1));
            sipReleaseType(a0,sipType_QNetworkSession_UsagePolicies,a0State);

            return sipConvertFromNewType(sipRes,sipType_QNetworkSession_UsagePolicies,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, or_slot, SIP_NULLPTR, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_QNetworkSession_UsagePolicies___iand__(PyObject *,PyObject *);}
static PyObject *slot_QNetworkSession_UsagePolicies___iand__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_QNetworkSession_UsagePolicies)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::QNetworkSession::UsagePolicies *sipCpp = reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QNetworkSession_UsagePolicies));

    if (!sipCpp)
        return SIP_NULLPTR;

    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
            sipCpp-> ::QNetworkSession::UsagePolicies::operator&=(a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_QNetworkSession_UsagePolicies___and__(PyObject *,PyObject *);}
static PyObject *slot_QNetworkSession_UsagePolicies___and__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkSession::UsagePolicies* a0;
        int a0State = 0;
        int a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J1i", sipType_QNetworkSession_UsagePolicies, &a0, &a0State, &a1))
        {
             ::QNetworkSession::UsagePolicies*sipRes;

            sipRes = new  ::QNetworkSession::UsagePolicies((*a0 & a1));
            sipReleaseType(a0,sipType_QNetworkSession_UsagePolicies,a0State);

            return sipConvertFromNewType(sipRes,sipType_QNetworkSession_UsagePolicies,SIP_NULLPTR);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return SIP_NULLPTR;

    return sipPySlotExtend(&sipModuleAPI_QtNetwork, and_slot, SIP_NULLPTR, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_QNetworkSession_UsagePolicies___invert__(PyObject *);}
static PyObject *slot_QNetworkSession_UsagePolicies___invert__(PyObject *sipSelf)
{
     ::QNetworkSession::UsagePolicies *sipCpp = reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QNetworkSession_UsagePolicies));

    if (!sipCpp)
        return SIP_NULLPTR;


    {
        {
             ::QNetworkSession::UsagePolicies*sipRes;

            sipRes = new  ::QNetworkSession::UsagePolicies(~(*sipCpp));

            return sipConvertFromNewType(sipRes,sipType_QNetworkSession_UsagePolicies,SIP_NULLPTR);
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_QNetworkSession_UsagePolicies___int__(PyObject *);}
static PyObject *slot_QNetworkSession_UsagePolicies___int__(PyObject *sipSelf)
{
     ::QNetworkSession::UsagePolicies *sipCpp = reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QNetworkSession_UsagePolicies));

    if (!sipCpp)
        return SIP_NULLPTR;


    {
        {
            int sipRes;

            sipRes = *sipCpp;

            return SIPLong_FromLong(sipRes);
        }
    }

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_QNetworkSession_UsagePolicies(void *, int);}
static void release_QNetworkSession_UsagePolicies(void *sipCppV, int)
{
    delete reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipCppV);
}


extern "C" {static void assign_QNetworkSession_UsagePolicies(void *, SIP_SSIZE_T, void *);}
static void assign_QNetworkSession_UsagePolicies(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QNetworkSession::UsagePolicies *>(sipSrc);
}


extern "C" {static void *array_QNetworkSession_UsagePolicies(SIP_SSIZE_T);}
static void *array_QNetworkSession_UsagePolicies(SIP_SSIZE_T sipNrElem)
{
    return new  ::QNetworkSession::UsagePolicies[sipNrElem];
}


extern "C" {static void *copy_QNetworkSession_UsagePolicies(const void *, SIP_SSIZE_T);}
static void *copy_QNetworkSession_UsagePolicies(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QNetworkSession::UsagePolicies(reinterpret_cast<const  ::QNetworkSession::UsagePolicies *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QNetworkSession_UsagePolicies(sipSimpleWrapper *);}
static void dealloc_QNetworkSession_UsagePolicies(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QNetworkSession_UsagePolicies(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QNetworkSession_UsagePolicies(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QNetworkSession_UsagePolicies(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QNetworkSession::UsagePolicies *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new  ::QNetworkSession::UsagePolicies();

            return sipCpp;
        }
    }

    {
        int a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "i", &a0))
        {
            sipCpp = new  ::QNetworkSession::UsagePolicies(a0);

            return sipCpp;
        }
    }

    {
        const  ::QNetworkSession::UsagePolicies* a0;
        int a0State = 0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J1", sipType_QNetworkSession_UsagePolicies, &a0, &a0State))
        {
            sipCpp = new  ::QNetworkSession::UsagePolicies(*a0);
            sipReleaseType(const_cast< ::QNetworkSession::UsagePolicies *>(a0),sipType_QNetworkSession_UsagePolicies,a0State);

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


extern "C" {static int convertTo_QNetworkSession_UsagePolicies(PyObject *, void **, int *, PyObject *);}
static int convertTo_QNetworkSession_UsagePolicies(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
     ::QNetworkSession::UsagePolicies **sipCppPtr = reinterpret_cast< ::QNetworkSession::UsagePolicies **>(sipCppPtrV);

#line 121 "sip/QtCore/qglobal.sip"
// Allow an instance of the base enum whenever a QNetworkSession::UsagePolicies is expected.

if (sipIsErr == NULL)
    return (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_QNetworkSession_UsagePolicy)) ||
            sipCanConvertToType(sipPy, sipType_QNetworkSession_UsagePolicies, SIP_NO_CONVERTORS));

if (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_QNetworkSession_UsagePolicy)))
{
    *sipCppPtr = new QNetworkSession::UsagePolicies(int(SIPLong_AsLong(sipPy)));

    return sipGetState(sipTransferObj);
}

*sipCppPtr = reinterpret_cast<QNetworkSession::UsagePolicies *>(sipConvertToType(sipPy, sipType_QNetworkSession_UsagePolicies, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
#line 20477 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QNetworkSession_UsagePolicies[] = {
    {(void *)slot_QNetworkSession_UsagePolicies___hash__, hash_slot},
    {(void *)slot_QNetworkSession_UsagePolicies___bool__, bool_slot},
    {(void *)slot_QNetworkSession_UsagePolicies___ne__, ne_slot},
    {(void *)slot_QNetworkSession_UsagePolicies___eq__, eq_slot},
    {(void *)slot_QNetworkSession_UsagePolicies___ixor__, ixor_slot},
    {(void *)slot_QNetworkSession_UsagePolicies___xor__, xor_slot},
    {(void *)slot_QNetworkSession_UsagePolicies___ior__, ior_slot},
    {(void *)slot_QNetworkSession_UsagePolicies___or__, or_slot},
    {(void *)slot_QNetworkSession_UsagePolicies___iand__, iand_slot},
    {(void *)slot_QNetworkSession_UsagePolicies___and__, and_slot},
    {(void *)slot_QNetworkSession_UsagePolicies___invert__, invert_slot},
    {(void *)slot_QNetworkSession_UsagePolicies___int__, int_slot},
    {0, (sipPySlotType)0}
};

PyDoc_STRVAR(doc_QNetworkSession_UsagePolicies, "\1QNetworkSession.UsagePolicies()\n"
"QNetworkSession.UsagePolicies(Union[QNetworkSession.UsagePolicies, QNetworkSession.UsagePolicy])\n"
"QNetworkSession.UsagePolicies(QNetworkSession.UsagePolicies)");


static pyqt5ClassPluginDef plugin_QNetworkSession_UsagePolicies = {
    SIP_NULLPTR,
    1,
    SIP_NULLPTR,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QNetworkSession_UsagePolicies = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QNetworkSession__UsagePolicies,
        {SIP_NULLPTR},
        &plugin_QNetworkSession_UsagePolicies
    },
    {
        sipNameNr_UsagePolicies,
        {97, 255, 0},
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QNetworkSession_UsagePolicies,
    -1,
    sipNameNr_sip_simplewrapper,
    SIP_NULLPTR,
    slots_QNetworkSession_UsagePolicies,
    init_type_QNetworkSession_UsagePolicies,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QNetworkSession_UsagePolicies,
    assign_QNetworkSession_UsagePolicies,
    array_QNetworkSession_UsagePolicies,
    copy_QNetworkSession_UsagePolicies,
    release_QNetworkSession_UsagePolicies,
    SIP_NULLPTR,
    convertTo_QNetworkSession_UsagePolicies,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworksession.sip"
#include <qnetworksession.h>
#line 20565 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"

#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkconfiguration.sip"
#include <qnetworkconfiguration.h>
#line 20569 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 28 "sip/QtCore/qobject.sip"
#include <qobject.h>
#line 20572 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworksession.sip"
#include <qnetworksession.h>
#line 20575 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 20578 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 27 "sip/QtCore/qstring.sip"
#include <qstring.h>
#line 20581 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 20584 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 86 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/sip/QtNetwork/qnetworkinterface.sip"
#include <qnetworkinterface.h>
#line 20587 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 20590 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 247 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 20593 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 235 "sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 20596 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 38 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 20599 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 30 "sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 20602 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 149 "sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 20605 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 20608 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qthread.sip"
#include <qthread.h>
#line 20611 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 20614 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 20617 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 20620 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"
#line 26 "sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 20623 "/media/art/data/SourceCode/UBUCON/src/sysroot-android-32/build/PyQt5_gpl-5.12/QtNetwork/sipQtNetworkpart0.cpp"


class sipQNetworkSession : public  ::QNetworkSession
{
public:
    sipQNetworkSession(const  ::QNetworkConfiguration&, ::QObject*);
    virtual ~sipQNetworkSession();

    int qt_metacall(QMetaObject::Call, int, void **) SIP_OVERRIDE;
    void *qt_metacast(const char *) SIP_OVERRIDE;
    const QMetaObject *metaObject() const SIP_OVERRIDE;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool event( ::QEvent*) SIP_OVERRIDE;
    bool eventFilter( ::QObject*, ::QEvent*) SIP_OVERRIDE;
    void timerEvent( ::QTimerEvent*) SIP_OVERRIDE;
    void childEvent( ::QChildEvent*) SIP_OVERRIDE;
    void customEvent( ::QEvent*) SIP_OVERRIDE;
    void connectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;
    void disconnectNotify(const  ::QMetaMethod&) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQNetworkSession(const sipQNetworkSession &);
    sipQNetworkSession &operator = (const sipQNetworkSession &);

    char sipPyMethods[7];
};

sipQNetworkSession::sipQNetworkSession(const  ::QNetworkConfiguration& a0, ::QObject*a1):  ::QNetworkSession(a0,a1), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQNetworkSession::~sipQNetworkSession()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQNetworkSession::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtNetwork_qt_metaobject(sipPySelf,sipType_QNetworkSession);

    return  ::QNetworkSession::metaObject();
}

int sipQNetworkSession::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QNetworkSession::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtNetwork_qt_metacall(sipPySelf,sipType_QNetworkSession,_c,_id,_a);

    return _id;
}

void *sipQNetworkSession::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtNetwork_qt_metacast(sipPySelf, sipType_QNetworkSession, _clname, &sipCpp) ? sipCpp :  ::QNetworkSession::qt_metacast(_clname));
}

bool sipQNetworkSession::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_event);

    if (!sipMeth)
        return  ::QNetworkSession::event(a0);

    extern bool sipVH_QtNetwork_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtNetwork_5(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQNetworkSession::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_eventFilter);

    if (!sipMeth)
        return  ::QNetworkSession::eventFilter(a0,a1);

    extern bool sipVH_QtNetwork_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtNetwork_4(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

void sipQNetworkSession::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QNetworkSession::timerEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtNetwork_3(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQNetworkSession::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_childEvent);

    if (!sipMeth)
    {
         ::QNetworkSession::childEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtNetwork_2(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQNetworkSession::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_customEvent);

    if (!sipMeth)
    {
         ::QNetworkSession::customEvent(a0);
        return;
    }

    extern void sipVH_QtNetwork_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtNetwork_1(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQNetworkSession::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QNetworkSession::connectNotify(a0);
        return;
    }

    extern void sipVH_QtNetwork_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtNetwork_0(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQNetworkSession::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,SIP_NULLPTR,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QNetworkSession::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtNetwork_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtNetwork_0(sipGILState, sipImportedVirtErrorHandlers_QtNetwork_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QNetworkSession_isOpen, "isOpen(self) -> bool");

extern "C" {static PyObject *meth_QNetworkSession_isOpen(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_isOpen(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isOpen();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_isOpen, doc_QNetworkSession_isOpen);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_configuration, "configuration(self) -> QNetworkConfiguration");

extern "C" {static PyObject *meth_QNetworkSession_configuration(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_configuration(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
             ::QNetworkConfiguration*sipRes;

            sipRes = new  ::QNetworkConfiguration(sipCpp->configuration());

            return sipConvertFromNewType(sipRes,sipType_QNetworkConfiguration,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_configuration, doc_QNetworkSession_configuration);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_interface, "interface(self) -> QNetworkInterface");

extern "C" {static PyObject *meth_QNetworkSession_interface(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_interface(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
             ::QNetworkInterface*sipRes;

            sipRes = new  ::QNetworkInterface(sipCpp->interface());

            return sipConvertFromNewType(sipRes,sipType_QNetworkInterface,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_interface, doc_QNetworkSession_interface);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_state, "state(self) -> QNetworkSession.State");

extern "C" {static PyObject *meth_QNetworkSession_state(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_state(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
             ::QNetworkSession::State sipRes;

            sipRes = sipCpp->state();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QNetworkSession_State);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_state, doc_QNetworkSession_state);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_error, "error(self) -> QNetworkSession.SessionError");

extern "C" {static PyObject *meth_QNetworkSession_error(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_error(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
             ::QNetworkSession::SessionError sipRes;

            sipRes = sipCpp->error();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QNetworkSession_SessionError);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_error, doc_QNetworkSession_error);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_errorString, "errorString(self) -> str");

extern "C" {static PyObject *meth_QNetworkSession_errorString(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_errorString(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->errorString());

            return sipConvertFromNewType(sipRes,sipType_QString,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_errorString, doc_QNetworkSession_errorString);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_sessionProperty, "sessionProperty(self, str) -> Any");

extern "C" {static PyObject *meth_QNetworkSession_sessionProperty(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_sessionProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QNetworkSession, &sipCpp, sipType_QString,&a0, &a0State))
        {
             ::QVariant*sipRes;

            sipRes = new  ::QVariant(sipCpp->sessionProperty(*a0));
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return sipConvertFromNewType(sipRes,sipType_QVariant,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_sessionProperty, doc_QNetworkSession_sessionProperty);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_setSessionProperty, "setSessionProperty(self, str, Any)");

extern "C" {static PyObject *meth_QNetworkSession_setSessionProperty(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_setSessionProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QVariant* a1;
        int a1State = 0;
         ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J1", &sipSelf, sipType_QNetworkSession, &sipCpp, sipType_QString,&a0, &a0State, sipType_QVariant, &a1, &a1State))
        {
            sipCpp->setSessionProperty(*a0,*a1);
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QVariant *>(a1),sipType_QVariant,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_setSessionProperty, doc_QNetworkSession_setSessionProperty);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_bytesWritten, "bytesWritten(self) -> int");

extern "C" {static PyObject *meth_QNetworkSession_bytesWritten(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_bytesWritten(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
             ::quint64 sipRes;

            sipRes = sipCpp->bytesWritten();

            return PyLong_FromUnsignedLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_bytesWritten, doc_QNetworkSession_bytesWritten);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_bytesReceived, "bytesReceived(self) -> int");

extern "C" {static PyObject *meth_QNetworkSession_bytesReceived(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_bytesReceived(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
             ::quint64 sipRes;

            sipRes = sipCpp->bytesReceived();

            return PyLong_FromUnsignedLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_bytesReceived, doc_QNetworkSession_bytesReceived);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_activeTime, "activeTime(self) -> int");

extern "C" {static PyObject *meth_QNetworkSession_activeTime(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_activeTime(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
             ::quint64 sipRes;

            sipRes = sipCpp->activeTime();

            return PyLong_FromUnsignedLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_activeTime, doc_QNetworkSession_activeTime);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_waitForOpened, "waitForOpened(self, msecs: int = 30000) -> bool");

extern "C" {static PyObject *meth_QNetworkSession_waitForOpened(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_waitForOpened(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int a0 = 30000;
         ::QNetworkSession *sipCpp;

        static const char *sipKwdList[] = {
            sipName_msecs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_QNetworkSession, &sipCpp, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->waitForOpened(a0);
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_waitForOpened, doc_QNetworkSession_waitForOpened);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_open, "open(self)");

extern "C" {static PyObject *meth_QNetworkSession_open(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_open(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
            sipCpp->open();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_open, doc_QNetworkSession_open);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_close, "close(self)");

extern "C" {static PyObject *meth_QNetworkSession_close(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_close(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
            sipCpp->close();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_close, doc_QNetworkSession_close);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_stop, "stop(self)");

extern "C" {static PyObject *meth_QNetworkSession_stop(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_stop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
            sipCpp->stop();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_stop, doc_QNetworkSession_stop);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_migrate, "migrate(self)");

extern "C" {static PyObject *meth_QNetworkSession_migrate(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_migrate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
            sipCpp->migrate();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_migrate, doc_QNetworkSession_migrate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_ignore, "ignore(self)");

extern "C" {static PyObject *meth_QNetworkSession_ignore(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_ignore(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
            sipCpp->ignore();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_ignore, doc_QNetworkSession_ignore);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_accept, "accept(self)");

extern "C" {static PyObject *meth_QNetworkSession_accept(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_accept(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
            sipCpp->accept();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_accept, doc_QNetworkSession_accept);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_reject, "reject(self)");

extern "C" {static PyObject *meth_QNetworkSession_reject(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_reject(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
            sipCpp->reject();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_reject, doc_QNetworkSession_reject);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_connectNotify, "connectNotify(self, QMetaMethod)");

extern "C" {static PyObject *meth_QNetworkSession_connectNotify(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_connectNotify(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QMetaMethod* a0;
         ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ9", &sipSelf, sipType_QNetworkSession, &sipCpp, sipType_QMetaMethod, &a0))
        {
            (sipSelfWasArg ? sipCpp-> ::QNetworkSession::connectNotify(*a0) : sipCpp->connectNotify(*a0));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_connectNotify, doc_QNetworkSession_connectNotify);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_disconnectNotify, "disconnectNotify(self, QMetaMethod)");

extern "C" {static PyObject *meth_QNetworkSession_disconnectNotify(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_disconnectNotify(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QMetaMethod* a0;
         ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ9", &sipSelf, sipType_QNetworkSession, &sipCpp, sipType_QMetaMethod, &a0))
        {
            (sipSelfWasArg ? sipCpp-> ::QNetworkSession::disconnectNotify(*a0) : sipCpp->disconnectNotify(*a0));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_disconnectNotify, doc_QNetworkSession_disconnectNotify);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_QNetworkSession_usagePolicies, "usagePolicies(self) -> QNetworkSession.UsagePolicies");

extern "C" {static PyObject *meth_QNetworkSession_usagePolicies(PyObject *, PyObject *);}
static PyObject *meth_QNetworkSession_usagePolicies(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::QNetworkSession *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QNetworkSession, &sipCpp))
        {
             ::QNetworkSession::UsagePolicies*sipRes;

            sipRes = new  ::QNetworkSession::UsagePolicies(sipCpp->usagePolicies());

            return sipConvertFromNewType(sipRes,sipType_QNetworkSession_UsagePolicies,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QNetworkSession, sipName_usagePolicies, doc_QNetworkSession_usagePolicies);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QNetworkSession(void *, const sipTypeDef *);}
static void *cast_QNetworkSession(void *sipCppV, const sipTypeDef *targetType)
{
     ::QNetworkSession *sipCpp = reinterpret_cast< ::QNetworkSession *>(sipCppV);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QNetworkSession(void *, int);}
static void release_QNetworkSession(void *sipCppV, int)
{
     ::QNetworkSession *sipCpp = reinterpret_cast< ::QNetworkSession *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static void dealloc_QNetworkSession(sipSimpleWrapper *);}
static void dealloc_QNetworkSession(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQNetworkSession *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QNetworkSession(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QNetworkSession(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QNetworkSession(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQNetworkSession *sipCpp = SIP_NULLPTR;

    {
        const  ::QNetworkConfiguration* a0;
         ::QObject* a1 = 0;

        static const char *sipKwdList[] = {
            SIP_NULLPTR,
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|JH", sipType_QNetworkConfiguration, &a0, sipType_QObject, &a1, sipOwner))
        {
            sipCpp = new sipQNetworkSession(*a0,a1);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QNetworkSession[] = {{12, 0, 1}};


static PyMethodDef methods_QNetworkSession[] = {
    {SIP_MLNAME_CAST(sipName_accept), meth_QNetworkSession_accept, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_accept)},
    {SIP_MLNAME_CAST(sipName_activeTime), meth_QNetworkSession_activeTime, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_activeTime)},
    {SIP_MLNAME_CAST(sipName_bytesReceived), meth_QNetworkSession_bytesReceived, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_bytesReceived)},
    {SIP_MLNAME_CAST(sipName_bytesWritten), meth_QNetworkSession_bytesWritten, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_bytesWritten)},
    {SIP_MLNAME_CAST(sipName_close), meth_QNetworkSession_close, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_close)},
    {SIP_MLNAME_CAST(sipName_configuration), meth_QNetworkSession_configuration, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_configuration)},
    {SIP_MLNAME_CAST(sipName_connectNotify), meth_QNetworkSession_connectNotify, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_connectNotify)},
    {SIP_MLNAME_CAST(sipName_disconnectNotify), meth_QNetworkSession_disconnectNotify, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_disconnectNotify)},
    {SIP_MLNAME_CAST(sipName_error), meth_QNetworkSession_error, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_error)},
    {SIP_MLNAME_CAST(sipName_errorString), meth_QNetworkSession_errorString, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_errorString)},
    {SIP_MLNAME_CAST(sipName_ignore), meth_QNetworkSession_ignore, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_ignore)},
    {SIP_MLNAME_CAST(sipName_interface), meth_QNetworkSession_interface, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_interface)},
    {SIP_MLNAME_CAST(sipName_isOpen), meth_QNetworkSession_isOpen, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_isOpen)},
    {SIP_MLNAME_CAST(sipName_migrate), meth_QNetworkSession_migrate, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_migrate)},
    {SIP_MLNAME_CAST(sipName_open), meth_QNetworkSession_open, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_open)},
    {SIP_MLNAME_CAST(sipName_reject), meth_QNetworkSession_reject, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_reject)},
    {SIP_MLNAME_CAST(sipName_sessionProperty), meth_QNetworkSession_sessionProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_sessionProperty)},
    {SIP_MLNAME_CAST(sipName_setSessionProperty), meth_QNetworkSession_setSessionProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_setSessionProperty)},
    {SIP_MLNAME_CAST(sipName_state), meth_QNetworkSession_state, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_state)},
    {SIP_MLNAME_CAST(sipName_stop), meth_QNetworkSession_stop, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_stop)},
    {SIP_MLNAME_CAST(sipName_usagePolicies), meth_QNetworkSession_usagePolicies, METH_VARARGS, SIP_MLDOC_CAST(doc_QNetworkSession_usagePolicies)},
    {SIP_MLNAME_CAST(sipName_waitForOpened), SIP_MLMETH_CAST(meth_QNetworkSession_waitForOpened), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QNetworkSession_waitForOpened)}
};

static sipEnumMemberDef enummembers_QNetworkSession[] = {
    {sipName_Closing, static_cast<int>( ::QNetworkSession::Closing), 99},
    {sipName_Connected, static_cast<int>( ::QNetworkSession::Connected), 99},
    {sipName_Connecting, static_cast<int>( ::QNetworkSession::Connecting), 99},
    {sipName_Disconnected, static_cast<int>( ::QNetworkSession::Disconnected), 99},
    {sipName_Invalid, static_cast<int>( ::QNetworkSession::Invalid), 99},
    {sipName_InvalidConfigurationError, static_cast<int>( ::QNetworkSession::InvalidConfigurationError), 98},
    {sipName_NoBackgroundTrafficPolicy, static_cast<int>( ::QNetworkSession::NoBackgroundTrafficPolicy), 101},
    {sipName_NoPolicy, static_cast<int>( ::QNetworkSession::NoPolicy), 101},
    {sipName_NotAvailable, static_cast<int>( ::QNetworkSession::NotAvailable), 99},
    {sipName_OperationNotSupportedError, static_cast<int>( ::QNetworkSession::OperationNotSupportedError), 98},
    {sipName_Roaming, static_cast<int>( ::QNetworkSession::Roaming), 99},
    {sipName_RoamingError, static_cast<int>( ::QNetworkSession::RoamingError), 98},
    {sipName_SessionAbortedError, static_cast<int>( ::QNetworkSession::SessionAbortedError), 98},
    {sipName_UnknownSessionError, static_cast<int>( ::QNetworkSession::UnknownSessionError), 98},
};

PyDoc_STRVAR(doc_QNetworkSession, "\1QNetworkSession(QNetworkConfiguration, parent: QObject = None)");


/* Define this type's signals. */
static const pyqt5QtSignal signals_QNetworkSession[] = {
    {"usagePoliciesChanged(QNetworkSession::UsagePolicies)", "\1usagePoliciesChanged(self, Union[QNetworkSession.UsagePolicies, QNetworkSession.UsagePolicy])", SIP_NULLPTR, SIP_NULLPTR},
    {"newConfigurationActivated()", "\1newConfigurationActivated(self)", SIP_NULLPTR, SIP_NULLPTR},
    {"preferredConfigurationChanged(QNetworkConfiguration,bool)", "\1preferredConfigurationChanged(self, QNetworkConfiguration, bool)", SIP_NULLPTR, SIP_NULLPTR},
    {"closed()", "\1closed(self)", SIP_NULLPTR, SIP_NULLPTR},
    {"opened()", "\1opened(self)", SIP_NULLPTR, SIP_NULLPTR},
    {"stateChanged(QNetworkSession::State)", "\1stateChanged(self, QNetworkSession.State)", SIP_NULLPTR, SIP_NULLPTR},
    {"error(QNetworkSession::SessionError)", "\1error(self, QNetworkSession.SessionError)", &methods_QNetworkSession[8], SIP_NULLPTR},
    {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR}
};


static pyqt5ClassPluginDef plugin_QNetworkSession = {
    & ::QNetworkSession::staticMetaObject,
    0,
    signals_QNetworkSession,
    SIP_NULLPTR
};


sipClassTypeDef sipTypeDef_QtNetwork_QNetworkSession = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QNetworkSession,
        {SIP_NULLPTR},
        &plugin_QNetworkSession
    },
    {
        sipNameNr_QNetworkSession,
        {0, 0, 1},
        22, methods_QNetworkSession,
        14, enummembers_QNetworkSession,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_QNetworkSession,
    -1,
    -1,
    supers_QNetworkSession,
    SIP_NULLPTR,
    init_type_QNetworkSession,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_QNetworkSession,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_QNetworkSession,
    cast_QNetworkSession,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};
